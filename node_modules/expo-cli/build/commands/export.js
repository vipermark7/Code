'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.action = undefined;

var _toConsumableArray2;

function _load_toConsumableArray() {
  return _toConsumableArray2 = _interopRequireDefault(require('babel-runtime/helpers/toConsumableArray'));
}

var _promise;

function _load_promise() {
  return _promise = _interopRequireDefault(require('babel-runtime/core-js/promise'));
}

var _regenerator;

function _load_regenerator() {
  return _regenerator = _interopRequireDefault(require('babel-runtime/regenerator'));
}

var _asyncToGenerator2;

function _load_asyncToGenerator() {
  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));
}

var action = exports.action = function () {
  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee2(projectDir) {
    var _this = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var outputPath, status, startedOurOwn, startOpts, exportOptions, absoluteOutputDir, mergeSrcDirs, tmpFolder, downloadDecompressPromises, srcDirs;
    return (_regenerator || _load_regenerator()).default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            outputPath = _path.default.resolve(projectDir, options.outputDir);

            if (!(_fsExtra || _load_fsExtra()).default.existsSync(outputPath)) {
              _context2.next = 3;
              break;
            }

            throw new (_CommandError || _load_CommandError()).default('OUTPUT_DIR_EXISTS', 'Output directory ' + outputPath + ' already exists. Aborting export.');

          case 3:
            if (options.publicUrl) {
              _context2.next = 5;
              break;
            }

            throw new (_CommandError || _load_CommandError()).default('MISSING_PUBLIC_URL', 'Missing required option: --public-url');

          case 5:
            if (!(!options.dev && !(_xdl || _load_xdl()).UrlUtils.isHttps(options.publicUrl))) {
              _context2.next = 9;
              break;
            }

            throw new (_CommandError || _load_CommandError()).default('INVALID_PUBLIC_URL', '--public-url must be a valid HTTPS URL.');

          case 9:
            if (!(_validator || _load_validator()).default.isURL(options.publicUrl, { protocols: ['http', 'https'] })) {
              console.warn('Dev Mode: publicUrl ' + options.publicUrl + ' does not conform to HTTP format.');
            }

          case 10:
            _context2.next = 12;
            return (_xdl || _load_xdl()).Project.currentStatus(projectDir);

          case 12:
            status = _context2.sent;
            startedOurOwn = false;

            if (!(status !== 'running')) {
              _context2.next = 23;
              break;
            }

            (0, (_log || _load_log()).default)('Unable to find an existing Expo CLI instance for this directory, starting a new one...');

            (0, (_exit || _load_exit()).installExitHooks)(projectDir);

            startOpts = { reset: options.clear, nonPersistent: true };

            if (options.maxWorkers) {
              startOpts.maxWorkers = options.maxWorkers;
            }
            (0, (_log || _load_log()).default)('Exporting your app...');
            _context2.next = 22;
            return (_xdl || _load_xdl()).Project.startAsync(projectDir, startOpts, !options.quiet);

          case 22:
            startedOurOwn = true;

          case 23:

            // Make outputDir an absolute path if it isnt already
            exportOptions = {
              dumpAssetmap: options.dumpAssetmap,
              dumpSourcemap: options.dumpSourcemap,
              isDev: options.dev
            };
            absoluteOutputDir = _path.default.resolve(process.cwd(), options.outputDir);
            _context2.next = 27;
            return (_xdl || _load_xdl()).Project.exportForAppHosting(projectDir, options.publicUrl, options.assetUrl, absoluteOutputDir, exportOptions);

          case 27:
            if (!startedOurOwn) {
              _context2.next = 31;
              break;
            }

            (0, (_log || _load_log()).default)('Terminating server processes.');
            _context2.next = 31;
            return (_xdl || _load_xdl()).Project.stopAsync(projectDir);

          case 31:

            // Merge src dirs/urls into a multimanifest if specified
            mergeSrcDirs = [];

            // src urls were specified to merge in, so download and decompress them

            if (!(options.mergeSrcUrl.length > 0)) {
              _context2.next = 41;
              break;
            }

            // delete .tmp if it exists and recreate it anew
            tmpFolder = _path.default.resolve(projectDir, _path.default.join('.tmp'));
            _context2.next = 36;
            return (_fsExtra || _load_fsExtra()).default.remove(tmpFolder);

          case 36:
            _context2.next = 38;
            return (_fsExtra || _load_fsExtra()).default.ensureDir(tmpFolder);

          case 38:

            // Download the urls into a tmp dir
            downloadDecompressPromises = options.mergeSrcUrl.map(function () {
              var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee(url) {
                var uniqFilename, tmpFileCompressed, tmpFolderUncompressed;
                return (_regenerator || _load_regenerator()).default.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        // Add the absolute paths to srcDir
                        uniqFilename = _path.default.basename(url, '.tar.gz') + '_' + _crypto.default.randomBytes(16).toString('hex');
                        tmpFileCompressed = _path.default.resolve(tmpFolder, uniqFilename + '_compressed');
                        tmpFolderUncompressed = _path.default.resolve(tmpFolder, uniqFilename);
                        _context.next = 5;
                        return download(url, tmpFileCompressed);

                      case 5:
                        _context.next = 7;
                        return decompress(tmpFileCompressed, tmpFolderUncompressed);

                      case 7:

                        // add the decompressed folder to be merged
                        mergeSrcDirs.push(tmpFolderUncompressed);

                      case 8:
                      case 'end':
                        return _context.stop();
                    }
                  }
                }, _callee, _this);
              }));

              return function (_x3) {
                return _ref2.apply(this, arguments);
              };
            }());
            _context2.next = 41;
            return (_promise || _load_promise()).default.all(downloadDecompressPromises);

          case 41:

            // add any local src dirs to be merged
            mergeSrcDirs.push.apply(mergeSrcDirs, (0, (_toConsumableArray2 || _load_toConsumableArray()).default)(options.mergeSrcDir));

            if (!(mergeSrcDirs.length > 0)) {
              _context2.next = 48;
              break;
            }

            srcDirs = options.mergeSrcDir.concat(options.mergeSrcUrl).join(' ');

            (0, (_log || _load_log()).default)('Starting project merge of ' + srcDirs + ' into ' + options.outputDir);

            // Merge app distributions
            _context2.next = 47;
            return (_xdl || _load_xdl()).Project.mergeAppDistributions(projectDir, [].concat(mergeSrcDirs, [options.outputDir]), // merge stuff in srcDirs and outputDir together
            options.outputDir);

          case 47:
            (0, (_log || _load_log()).default)('Project merge was successful. Your merged files can be found in ' + options.outputDir);

          case 48:
            (0, (_log || _load_log()).default)('Export was successful. Your exported files can be found in ' + options.outputDir);

          case 49:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));

  return function action(_x) {
    return _ref.apply(this, arguments);
  };
}();

var _axios;

function _load_axios() {
  return _axios = _interopRequireDefault(require('axios'));
}

var _crypto = _interopRequireDefault(require('crypto'));

var _fsExtra;

function _load_fsExtra() {
  return _fsExtra = _interopRequireDefault(require('fs-extra'));
}

var _validator;

function _load_validator() {
  return _validator = _interopRequireDefault(require('validator'));
}

var _path = _interopRequireDefault(require('path'));

var _targz;

function _load_targz() {
  return _targz = _interopRequireDefault(require('targz'));
}

var _util = _interopRequireDefault(require('util'));

var _xdl;

function _load_xdl() {
  return _xdl = require('xdl');
}

var _log;

function _load_log() {
  return _log = _interopRequireDefault(require('../log'));
}

var _exit;

function _load_exit() {
  return _exit = require('../exit');
}

var _CommandError;

function _load_CommandError() {
  return _CommandError = _interopRequireDefault(require('../CommandError'));
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var download = function () {
  var _ref3 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee3(uri, filename) {
    return (_regenerator || _load_regenerator()).default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt('return', new (_promise || _load_promise()).default(function (resolve, reject) {
              (0, (_axios || _load_axios()).default)(uri).pipe((_fsExtra || _load_fsExtra()).default.createWriteStream(filename)).on('close', function () {
                return resolve(null);
              }).on('error', function (err) {
                reject(err);
              });
            }));

          case 1:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, undefined);
  }));

  return function download(_x4, _x5) {
    return _ref3.apply(this, arguments);
  };
}();

var decompress = function () {
  var _ref4 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee4(src, dest) {
    return (_regenerator || _load_regenerator()).default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            return _context4.abrupt('return', new (_promise || _load_promise()).default(function (resolve, reject) {
              (_targz || _load_targz()).default.decompress({
                src: src,
                dest: dest
              }, function (error) {
                if (error) {
                  reject(error);
                } else {
                  resolve(null);
                }
              });
            }));

          case 1:
          case 'end':
            return _context4.stop();
        }
      }
    }, _callee4, undefined);
  }));

  return function decompress(_x6, _x7) {
    return _ref4.apply(this, arguments);
  };
}();

function collect(val, memo) {
  memo.push(val);
  return memo;
}

exports.default = function (program) {
  program.command('export [project-dir]').description('Exports the static files of the app for hosting it on a web server.').option('-p, --public-url <url>', 'The public url that will host the static files. (Required)').option('--output-dir <dir>', 'The directory to export the static files to. Default directory is `dist`', 'dist').option('-a, --asset-url <url>', "The absolute or relative url that will host the asset files. Default is './assets', which will be resolved against the public-url.", './assets').option('-d, --dump-assetmap', 'Dump the asset map for further processing.').option('--dev', 'Configures static files for developing locally using a non-https server').option('-s, --dump-sourcemap', 'Dump the source map for debugging the JS bundle.').option('-q, --quiet', 'Suppress verbose output from the React Native packager.').option('--merge-src-dir [dir]', 'A repeatable source dir to merge in.', collect, []).option('--merge-src-url [url]', 'A repeatable source tar.gz file URL to merge in.', collect, []).option('--max-workers [num]', 'Maximum number of tasks to allow Metro to spawn.').asyncActionProjectDir(action, false, true);
};
//# sourceMappingURL=../__sourcemaps__/commands/export.js.map
