'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator;

function _load_regenerator() {
  return _regenerator = _interopRequireDefault(require('babel-runtime/regenerator'));
}

var _toConsumableArray2;

function _load_toConsumableArray() {
  return _toConsumableArray2 = _interopRequireDefault(require('babel-runtime/helpers/toConsumableArray'));
}

var _keys;

function _load_keys() {
  return _keys = _interopRequireDefault(require('babel-runtime/core-js/object/keys'));
}

var _extends2;

function _load_extends() {
  return _extends2 = _interopRequireDefault(require('babel-runtime/helpers/extends'));
}

var _asyncToGenerator2;

function _load_asyncToGenerator() {
  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));
}

var _lodash;

function _load_lodash() {
  return _lodash = _interopRequireDefault(require('lodash'));
}

var _chalk;

function _load_chalk() {
  return _chalk = _interopRequireDefault(require('chalk'));
}

var _ora;

function _load_ora() {
  return _ora = _interopRequireDefault(require('ora'));
}

var _path = _interopRequireDefault(require('path'));

var _cliTable;

function _load_cliTable() {
  return _cliTable = _interopRequireDefault(require('cli-table'));
}

var _config;

function _load_config() {
  return _config = _interopRequireWildcard(require('@expo/config'));
}

var _xdl;

function _load_xdl() {
  return _xdl = require('@expo/xdl');
}

var _CommandError;

function _load_CommandError() {
  return _CommandError = _interopRequireDefault(require('../../CommandError'));
}

var _urlOpts;

function _load_urlOpts() {
  return _urlOpts = _interopRequireDefault(require('../../urlOpts'));
}

var _appleApi;

function _load_appleApi() {
  return _appleApi = _interopRequireWildcard(require('../build/ios/appleApi'));
}

var _constants;

function _load_constants() {
  return _constants = require('../build/constants');
}

var _fastlane;

function _load_fastlane() {
  return _fastlane = require('../build/ios/appleApi/fastlane');
}

var _selectDistributionCert;

function _load_selectDistributionCert() {
  return _selectDistributionCert = _interopRequireDefault(require('./selectDistributionCert'));
}

var _selectPushKey;

function _load_selectPushKey() {
  return _selectPushKey = _interopRequireDefault(require('./selectPushKey'));
}

var _selectAdhocProvisioningProfile;

function _load_selectAdhocProvisioningProfile() {
  return _selectAdhocProvisioningProfile = _interopRequireDefault(require('./selectAdhocProvisioningProfile'));
}

var _generateBundleIdentifier;

function _load_generateBundleIdentifier() {
  return _generateBundleIdentifier = _interopRequireDefault(require('./generateBundleIdentifier'));
}

var _clientBuildApi;

function _load_clientBuildApi() {
  return _clientBuildApi = require('./clientBuildApi');
}

var _log;

function _load_log() {
  return _log = _interopRequireDefault(require('../../log'));
}

var _prompt;

function _load_prompt() {
  return _prompt = _interopRequireDefault(require('../../prompt'));
}

var _tagger;

function _load_tagger() {
  return _tagger = require('./tagger');
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var IOS = (_constants || _load_constants()).PLATFORMS.IOS;

exports.default = function (program) {
  program.command('client:ios [project-dir]').option('--apple-id <login>', 'Apple ID username (please also set the Apple ID password as EXPO_APPLE_PASSWORD environment variable).').description('Build a custom version of the Expo Client for iOS using your own Apple credentials and install it on your mobile device using Safari.').asyncActionProjectDir(function () {
    var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee2(projectDir, options) {
      var disabledServices, spinner, appJsonPath, appJsonExists, _ref2, exp, disabledReason, authData, user, _ref3, isAllowed, errorMessage, bundleIdentifier, experienceName, context, _ref4, devices, udids, distributionCert, pushKey, provisioningProfile, _disabledReason, table, credentialsList, updateCredentialsFn, CredentialsUpdater, email, _ref6, addUdid, _table, udidPrompt, result;

      return (_regenerator || _load_regenerator()).default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              disabledServices = {
                pushNotifications: {
                  name: 'Push Notifications',
                  reason: 'not yet available until API tokens are supported for the Push Notification system'
                }
              };

              // get custom project manifest if it exists
              // Note: this is the current developer's project, NOT the Expo client's manifest

              spinner = (0, (_ora || _load_ora()).default)('Finding custom configuration for the Expo client...').start();
              appJsonPath = options.config || _path.default.join(projectDir, 'app.json');
              _context2.next = 5;
              return (_config || _load_config()).fileExistsAsync(appJsonPath);

            case 5:
              appJsonExists = _context2.sent;

              if (!appJsonExists) {
                _context2.next = 12;
                break;
              }

              _context2.next = 9;
              return (_config || _load_config()).readConfigJsonAsync(projectDir);

            case 9:
              _context2.t0 = _context2.sent;
              _context2.next = 13;
              break;

            case 12:
              _context2.t0 = {};

            case 13:
              _ref2 = _context2.t0;
              exp = _ref2.exp;


              if (exp) {
                spinner.succeed('Found custom configuration for the Expo client at ' + appJsonPath);
              } else {
                spinner.warn('Unable to find custom configuration for the Expo client');
              }
              if (!(_lodash || _load_lodash()).default.has(exp, 'ios.config.googleMapsApiKey')) {
                disabledReason = exp ? 'ios.config.googleMapsApiKey does not exist in configuration file found in ' + appJsonPath : 'No custom configuration file could be found. You will need to provide a json file with a valid ios.config.googleMapsApiKey field.';

                disabledServices.googleMaps = { name: 'Google Maps', reason: disabledReason };
              }

              _context2.next = 19;
              return (_appleApi || _load_appleApi()).authenticate(options);

            case 19:
              authData = _context2.sent;
              _context2.next = 22;
              return (_xdl || _load_xdl()).User.getCurrentUserAsync();

            case 22:
              user = _context2.sent;
              _context2.next = 25;
              return (0, (_clientBuildApi || _load_clientBuildApi()).isAllowedToBuild)({
                user: user,
                appleTeamId: authData.team.id
              });

            case 25:
              _ref3 = _context2.sent;
              isAllowed = _ref3.isAllowed;
              errorMessage = _ref3.errorMessage;

              if (isAllowed) {
                _context2.next = 30;
                break;
              }

              throw new (_CommandError || _load_CommandError()).default('CLIENT_BUILD_REQUEST_NOT_ALLOWED', 'New Expo Client build request disallowed. Reason: ' + errorMessage);

            case 30:
              bundleIdentifier = (0, (_generateBundleIdentifier || _load_generateBundleIdentifier()).default)(authData.team.id);
              _context2.next = 33;
              return (0, (_clientBuildApi || _load_clientBuildApi()).getExperienceName)({ user: user, appleTeamId: authData.team.id });

            case 33:
              experienceName = _context2.sent;
              context = (0, (_extends2 || _load_extends()).default)({}, authData, {
                bundleIdentifier: bundleIdentifier,
                experienceName: experienceName,
                username: user ? user.username : null
              });
              _context2.next = 37;
              return (_appleApi || _load_appleApi()).ensureAppExists(context, { enablePushNotifications: true });

            case 37:
              _context2.next = 39;
              return (0, (_fastlane || _load_fastlane()).runAction)((_fastlane || _load_fastlane()).travelingFastlane.listDevices, ['--all-ios-profile-devices', context.appleId, context.appleIdPassword, context.team.id]);

            case 39:
              _ref4 = _context2.sent;
              devices = _ref4.devices;
              udids = devices.map(function (device) {
                return device.deviceNumber;
              });
              _context2.next = 44;
              return (0, (_selectDistributionCert || _load_selectDistributionCert()).default)(context);

            case 44:
              distributionCert = _context2.sent;
              _context2.next = 47;
              return (0, (_selectPushKey || _load_selectPushKey()).default)(context);

            case 47:
              pushKey = _context2.sent;
              _context2.next = 50;
              return (0, (_selectAdhocProvisioningProfile || _load_selectAdhocProvisioningProfile()).default)(context, udids, distributionCert.distCertSerialNumber);

            case 50:
              provisioningProfile = _context2.sent;


              // push notifications won't work if we dont have any push creds
              // we also dont store anonymous creds, so user needs to be logged in
              if (pushKey === null || !user) {
                _disabledReason = pushKey === null ? 'you did not upload your push credentials' : 'we require you to be logged in to store push credentials';
                // TODO(quin): remove this when we fix push notifications
                // keep the default push notification reason if we haven't implemented API tokens

                disabledServices.pushNotifications.reason = disabledServices.pushNotifications.reason || _disabledReason;
              }

              if ((0, (_keys || _load_keys()).default)(disabledServices).length > 0) {
                (_log || _load_log()).default.newLine();
                (_log || _load_log()).default.warn('These services will be disabled in your custom Expo Client:');
                table = new (_cliTable || _load_cliTable()).default({ head: ['Service', 'Reason'], style: { head: ['cyan'] } });

                table.push.apply(table, (0, (_toConsumableArray2 || _load_toConsumableArray()).default)((0, (_keys || _load_keys()).default)(disabledServices).map(function (serviceKey) {
                  var service = disabledServices[serviceKey];
                  return [service.name, service.reason];
                })));
                (0, (_log || _load_log()).default)(table.toString());
                (0, (_log || _load_log()).default)('See https://docs.expo.io/versions/latest/guides/adhoc-builds/#optional-additional-configuration-steps for more details.');
              }

              // if user is logged in, then we should update credentials
              credentialsList = [distributionCert, pushKey, provisioningProfile].filter(function (i) {
                return i;
              });

              if (!user) {
                _context2.next = 61;
                break;
              }

              // store all the credentials that we mark for update
              updateCredentialsFn = function () {
                var _ref5 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee(listOfCredentials) {
                  var credentials;
                  return (_regenerator || _load_regenerator()).default.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          if (!(listOfCredentials.length === 0)) {
                            _context.next = 2;
                            break;
                          }

                          return _context.abrupt('return');

                        case 2:
                          credentials = listOfCredentials.reduce(function (acc, credential) {
                            return (0, (_extends2 || _load_extends()).default)({}, acc, credential);
                          }, { teamId: context.team.id });
                          _context.next = 5;
                          return (_xdl || _load_xdl()).Credentials.updateCredentialsForPlatform(IOS, credentials, [], {
                            username: user.username,
                            experienceName: experienceName,
                            bundleIdentifier: bundleIdentifier
                          });

                        case 5:
                        case 'end':
                          return _context.stop();
                      }
                    }
                  }, _callee, undefined);
                }));

                return function updateCredentialsFn(_x3) {
                  return _ref5.apply(this, arguments);
                };
              }();

              CredentialsUpdater = new (_tagger || _load_tagger()).Updater(updateCredentialsFn);
              _context2.next = 59;
              return CredentialsUpdater.updateAllAsync(credentialsList);

            case 59:
              _context2.next = 62;
              break;

            case 61:
              // clear update tags, we dont store credentials for anonymous users
              (0, (_tagger || _load_tagger()).clearTags)(credentialsList);

            case 62:
              email = void 0;

              if (!user) {
                _context2.next = 67;
                break;
              }

              email = user.email;
              _context2.next = 71;
              break;

            case 67:
              _context2.next = 69;
              return (0, (_prompt || _load_prompt()).default)({
                name: 'email',
                message: 'Please enter an email address to notify, when the build is completed:',
                filter: function filter(value) {
                  return value.trim();
                },
                validate: function validate(value) {
                  return (/.+@.+/.test(value) ? true : "That doesn't look like a valid email."
                  );
                }
              });

            case 69:
              _ref6 = _context2.sent;
              email = _ref6.email;

            case 71:
              (_log || _load_log()).default.newLine();

              addUdid = void 0;

              if (!(udids.length === 0)) {
                _context2.next = 78;
                break;
              }

              (0, (_log || _load_log()).default)('There are no devices registered to your Apple Developer account. Please follow the instructions below to register an iOS device.');
              addUdid = true;
              _context2.next = 87;
              break;

            case 78:
              (0, (_log || _load_log()).default)('Custom builds of the Expo Client can only be installed on devices which have been registered with Apple at build-time.');
              (0, (_log || _load_log()).default)('These devices are currently registered on your Apple Developer account:');
              _table = new (_cliTable || _load_cliTable()).default({ head: ['Name', 'Identifier'], style: { head: ['cyan'] } });

              _table.push.apply(_table, (0, (_toConsumableArray2 || _load_toConsumableArray()).default)(devices.map(function (device) {
                return [device.name, device.deviceNumber];
              })));
              (0, (_log || _load_log()).default)(_table.toString());

              _context2.next = 85;
              return (0, (_prompt || _load_prompt()).default)({
                name: 'addUdid',
                message: 'Would you like to register a new device to use the Expo Client with?',
                type: 'confirm',
                default: true
              });

            case 85:
              udidPrompt = _context2.sent;

              addUdid = udidPrompt.addUdid;

            case 87:
              _context2.next = 89;
              return (0, (_clientBuildApi || _load_clientBuildApi()).createClientBuildRequest)({
                user: user,
                context: context,
                distributionCert: distributionCert,
                provisioningProfile: provisioningProfile,
                pushKey: pushKey,
                udids: udids,
                addUdid: addUdid,
                email: email,
                customAppConfig: exp
              });

            case 89:
              result = _context2.sent;


              (_log || _load_log()).default.newLine();
              if (addUdid) {
                (_urlOpts || _load_urlOpts()).default.printQRCode(result.registrationUrl);
                (0, (_log || _load_log()).default)('Open the following link on your iOS device (or scan the QR code) and follow the instructions to install the development profile:');
                (_log || _load_log()).default.newLine();
                (0, (_log || _load_log()).default)((_chalk || _load_chalk()).default.green('' + result.registrationUrl));
                (_log || _load_log()).default.newLine();
                (0, (_log || _load_log()).default)('Please note that you can only register one iOS device per request.');
                (0, (_log || _load_log()).default)("After you register your device, we'll start building your client, and you'll receive an email when it's ready to install.");
              } else {
                (_urlOpts || _load_urlOpts()).default.printQRCode(result.statusUrl);
                (0, (_log || _load_log()).default)('Your custom Expo Client is being built! 🛠');
                (0, (_log || _load_log()).default)('Open this link on your iOS device (or scan the QR code) to view build logs and install the client:');
                (_log || _load_log()).default.newLine();
                (0, (_log || _load_log()).default)((_chalk || _load_chalk()).default.green('' + result.statusUrl));
              }
              (_log || _load_log()).default.newLine();

            case 93:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, undefined);
    }));

    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }(), true);

  program.command('client:install:ios').description('Install the latest version of Expo Client for iOS on the simulator').asyncAction((0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee3() {
    return (_regenerator || _load_regenerator()).default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return (_xdl || _load_xdl()).Simulator.upgradeExpoAsync();

          case 2:
            if (!_context3.sent) {
              _context3.next = 4;
              break;
            }

            (0, (_log || _load_log()).default)('Done!');

          case 4:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, undefined);
  })), true);

  program.command('client:install:android').description('Install the latest version of Expo Client for Android on a connected device or emulator').asyncAction((0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee4() {
    return (_regenerator || _load_regenerator()).default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return (_xdl || _load_xdl()).Android.upgradeExpoAsync();

          case 2:
            if (!_context4.sent) {
              _context4.next = 4;
              break;
            }

            (0, (_log || _load_log()).default)('Done!');

          case 4:
          case 'end':
            return _context4.stop();
        }
      }
    }, _callee4, undefined);
  })), true);
};

module.exports = exports['default'];
//# sourceMappingURL=../../__sourcemaps__/commands/client/index.js.map
