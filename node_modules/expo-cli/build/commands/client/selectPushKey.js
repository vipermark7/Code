'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator;

function _load_regenerator() {
  return _regenerator = _interopRequireDefault(require('babel-runtime/regenerator'));
}

var _toConsumableArray2;

function _load_toConsumableArray() {
  return _toConsumableArray2 = _interopRequireDefault(require('babel-runtime/helpers/toConsumableArray'));
}

var _asyncToGenerator2;

function _load_asyncToGenerator() {
  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));
}

var validateUploadedPushKey = function () {
  var _ref3 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee2(context, pushKey) {
    var spinner, formattedPushKeyArray, filteredFormattedPushKeyArray, isValidPushKey, successMsg, failureMsg;
    return (_regenerator || _load_regenerator()).default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            spinner = (0, (_ora || _load_ora()).default)('Checking validity of push key on Apple Developer Portal...').start();
            formattedPushKeyArray = (_xdl || _load_xdl()).Credentials.Ios.formatPushKeys([pushKey], {
              provideFullPushKey: true
            });
            _context2.next = 4;
            return filterRevokedPushKeys(context, formattedPushKeyArray);

          case 4:
            filteredFormattedPushKeyArray = _context2.sent;
            isValidPushKey = filteredFormattedPushKeyArray.length > 0;

            if (isValidPushKey) {
              successMsg = 'Successfully validated the Push Key you uploaded against Apple Servers';

              spinner.succeed(successMsg);
            } else {
              failureMsg = 'The Push Key you uploaded is not valid. Please check that it was not revoked on the Apple Servers. See docs.expo.io/versions/latest/guides/adhoc-builds for more details on uploading your credentials.';

              spinner.fail(failureMsg);
            }
            return _context2.abrupt('return', isValidPushKey);

          case 8:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));

  return function validateUploadedPushKey(_x3, _x4) {
    return _ref3.apply(this, arguments);
  };
}();

var chooseUnrevokedPushKey = function () {
  var _ref4 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee3(context) {
    var pushKeysOnExpoServer, spinner, validPushKeysOnExpoServer, numValidKeys, numRevokedKeys, statusToDisplay;
    return (_regenerator || _load_regenerator()).default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return (_xdl || _load_xdl()).Credentials.Ios.getExistingPushKeys(context.username, context.team.id, {
              provideFullPushKey: true
            });

          case 2:
            pushKeysOnExpoServer = _context3.sent;

            if (!(pushKeysOnExpoServer.length === 0)) {
              _context3.next = 5;
              break;
            }

            return _context3.abrupt('return', []);

          case 5:
            spinner = (0, (_ora || _load_ora()).default)('Checking validity of push keys on Apple Developer Portal...').start();
            _context3.next = 8;
            return filterRevokedPushKeys(context, pushKeysOnExpoServer);

          case 8:
            validPushKeysOnExpoServer = _context3.sent;
            numValidKeys = validPushKeysOnExpoServer.length;
            numRevokedKeys = pushKeysOnExpoServer.length - validPushKeysOnExpoServer.length;
            statusToDisplay = 'Push Keys: You have ' + numValidKeys + ' valid and ' + numRevokedKeys + ' revoked push keys on the Expo servers.';

            if (numValidKeys > 0) {
              spinner.succeed(statusToDisplay);
            } else {
              spinner.warn(statusToDisplay);
            }

            return _context3.abrupt('return', validPushKeysOnExpoServer);

          case 14:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));

  return function chooseUnrevokedPushKey(_x5) {
    return _ref4.apply(this, arguments);
  };
}();

var filterRevokedPushKeys = function () {
  var _ref5 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee4(context, pushKeys) {
    var pushKeyManager, pushKeysOnAppleServer, validKeyIdsOnAppleServer, validPushKeysOnExpoServer;
    return (_regenerator || _load_regenerator()).default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            // if the credentials are valid, check it against apple to make sure it hasnt been revoked
            pushKeyManager = (_appleApi || _load_appleApi()).createManagers(context).pushKey;
            _context4.next = 3;
            return pushKeyManager.list();

          case 3:
            pushKeysOnAppleServer = _context4.sent;
            validKeyIdsOnAppleServer = pushKeysOnAppleServer.map(function (pushKey) {
              return pushKey.id;
            });
            validPushKeysOnExpoServer = pushKeys.filter(function (pushKey) {
              var apnsKeyId = pushKey.value && pushKey.value.apnsKeyId;
              return validKeyIdsOnAppleServer.includes(apnsKeyId);
            });
            return _context4.abrupt('return', validPushKeysOnExpoServer);

          case 7:
          case 'end':
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));

  return function filterRevokedPushKeys(_x6, _x7) {
    return _ref5.apply(this, arguments);
  };
}();

var generatePushKey = function () {
  var _ref6 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee5(context) {
    var manager, pushKey, keys, _ref7, answer;

    return (_regenerator || _load_regenerator()).default.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            manager = (_appleApi || _load_appleApi()).createManagers(context).pushKey;
            _context5.prev = 1;
            _context5.next = 4;
            return manager.create({});

          case 4:
            pushKey = _context5.sent;


            // tag for updating to Expo servers
            (0, (_tagger || _load_tagger()).tagForUpdate)(pushKey);

            return _context5.abrupt('return', pushKey);

          case 9:
            _context5.prev = 9;
            _context5.t0 = _context5['catch'](1);

            if (!(_context5.t0.code === 'APPLE_KEYS_TOO_MANY_GENERATED_ERROR')) {
              _context5.next = 43;
              break;
            }

            _context5.next = 14;
            return manager.list();

          case 14:
            keys = _context5.sent;

            (_log || _load_log()).default.warn('Maximum number (' + keys.length + ') of keys generated.');
            _context5.next = 18;
            return (0, (_prompt || _load_prompt()).default)({
              type: 'list',
              name: 'answer',
              message: 'Please revoke or reuse an existing key:',
              choices: [{
                key: 'r',
                name: 'Choose which keys to revoke',
                value: 'REVOKE'
              }, {
                key: 'e',
                name: 'Use an existing key',
                value: 'USE_EXISTING'
              }, {
                key: 's',
                name: '[Skip. This will disable push notifications.]',
                value: 'SKIP'
              }, { name: '[Show me more info about these choices] ℹ️', value: 'INFO' }]
            });

          case 18:
            _ref7 = _context5.sent;
            answer = _ref7.answer;

            if (!(answer === 'REVOKE')) {
              _context5.next = 28;
              break;
            }

            _context5.next = 23;
            return (_credentials || _load_credentials()).revoke(context, ['pushKey']);

          case 23:
            _context5.next = 25;
            return generatePushKey(context);

          case 25:
            return _context5.abrupt('return', _context5.sent);

          case 28:
            if (!(answer === 'USE_EXISTING')) {
              _context5.next = 34;
              break;
            }

            _context5.next = 31;
            return selectPushKey(context, {
              disableCreate: true,
              disableAutoSelectExisting: true
            });

          case 31:
            return _context5.abrupt('return', _context5.sent);

          case 34:
            if (!(answer === 'SKIP')) {
              _context5.next = 38;
              break;
            }

            return _context5.abrupt('return', null);

          case 38:
            if (!(answer === 'INFO')) {
              _context5.next = 43;
              break;
            }

            (0, (_open || _load_open()).default)('https://docs.expo.io/versions/latest/guides/adhoc-builds/#push-key-cli-options');
            _context5.next = 42;
            return generatePushKey(context);

          case 42:
            return _context5.abrupt('return', _context5.sent);

          case 43:
            throw new Error(_context5.t0);

          case 44:
          case 'end':
            return _context5.stop();
        }
      }
    }, _callee5, this, [[1, 9]]);
  }));

  return function generatePushKey(_x8) {
    return _ref6.apply(this, arguments);
  };
}();

var _open;

function _load_open() {
  return _open = _interopRequireDefault(require('open'));
}

var _ora;

function _load_ora() {
  return _ora = _interopRequireDefault(require('ora'));
}

var _xdl;

function _load_xdl() {
  return _xdl = require('@expo/xdl');
}

var _appleApi;

function _load_appleApi() {
  return _appleApi = _interopRequireWildcard(require('../build/ios/appleApi'));
}

var _credentials;

function _load_credentials() {
  return _credentials = _interopRequireWildcard(require('../build/ios/credentials'));
}

var _promptForCredentials;

function _load_promptForCredentials() {
  return _promptForCredentials = _interopRequireDefault(require('../build/ios/credentials/prompt/promptForCredentials'));
}

var _log;

function _load_log() {
  return _log = _interopRequireDefault(require('../../log'));
}

var _prompt;

function _load_prompt() {
  return _prompt = _interopRequireDefault(require('../../prompt'));
}

var _tagger;

function _load_tagger() {
  return _tagger = require('./tagger');
}

var _selectUtils;

function _load_selectUtils() {
  return _selectUtils = require('./selectUtils');
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee(context) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var pushKeys, choices, autoselectedPushkey, _ref2, promptValue, pushKey, isValid;

    return (_regenerator || _load_regenerator()).default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!context.username) {
              _context.next = 6;
              break;
            }

            _context.next = 3;
            return chooseUnrevokedPushKey(context);

          case 3:
            _context.t0 = _context.sent;
            _context.next = 7;
            break;

          case 6:
            _context.t0 = [];

          case 7:
            pushKeys = _context.t0;
            choices = [].concat((0, (_toConsumableArray2 || _load_toConsumableArray()).default)(pushKeys));

            // autoselect creds if we find valid ones

            if (!(pushKeys.length > 0 && !options.disableAutoSelectExisting)) {
              _context.next = 13;
              break;
            }

            autoselectedPushkey = (0, (_selectUtils || _load_selectUtils()).choosePreferredCreds)(context, pushKeys);

            (0, (_log || _load_log()).default)('Using Push Key: ' + autoselectedPushkey.name);
            return _context.abrupt('return', autoselectedPushkey.value);

          case 13:

            if (!options.disableCreate) {
              choices.push({ name: '[Create a new key] (Recommended)', value: 'GENERATE' });
            }
            choices.push({ name: '[Upload an existing key]', value: 'UPLOAD' });
            choices.push({ name: '[Skip. This will disable push notifications.]', value: 'SKIP' });
            choices.push({ name: '[Show me more info about these choices] ℹ️', value: 'INFO' });

            _context.next = 19;
            return (0, (_prompt || _load_prompt()).default)({
              type: 'list',
              name: 'promptValue',
              message: 'Select an authentication token signing key to use for push notifications:',
              pageSize: Infinity,
              choices: choices
            });

          case 19:
            _ref2 = _context.sent;
            promptValue = _ref2.promptValue;

            if (!(promptValue === 'GENERATE')) {
              _context.next = 27;
              break;
            }

            _context.next = 24;
            return generatePushKey(context);

          case 24:
            return _context.abrupt('return', _context.sent);

          case 27:
            if (!(promptValue === 'UPLOAD')) {
              _context.next = 41;
              break;
            }

            _context.next = 30;
            return (0, (_promptForCredentials || _load_promptForCredentials()).default)(context, ['pushKey']);

          case 30:
            pushKey = _context.sent[0].pushKey;
            _context.next = 33;
            return validateUploadedPushKey(context, pushKey);

          case 33:
            isValid = _context.sent;

            if (isValid) {
              _context.next = 38;
              break;
            }

            _context.next = 37;
            return selectPushKey(context, { disableAutoSelectExisting: true });

          case 37:
            return _context.abrupt('return', _context.sent);

          case 38:

            // tag for updating to Expo servers
            (0, (_tagger || _load_tagger()).tagForUpdate)(pushKey);
            _context.next = 53;
            break;

          case 41:
            if (!(promptValue === 'INFO')) {
              _context.next = 48;
              break;
            }

            (0, (_open || _load_open()).default)('https://docs.expo.io/versions/latest/guides/adhoc-builds/#push-key-cli-options');
            _context.next = 45;
            return selectPushKey(context);

          case 45:
            return _context.abrupt('return', _context.sent);

          case 48:
            if (!(promptValue === 'SKIP')) {
              _context.next = 52;
              break;
            }

            return _context.abrupt('return', null);

          case 52:
            return _context.abrupt('return', promptValue);

          case 53:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  function selectPushKey(_x) {
    return _ref.apply(this, arguments);
  }

  return selectPushKey;
}();

module.exports = exports['default'];
//# sourceMappingURL=../../__sourcemaps__/commands/client/selectPushKey.js.map
