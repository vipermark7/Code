'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator;

function _load_regenerator() {
  return _regenerator = _interopRequireDefault(require('babel-runtime/regenerator'));
}

var _toConsumableArray2;

function _load_toConsumableArray() {
  return _toConsumableArray2 = _interopRequireDefault(require('babel-runtime/helpers/toConsumableArray'));
}

var _asyncToGenerator2;

function _load_asyncToGenerator() {
  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));
}

var validateUploadedCertificate = function () {
  var _ref3 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee2(context, distributionCert) {
    var spinner, formattedDistCertArray, filteredFormattedDistCertArray, isValidCert, successMsg, failureMsg;
    return (_regenerator || _load_regenerator()).default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            spinner = (0, (_ora || _load_ora()).default)('Checking validity of distribution certificate on Apple Developer Portal...').start();
            formattedDistCertArray = (_xdl || _load_xdl()).Credentials.Ios.formatDistCerts([distributionCert], {
              provideFullCertificate: true
            });
            _context2.next = 4;
            return filterRevokedDistributionCerts(context, formattedDistCertArray);

          case 4:
            filteredFormattedDistCertArray = _context2.sent;
            isValidCert = filteredFormattedDistCertArray.length > 0;

            if (isValidCert) {
              successMsg = 'Successfully validated Distribution Certificate you uploaded against Apple Servers';

              spinner.succeed(successMsg);
            } else {
              failureMsg = 'The Distribution Certificate you uploaded is not valid. Please check that you uploaded your certificate to the Apple Servers. See docs.expo.io/versions/latest/guides/adhoc-builds for more details on uploading your credentials.';

              spinner.fail(failureMsg);
            }
            return _context2.abrupt('return', isValidCert);

          case 8:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));

  return function validateUploadedCertificate(_x3, _x4) {
    return _ref3.apply(this, arguments);
  };
}();

var chooseUnrevokedDistributionCert = function () {
  var _ref4 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee3(context) {
    var certsOnExpoServer, spinner, validCertsOnExpoServer, numValidCerts, numRevokedCerts, statusToDisplay;
    return (_regenerator || _load_regenerator()).default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return (_xdl || _load_xdl()).Credentials.Ios.getExistingDistCerts(context.username, context.team.id, { provideFullCertificate: true });

          case 2:
            certsOnExpoServer = _context3.sent;

            if (!(certsOnExpoServer.length === 0)) {
              _context3.next = 5;
              break;
            }

            return _context3.abrupt('return', []);

          case 5:
            spinner = (0, (_ora || _load_ora()).default)('Checking validity of distribution certificates on Apple Developer Portal...').start();
            _context3.next = 8;
            return filterRevokedDistributionCerts(context, certsOnExpoServer);

          case 8:
            validCertsOnExpoServer = _context3.sent;
            numValidCerts = validCertsOnExpoServer.length;
            numRevokedCerts = certsOnExpoServer.length - validCertsOnExpoServer.length;
            statusToDisplay = 'Distribution Certificate: You have ' + numValidCerts + ' valid and ' + numRevokedCerts + ' revoked certificates on the Expo servers.';

            if (numValidCerts > 0) {
              spinner.succeed(statusToDisplay);
            } else {
              spinner.warn(statusToDisplay);
            }

            return _context3.abrupt('return', validCertsOnExpoServer);

          case 14:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));

  return function chooseUnrevokedDistributionCert(_x5) {
    return _ref4.apply(this, arguments);
  };
}();

var filterRevokedDistributionCerts = function () {
  var _ref5 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee4(context, distributionCerts) {
    var distCertManager, certsOnAppleServer, validCertSerialsOnAppleServer, validCertsOnExpoServer;
    return (_regenerator || _load_regenerator()).default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            // if the credentials are valid, check it against apple to make sure it hasnt been revoked
            distCertManager = (_appleApi || _load_appleApi()).createManagers(context).distributionCert;
            _context4.next = 3;
            return distCertManager.list();

          case 3:
            certsOnAppleServer = _context4.sent;
            validCertSerialsOnAppleServer = certsOnAppleServer.filter(
            // remove expired certs
            function (cert) {
              return cert.expires > Math.floor(Date.now() / 1000);
            }).map(function (cert) {
              return cert.serialNumber;
            });
            validCertsOnExpoServer = distributionCerts.filter(function (cert) {
              var serialNumber = cert.value && cert.value.distCertSerialNumber;
              return validCertSerialsOnAppleServer.includes(serialNumber);
            });
            return _context4.abrupt('return', validCertsOnExpoServer);

          case 7:
          case 'end':
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));

  return function filterRevokedDistributionCerts(_x6, _x7) {
    return _ref5.apply(this, arguments);
  };
}();

var generateDistributionCert = function () {
  var _ref6 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee5(context) {
    var manager, distributionCert, certificates, _ref7, answer;

    return (_regenerator || _load_regenerator()).default.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            manager = (_appleApi || _load_appleApi()).createManagers(context).distributionCert;
            _context5.prev = 1;
            _context5.next = 4;
            return manager.create({});

          case 4:
            distributionCert = _context5.sent;


            // tag for updating to Expo servers
            (0, (_tagger || _load_tagger()).tagForUpdate)(distributionCert);

            return _context5.abrupt('return', distributionCert);

          case 9:
            _context5.prev = 9;
            _context5.t0 = _context5['catch'](1);

            if (!(_context5.t0.code === 'APPLE_DIST_CERTS_TOO_MANY_GENERATED_ERROR')) {
              _context5.next = 39;
              break;
            }

            _context5.next = 14;
            return manager.list();

          case 14:
            certificates = _context5.sent;

            (_log || _load_log()).default.warn('Maximum number (' + certificates.length + ') of certificates generated.');
            _context5.next = 18;
            return (0, (_prompt || _load_prompt()).default)({
              type: 'list',
              name: 'answer',
              message: 'Please revoke or reuse an existing certificate:',
              choices: [{
                key: 'r',
                name: 'Choose certificates to revoke and try again',
                value: 'REVOKE'
              }, {
                key: 'e',
                name: 'Use an existing certificate',
                value: 'USE_EXISTING'
              }, { name: '[Show me more info about these choices] ℹ️', value: 'INFO' }]
            });

          case 18:
            _ref7 = _context5.sent;
            answer = _ref7.answer;

            if (!(answer === 'REVOKE')) {
              _context5.next = 28;
              break;
            }

            _context5.next = 23;
            return (_credentials || _load_credentials()).revoke(context, ['distributionCert']);

          case 23:
            _context5.next = 25;
            return generateDistributionCert(context);

          case 25:
            return _context5.abrupt('return', _context5.sent);

          case 28:
            if (!(answer === 'USE_EXISTING')) {
              _context5.next = 34;
              break;
            }

            _context5.next = 31;
            return selectDistributionCert(context, {
              disableCreate: true,
              disableAutoSelectExisting: true
            });

          case 31:
            return _context5.abrupt('return', _context5.sent);

          case 34:
            if (!(answer === 'INFO')) {
              _context5.next = 39;
              break;
            }

            (0, (_open || _load_open()).default)('https://docs.expo.io/versions/latest/guides/adhoc-builds/#distribution-certificate-cli-options');
            _context5.next = 38;
            return generateDistributionCert(context);

          case 38:
            return _context5.abrupt('return', _context5.sent);

          case 39:
            throw new Error(_context5.t0);

          case 40:
          case 'end':
            return _context5.stop();
        }
      }
    }, _callee5, this, [[1, 9]]);
  }));

  return function generateDistributionCert(_x8) {
    return _ref6.apply(this, arguments);
  };
}();

var _open;

function _load_open() {
  return _open = _interopRequireDefault(require('open'));
}

var _ora;

function _load_ora() {
  return _ora = _interopRequireDefault(require('ora'));
}

var _xdl;

function _load_xdl() {
  return _xdl = require('@expo/xdl');
}

var _appleApi;

function _load_appleApi() {
  return _appleApi = _interopRequireWildcard(require('../build/ios/appleApi'));
}

var _credentials;

function _load_credentials() {
  return _credentials = _interopRequireWildcard(require('../build/ios/credentials'));
}

var _promptForCredentials;

function _load_promptForCredentials() {
  return _promptForCredentials = _interopRequireDefault(require('../build/ios/credentials/prompt/promptForCredentials'));
}

var _log;

function _load_log() {
  return _log = _interopRequireDefault(require('../../log'));
}

var _prompt;

function _load_prompt() {
  return _prompt = _interopRequireDefault(require('../../prompt'));
}

var _tagger;

function _load_tagger() {
  return _tagger = require('./tagger');
}

var _selectUtils;

function _load_selectUtils() {
  return _selectUtils = require('./selectUtils');
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee(context) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var certificates, choices, autoselectedCertificate, _ref2, promptValue, userProvidedCredentials, distributionCert, isValid;

    return (_regenerator || _load_regenerator()).default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!context.username) {
              _context.next = 6;
              break;
            }

            _context.next = 3;
            return chooseUnrevokedDistributionCert(context);

          case 3:
            _context.t0 = _context.sent;
            _context.next = 7;
            break;

          case 6:
            _context.t0 = [];

          case 7:
            certificates = _context.t0;
            choices = [].concat((0, (_toConsumableArray2 || _load_toConsumableArray()).default)(certificates));

            // autoselect creds if we find valid ones

            if (!(certificates.length > 0 && !options.disableAutoSelectExisting)) {
              _context.next = 13;
              break;
            }

            autoselectedCertificate = (0, (_selectUtils || _load_selectUtils()).choosePreferredCreds)(context, certificates);

            (0, (_log || _load_log()).default)('Using Distribution Certificate: ' + autoselectedCertificate.name);
            return _context.abrupt('return', autoselectedCertificate.value);

          case 13:

            if (!options.disableCreate) {
              choices.push({ name: '[Create a new certificate] (Recommended)', value: 'GENERATE' });
            }
            choices.push({ name: '[Upload an existing certificate]', value: 'UPLOAD' });
            choices.push({ name: '[Show me more info about these choices] ℹ️', value: 'INFO' });

            _context.next = 18;
            return (0, (_prompt || _load_prompt()).default)({
              type: 'list',
              name: 'promptValue',
              message: 'Select an iOS distribution certificate to use for code signing:',
              pageSize: Infinity,
              choices: choices
            });

          case 18:
            _ref2 = _context.sent;
            promptValue = _ref2.promptValue;

            if (!(promptValue === 'GENERATE')) {
              _context.next = 26;
              break;
            }

            _context.next = 23;
            return generateDistributionCert(context);

          case 23:
            return _context.abrupt('return', _context.sent);

          case 26:
            if (!(promptValue === 'UPLOAD')) {
              _context.next = 42;
              break;
            }

            _context.next = 29;
            return (0, (_promptForCredentials || _load_promptForCredentials()).default)(context, ['distributionCert']);

          case 29:
            userProvidedCredentials = _context.sent;
            distributionCert = userProvidedCredentials[0].distributionCert;

            distributionCert.distCertSerialNumber = userProvidedCredentials[1].distCertSerialNumber;
            _context.next = 34;
            return validateUploadedCertificate(context, distributionCert);

          case 34:
            isValid = _context.sent;

            if (isValid) {
              _context.next = 39;
              break;
            }

            _context.next = 38;
            return selectDistributionCert(context, { disableAutoSelectExisting: true });

          case 38:
            return _context.abrupt('return', _context.sent);

          case 39:

            // tag for updating to Expo servers
            (0, (_tagger || _load_tagger()).tagForUpdate)(distributionCert);
            _context.next = 50;
            break;

          case 42:
            if (!(promptValue === 'INFO')) {
              _context.next = 49;
              break;
            }

            (0, (_open || _load_open()).default)('https://docs.expo.io/versions/latest/guides/adhoc-builds/#distribution-certificate-cli-options');
            _context.next = 46;
            return selectDistributionCert(context);

          case 46:
            return _context.abrupt('return', _context.sent);

          case 49:
            return _context.abrupt('return', promptValue);

          case 50:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  function selectDistributionCert(_x) {
    return _ref.apply(this, arguments);
  }

  return selectDistributionCert;
}();

module.exports = exports['default'];
//# sourceMappingURL=../../__sourcemaps__/commands/client/selectDistributionCert.js.map
