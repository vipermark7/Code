"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clearTags = exports.tagForUpdate = exports.Updater = undefined;

var _regenerator;

function _load_regenerator() {
  return _regenerator = _interopRequireDefault(require("babel-runtime/regenerator"));
}

var _asyncToGenerator2;

function _load_asyncToGenerator() {
  return _asyncToGenerator2 = _interopRequireDefault(require("babel-runtime/helpers/asyncToGenerator"));
}

var _classCallCheck2;

function _load_classCallCheck() {
  return _classCallCheck2 = _interopRequireDefault(require("babel-runtime/helpers/classCallCheck"));
}

var _createClass2;

function _load_createClass() {
  return _createClass2 = _interopRequireDefault(require("babel-runtime/helpers/createClass"));
}

var _symbol;

function _load_symbol() {
  return _symbol = _interopRequireDefault(require("babel-runtime/core-js/symbol"));
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var updateSymbol = (0, (_symbol || _load_symbol()).default)(); // a unique key to mark an object on whether we should perform an update

var Updater = function () {
  function Updater(updateAllFn) {
    (0, (_classCallCheck2 || _load_classCallCheck()).default)(this, Updater);

    this.updateAllFn = updateAllFn;
  }

  (0, (_createClass2 || _load_createClass()).default)(Updater, [{
    key: "updateAllAsync",
    value: function () {
      var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee(objs) {
        var taggedObjs;
        return (_regenerator || _load_regenerator()).default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                taggedObjs = objs.filter(function (obj) {
                  return obj[updateSymbol];
                });

                clearTags(objs);
                _context.next = 4;
                return this.updateAllFn(taggedObjs);

              case 4:
                return _context.abrupt("return", _context.sent);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function updateAllAsync(_x) {
        return _ref.apply(this, arguments);
      }

      return updateAllAsync;
    }()
  }]);
  return Updater;
}();

function tagForUpdate(obj) {
  obj[updateSymbol] = true;
  return obj;
}

function clearTags(objs) {
  objs.forEach(function (obj) {
    return delete obj[updateSymbol];
  });
}

exports.Updater = Updater;
exports.tagForUpdate = tagForUpdate;
exports.clearTags = clearTags;
//# sourceMappingURL=../../__sourcemaps__/commands/client/tagger.js.map
