'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ensurePNGIsNotTransparent = undefined;

var _regenerator;

function _load_regenerator() {
  return _regenerator = _interopRequireDefault(require('babel-runtime/regenerator'));
}

var _promise;

function _load_promise() {
  return _promise = _interopRequireDefault(require('babel-runtime/core-js/promise'));
}

var _asyncToGenerator2;

function _load_asyncToGenerator() {
  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));
}

var ensurePNGIsNotTransparent = function () {
  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee(imagePathOrURL) {
    var hasAlreadyResolved, stream;
    return (_regenerator || _load_regenerator()).default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            hasAlreadyResolved = false;
            stream = (_validator || _load_validator()).default.isURL(imagePathOrURL, {
              protocols: ['http', 'https'],
              require_protocol: true
            }) ? (0, (_request || _load_request()).default)(imagePathOrURL) : (_fsExtra || _load_fsExtra()).default.createReadStream(imagePathOrURL);
            return _context.abrupt('return', new (_promise || _load_promise()).default(function (res, rej) {
              stream.pipe(new (_pngjs || _load_pngjs()).PNG({ filterType: 4 })).on('metadata', function (_ref2) {
                var alpha = _ref2.alpha;

                if (!alpha) {
                  hasAlreadyResolved = true;
                  stream.close();
                  res();
                }
              }).on('parsed', function () {
                if (hasAlreadyResolved) {
                  return;
                }
                try {
                  validateAlphaChannelIsEmpty(this.data, (0, (_pick || _load_pick()).default)(this, ['width', 'height']));
                  res();
                } catch (err) {
                  rej(err);
                }
              }).on('error', function (err) {
                return rej(err);
              });
            }));

          case 3:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function ensurePNGIsNotTransparent(_x) {
    return _ref.apply(this, arguments);
  };
}();

var _fsExtra;

function _load_fsExtra() {
  return _fsExtra = _interopRequireDefault(require('fs-extra'));
}

var _pngjs;

function _load_pngjs() {
  return _pngjs = require('pngjs');
}

var _pick;

function _load_pick() {
  return _pick = _interopRequireDefault(require('lodash/pick'));
}

var _xdl;

function _load_xdl() {
  return _xdl = require('@expo/xdl');
}

var _request;

function _load_request() {
  return _request = _interopRequireDefault(require('request'));
}

var _validator;

function _load_validator() {
  return _validator = _interopRequireDefault(require('validator'));
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validateAlphaChannelIsEmpty(data, _ref3) {
  var width = _ref3.width,
      height = _ref3.height;

  for (var y = 0; y < height; y++) {
    for (var x = 0; x < width; x++) {
      var idx = (width * y + x) * 4;
      if (data[idx + 3] !== 255) {
        throw new (_xdl || _load_xdl()).XDLError('INVALID_ASSETS', 'Your application icon can\'t have transparency if you wish to upload your app to Apple Store.');
      }
    }
  }
}

exports.ensurePNGIsNotTransparent = ensurePNGIsNotTransparent;
//# sourceMappingURL=../../../../__sourcemaps__/commands/build/ios/utils/image.js.map
