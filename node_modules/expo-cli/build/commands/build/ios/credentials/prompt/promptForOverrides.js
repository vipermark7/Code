'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toConsumableArray2;

function _load_toConsumableArray() {
  return _toConsumableArray2 = _interopRequireDefault(require('babel-runtime/helpers/toConsumableArray'));
}

var _regenerator;

function _load_regenerator() {
  return _regenerator = _interopRequireDefault(require('babel-runtime/regenerator'));
}

var _getIterator2;

function _load_getIterator() {
  return _getIterator2 = _interopRequireDefault(require('babel-runtime/core-js/get-iterator'));
}

var _extends2;

function _load_extends() {
  return _extends2 = _interopRequireDefault(require('babel-runtime/helpers/extends'));
}

var _asyncToGenerator2;

function _load_asyncToGenerator() {
  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));
}

var promptForOverrides = function () {
  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee(appleCtx, types) {
    var credentials, toAskUserFor, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, type, definition, dependsOn, name, canReuse, shouldBeExpoGenerated, choice, userProvidedCredentials, credentialsToReturn;

    return (_regenerator || _load_regenerator()).default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            credentials = {};
            toAskUserFor = [];
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            _context.prev = 5;
            _iterator = (0, (_getIterator2 || _load_getIterator()).default)(types);

          case 7:
            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
              _context.next = 33;
              break;
            }

            type = _step.value;
            definition = (_constants || _load_constants()).CREDENTIALS[type];
            dependsOn = definition.dependsOn, name = definition.name, canReuse = definition.canReuse;
            shouldBeExpoGenerated = dependsOn && !toAskUserFor.includes(dependsOn) && types.includes(dependsOn) && !((0, (_isObject || _load_isObject()).default)(credentials[dependsOn]) && 'reuse' in credentials[dependsOn]);

            if (!shouldBeExpoGenerated) {
              _context.next = 16;
              break;
            }

            // if a user was missing Distribution Certificate
            // and he let Expo handle generating it
            // we must generate new Provisioning Profile
            // (and the user cannot provide his own file)
            credentials[type] = (_constants || _load_constants()).EXPO_WILL_GENERATE;
            _context.next = 30;
            break;

          case 16:
            _context.next = 18;
            return _willUserProvideCredentialsType(name);

          case 18:
            if (!_context.sent) {
              _context.next = 22;
              break;
            }

            toAskUserFor.push(type);
            _context.next = 30;
            break;

          case 22:
            if (!canReuse) {
              _context.next = 29;
              break;
            }

            _context.next = 25;
            return _askIfWantsToReuse(appleCtx, definition);

          case 25:
            choice = _context.sent;

            if (choice) {
              credentials[type] = { reuse: choice };
            } else {
              credentials[type] = (_constants || _load_constants()).EXPO_WILL_GENERATE;
            }
            _context.next = 30;
            break;

          case 29:
            credentials[type] = (_constants || _load_constants()).EXPO_WILL_GENERATE;

          case 30:
            _iteratorNormalCompletion = true;
            _context.next = 7;
            break;

          case 33:
            _context.next = 39;
            break;

          case 35:
            _context.prev = 35;
            _context.t0 = _context['catch'](5);
            _didIteratorError = true;
            _iteratorError = _context.t0;

          case 39:
            _context.prev = 39;
            _context.prev = 40;

            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }

          case 42:
            _context.prev = 42;

            if (!_didIteratorError) {
              _context.next = 45;
              break;
            }

            throw _iteratorError;

          case 45:
            return _context.finish(42);

          case 46:
            return _context.finish(39);

          case 47:
            _context.next = 49;
            return (0, (_promptForCredentials || _load_promptForCredentials()).default)(appleCtx, toAskUserFor, false);

          case 49:
            userProvidedCredentials = _context.sent;
            credentialsToReturn = (0, (_extends2 || _load_extends()).default)({}, credentials, userProvidedCredentials);
            return _context.abrupt('return', [credentialsToReturn, null]);

          case 52:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this, [[5, 35, 39, 47], [40,, 42, 46]]);
  }));

  return function promptForOverrides(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

var _willUserProvideCredentialsType = function () {
  var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee2(name) {
    var _ref3, answer;

    return (_regenerator || _load_regenerator()).default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return (0, (_prompt || _load_prompt()).default)({
              type: 'list',
              name: 'answer',
              message: 'Will you provide your own ' + name + '?',
              choices: [{ name: 'Let Expo handle the process', value: false }, { name: 'I want to upload my own file', value: true }]
            });

          case 2:
            _ref3 = _context2.sent;
            answer = _ref3.answer;
            return _context2.abrupt('return', answer);

          case 5:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));

  return function _willUserProvideCredentialsType(_x3) {
    return _ref2.apply(this, arguments);
  };
}();

var _askIfWantsToReuse = function () {
  var _ref4 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee3(appleCtx, definition) {
    var name, existingCreds, newCertChoice, choices, _ref5, userChoice;

    return (_regenerator || _load_regenerator()).default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            name = definition.name;
            _context3.next = 3;
            return _getExistingCreds(appleCtx, definition);

          case 3:
            existingCreds = _context3.sent;

            if (existingCreds) {
              _context3.next = 6;
              break;
            }

            return _context3.abrupt('return', null);

          case 6:
            newCertChoice = {
              name: 'No, please create a new one',
              value: null
            };
            choices = [newCertChoice].concat((0, (_toConsumableArray2 || _load_toConsumableArray()).default)(existingCreds));
            _context3.next = 10;
            return (0, (_prompt || _load_prompt()).default)({
              type: 'list',
              name: 'userChoice',
              message: 'Would you like to reuse ' + name + ' from another app?',
              choices: choices
            });

          case 10:
            _ref5 = _context3.sent;
            userChoice = _ref5.userChoice;
            return _context3.abrupt('return', userChoice);

          case 13:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));

  return function _askIfWantsToReuse(_x4, _x5) {
    return _ref4.apply(this, arguments);
  };
}();

var _getExistingCreds = function () {
  var _ref6 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee4(_ref7, _ref8) {
    var username = _ref7.username,
        appleTeamId = _ref7.team.id;
    var id = _ref8.id,
        name = _ref8.name;
    var getter, spinner, existingCreds;
    return (_regenerator || _load_regenerator()).default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            getter = existingCredsGettersByType[id];
            spinner = (0, (_ora || _load_ora()).default)('Looking for ' + name + ' you might have created before...').start();
            _context4.prev = 2;
            _context4.next = 5;
            return getter(username, appleTeamId);

          case 5:
            existingCreds = _context4.sent;

            if (!(existingCreds.length === 0)) {
              _context4.next = 11;
              break;
            }

            spinner.succeed('Didn\'t find any previously uploaded ' + name);
            return _context4.abrupt('return', null);

          case 11:
            spinner.stop();
            return _context4.abrupt('return', existingCreds);

          case 13:
            _context4.next = 19;
            break;

          case 15:
            _context4.prev = 15;
            _context4.t0 = _context4['catch'](2);

            spinner.fail('Failed when trying to find previously uploaded ' + name);
            throw _context4.t0;

          case 19:
          case 'end':
            return _context4.stop();
        }
      }
    }, _callee4, this, [[2, 15]]);
  }));

  return function _getExistingCreds(_x6, _x7) {
    return _ref6.apply(this, arguments);
  };
}();

var _xdl;

function _load_xdl() {
  return _xdl = require('@expo/xdl');
}

var _ora;

function _load_ora() {
  return _ora = _interopRequireDefault(require('ora'));
}

var _isObject;

function _load_isObject() {
  return _isObject = _interopRequireDefault(require('lodash/isObject'));
}

var _constants;

function _load_constants() {
  return _constants = _interopRequireWildcard(require('../constants'));
}

var _promptForCredentials;

function _load_promptForCredentials() {
  return _promptForCredentials = _interopRequireDefault(require('./promptForCredentials'));
}

var _prompt;

function _load_prompt() {
  return _prompt = _interopRequireDefault(require('../../../../../prompt'));
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var existingCredsGettersByType = {
  distributionCert: (_xdl || _load_xdl()).Credentials.Ios.getExistingDistCerts,
  pushKey: (_xdl || _load_xdl()).Credentials.Ios.getExistingPushKeys
};

exports.default = promptForOverrides;
module.exports = exports['default'];
//# sourceMappingURL=../../../../../__sourcemaps__/commands/build/ios/credentials/prompt/promptForOverrides.js.map
