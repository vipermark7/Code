"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getServer = getServer;
exports.startAsync = startAsync;
exports.getUrlAsync = getUrlAsync;
exports.getProtocolAsync = getProtocolAsync;
exports.stopAsync = stopAsync;
exports.bundleAsync = bundleAsync;
exports.openAsync = openAsync;

var ConfigUtils = _interopRequireWildcard(require("@expo/config"));

var _WebpackDevServerUtils = require("react-dev-utils/WebpackDevServerUtils");

var _webpack = _interopRequireDefault(require("webpack"));

var _webpackDevServer = _interopRequireDefault(require("webpack-dev-server"));

var _chalk = _interopRequireDefault(require("chalk"));

var _createWebpackCompiler = _interopRequireDefault(require("./createWebpackCompiler"));

var ProjectUtils = _interopRequireWildcard(require("./project/ProjectUtils"));

var ProjectSettings = _interopRequireWildcard(require("./ProjectSettings"));

var Web = _interopRequireWildcard(require("./Web"));

var Doctor = _interopRequireWildcard(require("./project/Doctor"));

var _XDLError = _interopRequireDefault(require("./XDLError"));

var _ip = _interopRequireDefault(require("./ip"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

//eslint-disable-line
const HOST = '0.0.0.0';
const DEFAULT_PORT = 19006;
const WEBPACK_LOG_TAG = 'expo';
let webpackDevServerInstance = null;
let webpackServerPort = null;

function getServer(projectRoot) {
  if (webpackDevServerInstance == null) {
    ProjectUtils.logError(projectRoot, WEBPACK_LOG_TAG, 'Webpack is not running.');
  }

  return webpackDevServerInstance;
}

async function choosePortAsync() {
  try {
    return await (0, _WebpackDevServerUtils.choosePort)(HOST, DEFAULT_PORT);
  } catch (error) {
    throw new _XDLError.default('NO_PORT_FOUND', 'No available port found: ' + error.message);
  }
}

async function startAsync(projectRoot, {
  nonInteractive
}, verbose) {
  await Doctor.validateWebSupportAsync(projectRoot);

  if (webpackDevServerInstance) {
    ProjectUtils.logError(projectRoot, WEBPACK_LOG_TAG, 'Webpack is already running.');
    return;
  }

  const useYarn = ConfigUtils.isUsingYarn(projectRoot);
  const {
    exp
  } = await ProjectUtils.readConfigJsonAsync(projectRoot);
  const {
    webName
  } = ConfigUtils.getNameFromConfig(exp);
  let {
    dev,
    https
  } = await ProjectSettings.readAsync(projectRoot);
  const mode = dev ? 'development' : 'production';
  const config = await Web.invokeWebpackConfigAsync({
    projectRoot,
    pwa: true,
    development: dev,
    production: !dev,
    https,
    info: Web.isInfoEnabled()
  });
  webpackServerPort = await choosePortAsync();
  ProjectUtils.logInfo(projectRoot, WEBPACK_LOG_TAG, `Starting Webpack on port ${webpackServerPort} in ${_chalk.default.underline(mode)} mode.`);
  const protocol = https ? 'https' : 'http';
  const urls = (0, _WebpackDevServerUtils.prepareUrls)(protocol, '::', webpackServerPort);
  await new Promise(resolve => {
    // Create a webpack compiler that is configured with custom messages.
    const compiler = (0, _createWebpackCompiler.default)({
      projectRoot,
      nonInteractive,
      webpack: _webpack.default,
      appName: webName,
      config,
      urls,
      useYarn,
      onFinished: resolve
    });
    webpackDevServerInstance = new _webpackDevServer.default(compiler, config.devServer); // Launch WebpackDevServer.

    webpackDevServerInstance.listen(webpackServerPort, HOST, error => {
      if (error) {
        ProjectUtils.logError(projectRoot, WEBPACK_LOG_TAG, error);
      } // clearConsole();

    });
  });
  await ProjectSettings.setPackagerInfoAsync(projectRoot, {
    webpackServerPort
  });
  return {
    server: webpackDevServerInstance,
    url: await getUrlAsync(projectRoot)
  };
}

async function getUrlAsync(projectRoot) {
  const devServer = getServer(projectRoot);

  if (!devServer) {
    return null;
  }

  const host = _ip.default.address();

  const urlType = await getProtocolAsync(projectRoot);
  return `${urlType}://${host}:${webpackServerPort}`;
}

async function getProtocolAsync(projectRoot) {
  // TODO: Bacon: Handle when not in expo
  const {
    https
  } = await ProjectSettings.readAsync(projectRoot);

  if (https === true) {
    return 'https';
  }

  return 'http';
}

async function stopAsync(projectRoot) {
  if (webpackDevServerInstance) {
    await new Promise(resolve => webpackDevServerInstance.close(() => resolve()));
    webpackDevServerInstance = null;
    webpackServerPort = null; // TODO

    await ProjectSettings.setPackagerInfoAsync(projectRoot, {
      webpackServerPort: null
    });
  }
}

async function bundleAsync(projectRoot, packagerOpts) {
  await Doctor.validateWebSupportAsync(projectRoot);
  const mode = packagerOpts.dev ? 'development' : 'production';
  process.env.BABEL_ENV = mode;
  process.env.NODE_ENV = mode;
  let config = await Web.invokeWebpackConfigAsync({
    projectRoot,
    pwa: packagerOpts.pwa,
    polyfill: packagerOpts.polyfill,
    development: packagerOpts.dev,
    production: !packagerOpts.dev,
    info: Web.isInfoEnabled()
  });
  let compiler = (0, _webpack.default)(config);

  try {
    // We generate the stats.json file in the webpack-config
    await new Promise((resolve, reject) => compiler.run(async (error, stats) => {
      // TODO: Bacon: account for CI
      if (error) {
        // TODO: Bacon: Clean up error messages
        return reject(error);
      }

      resolve(stats);
    }));
  } catch (error) {
    ProjectUtils.logError(projectRoot, 'expo', 'There was a problem building your web project. ' + error.message);
    throw error;
  }
}

async function openAsync(projectRoot, options = {}, verbose = true) {
  if (!webpackDevServerInstance) {
    await startAsync(projectRoot, options, verbose);
  }

  await Web.openProjectAsync(projectRoot);
}
//# sourceMappingURL=__sourcemaps__/Webpack.js.map
