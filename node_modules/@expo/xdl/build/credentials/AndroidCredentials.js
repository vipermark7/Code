"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.backupExistingCredentials = backupExistingCredentials;
exports.exportCertBinary = exportCertBinary;
exports.exportCertBase64 = exportCertBase64;
exports.exportPrivateKey = exportPrivateKey;
exports.logKeystoreHashes = logKeystoreHashes;
exports.logKeystoreCredentials = logKeystoreCredentials;
exports.createKeystore = createKeystore;
exports.generateUploadKeystore = generateUploadKeystore;

var _path = _interopRequireDefault(require("path"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _chalk = _interopRequireDefault(require("chalk"));

var _crypto = _interopRequireDefault(require("crypto"));

var _v = _interopRequireDefault(require("uuid/v4"));

var _spawnAsync = _interopRequireDefault(require("@expo/spawn-async"));

var _axios = _interopRequireDefault(require("axios"));

var _progress = _interopRequireDefault(require("progress"));

var _Credentials = require("./Credentials");

var _Logger = _interopRequireDefault(require("../Logger"));

var _UserSettings = _interopRequireDefault(require("../UserSettings"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const NEWLINE = process.platform === 'win32' ? '\r\n' : '\n';
const javaExecutable = process.platform === 'win32' ? 'java.exe' : 'java';

async function backupExistingCredentials({
  outputPath,
  username,
  experienceName
}, log = _Logger.default.info.bind(_Logger.default), logSecrets = true) {
  const credentialMetadata = {
    username,
    experienceName,
    platform: 'android'
  };
  log(`Retreiving Android keystore for ${experienceName}`);
  const credentials = await (0, _Credentials.getCredentialsForPlatform)(credentialMetadata);

  if (!credentials) {
    throw new Error('Unable to fetch credentials for this project. Are you sure they exist?');
  }

  const {
    keystore,
    keystorePassword,
    keystoreAlias: keyAlias,
    keyPassword
  } = credentials;
  const storeBuf = Buffer.from(keystore, 'base64');
  log(`Writing keystore to ${outputPath}...`);

  _fsExtra.default.writeFileSync(outputPath, storeBuf);

  if (logSecrets) {
    log('Done writing keystore to disk.');
    log(`${_chalk.default.yellow('Save these important values as well:')}

  Keystore password: ${_chalk.default.bold(keystorePassword)}
  Key alias:         ${_chalk.default.bold(keyAlias)}
  Key password:      ${_chalk.default.bold(keyPassword)}
  `);
  }

  return {
    keystorePassword,
    keyAlias,
    keyPassword
  };
}

async function exportCertBinary(keystorePath, keystorePassword, keyAlias, certFile) {
  return (0, _spawnAsync.default)('keytool', ['-exportcert', '-keystore', keystorePath, '-storepass', keystorePassword, '-alias', keyAlias, '-file', certFile, '-noprompt', '-storetype', 'JKS']);
}

async function exportCertBase64(keystorePath, keystorePassword, keyAlias, certFile) {
  return (0, _spawnAsync.default)('keytool', ['-export', '-rfc', '-keystore', keystorePath, '-storepass', keystorePassword, '-alias', keyAlias, '-file', certFile, '-noprompt', '-storetype', 'JKS']);
}

async function exportPrivateKey({
  keystorePath,
  keystorePassword,
  keyAlias,
  keyPassword
}, encryptionKey, outputPath, log = _Logger.default.info.bind(_Logger.default)) {
  let nodePty;
  const ptyTmpDir = '/tmp/pty-tmp-install';

  try {
    // it's not very pretty solution, but we decided to use it because it's affecting only people using
    // this command and if node-pty is supported on that system instalation process will be invisble for user.
    nodePty = require('node-pty-prebuilt');
  } catch (err) {
    try {
      log('Installing node-pty-prebuilt in temporary directory');
      await _fsExtra.default.mkdirp(ptyTmpDir);
      await (0, _spawnAsync.default)('npm', ['init', '--yes'], {
        cwd: ptyTmpDir
      });
      await (0, _spawnAsync.default)('npm', ['install', 'node-pty-prebuilt'], {
        cwd: ptyTmpDir,
        stdio: ['pipe', 1, 2]
      });
      nodePty = require(`${ptyTmpDir}/node_modules/node-pty-prebuilt`);
    } catch (err) {
      log(`Run ${_chalk.default.cyan('npm -g install node-pty-prebuilt')} to install node pty`);
      throw new Error('Package node-pty-prebuilt is required to use PEPK tool');
    }
  }

  const ptySpawn = nodePty.spawn;

  const encryptToolPath = _path.default.join(_UserSettings.default.dotExpoHomeDirectory(), 'android_tools_pepk.jar');

  if (!_fsExtra.default.existsSync(encryptToolPath)) {
    log(`Downloading PEPK tool from Google Play to ${encryptToolPath}`);
    const downloadUrl = 'https://www.gstatic.com/play-apps-publisher-rapid/signing-tool/prod/pepk.jar';

    const file = _fsExtra.default.createWriteStream(encryptToolPath);

    const response = await (0, _axios.default)({
      url: downloadUrl,
      method: 'GET',
      responseType: 'stream'
    });
    const bar = new _progress.default('  downloading pepk tool [:bar] :rate/bps :percent :etas', {
      complete: '=',
      incomplete: ' ',
      width: 40,
      total: parseInt(response.headers['content-length'], 10)
    });
    response.data.pipe(file);
    response.data.on('data', chunk => bar.tick(chunk.length));
    await new Promise((resolve, reject) => {
      file.on('finish', resolve);
      file.on('error', reject);
    });
  }

  try {
    await new Promise((res, rej) => {
      const child = ptySpawn(javaExecutable, ['-jar', encryptToolPath, '--keystore', keystorePath, '--alias', keyAlias, '--output', outputPath, '--encryptionkey', encryptionKey], {
        name: 'pepk tool',
        cols: 80,
        rows: 30,
        cwd: process.cwd(),
        env: process.env
      });
      child.on('error', err => {
        log('error', err);
        rej(err);
      });
      child.on('exit', exitCode => {
        if (exitCode !== 0) {
          rej(exitCode);
        } else {
          res();
        }
      });
      child.write(keystorePassword + NEWLINE);
      child.write(keyPassword + NEWLINE);
    });
    log(`Exported and encrypted private app signing key to file ${outputPath}`);
  } catch (error) {
    throw new Error(`PEPK tool failed with return code ${error}`);
  } finally {
    _fsExtra.default.remove(ptyTmpDir);
  }
}

async function logKeystoreHashes({
  keystorePath,
  keystorePassword,
  keyAlias
}, log = _Logger.default.info.bind(_Logger.default)) {
  const certFile = `${keystorePath}.cer`;

  try {
    await exportCertBinary(keystorePath, keystorePassword, keyAlias, certFile);

    const data = _fsExtra.default.readFileSync(certFile);

    const googleHash = _crypto.default.createHash('sha1').update(data).digest('hex').toUpperCase();

    const googleHash256 = _crypto.default.createHash('sha256').update(data).digest('hex').toUpperCase();

    const fbHash = _crypto.default.createHash('sha1').update(data).digest('base64');

    log(`Google Certificate Fingerprint:     ${googleHash.replace(/(.{2}(?!$))/g, '$1:')}`);
    log(`Google Certificate Hash (SHA-1):    ${googleHash}`);
    log(`Google Certificate Hash (SHA-256):  ${googleHash256}`);
    log(`Facebook Key Hash:                  ${fbHash}`);
  } catch (err) {
    if (err.code === 'ENOENT') {
      log.warn('Are you sure you have keytool installed?');
      log('keytool is part of OpenJDK: https://openjdk.java.net/');
      log('Also make sure that keytool is in your PATH after installation.');
    }

    if (err.stdout) {
      log(err.stdout);
    }

    if (err.stderr) {
      log.error(err.stderr);
    }

    throw err;
  } finally {
    try {
      _fsExtra.default.unlinkSync(certFile);
    } catch (err) {
      if (err.code !== 'ENOENT') {
        log.error(err);
      }
    }
  }
}

function logKeystoreCredentials({
  keystorePassword,
  keyAlias,
  keyPassword
}, title = 'Keystore credentials', log = _Logger.default.info.bind(_Logger.default)) {
  log(`${title}
    Keystore password: ${_chalk.default.bold(keystorePassword)}
    Key alias:         ${_chalk.default.bold(keyAlias)}
    Key password:      ${_chalk.default.bold(keyPassword)}
  `);
}

async function createKeystore({
  keystorePath,
  keystorePassword,
  keyAlias,
  keyPassword
}, androidPackage) {
  return (0, _spawnAsync.default)('keytool', ['-genkey', '-v', '-storepass', keystorePassword, '-keypass', keyPassword, '-keystore', keystorePath, '-alias', keyAlias, '-keyalg', 'RSA', '-keysize', '2048', '-validity', '10000', '-dname', `CN=${androidPackage},OU=,O=,L=,S=,C=US`]);
}

async function generateUploadKeystore(uploadKeystorePath, androidPackage, experienceName) {
  const keystoreData = {
    keystorePassword: (0, _v.default)().replace(/-/g, ''),
    keyPassword: (0, _v.default)().replace(/-/g, ''),
    keyAlias: Buffer.from(experienceName).toString('base64')
  };
  await createKeystore({
    keystorePath: uploadKeystorePath,
    ...keystoreData
  }, androidPackage);
  return keystoreData;
}
//# sourceMappingURL=../__sourcemaps__/credentials/AndroidCredentials.js.map
