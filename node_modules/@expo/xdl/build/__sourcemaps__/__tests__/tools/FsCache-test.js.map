{"version":3,"sources":["__tests__/tools/FsCache-test.js"],"names":["jest","mock","fs","require","path","describe","it","async","dateCacher","Cacher","Date","await","clearAsync","e","date1","getAsync","expect","toEqual","setTimeout","then","d","not","expected","JSON","parse","readFile","join","__dirname","failCacher","Error","found"],"mappings":";;AACA;;AAEAA,IAAI,CAACC,IAALD,CAAU,gBAAVA;;AAEA,MAAME,EAAAA,GAAKC,OAAO,CAAC,UAAD,CAAlB;;AACA,MAAMC,IAAAA,GAAOD,OAAO,CAAC,MAAD,CAApB;;AAEAE,QAAQ,CAAC,QAAD,EAAW,MAAM;AACvBC,EAAAA,EAAE,CAAC,gCAAD,EAAmCC,YAAY;AAC/C,UAAMC,UAAuB,GAAI,IAAIC,eAAJ,CAC/BF,YAAY;AACV,aAAO,IAAIG,IAAJ,EAAP;AACD,KAH8B,EAI/B,UAJ+B,EAK/B,IAL+B,CAAjC;;AAQA,QAAI;AACFC,YAAMH,UAAU,CAACI,UAAXJ,EAANG;AACF,KAFA,CAEE,OAAOE,CAAP,EAAU,CACV;AACF;;AAEA,UAAMC,KAAAA,GAAQ,IAAIJ,IAAJ,EAASC,MAAMH,UAAU,CAACO,QAAXP,EAAf,EAAd,CAf+C,CAiB/C;;AACAQ,IAAAA,MAAM,CAACF,KAAD,CAANE,CAAcC,OAAdD,CAAsB,IAAIN,IAAJ,EAASC,MAAMH,UAAU,CAACO,QAAXP,EAAf,EAAtBQ,EAlB+C,CAoB/C;;AACAE,IAAAA,UAAU,CAAC,MAAM;AACfV,MAAAA,UAAU,CAACO,QAAXP,GAAsBW,IAAtBX,CAA2BY,CAAAA,IAAK;AAC9BJ,QAAAA,MAAM,CAACF,KAAD,CAANE,CAAcK,GAAdL,CAAkBC,OAAlBD,CAA0B,IAAIN,IAAJ,CAASU,CAAT,CAA1BJ;AACD,OAFDR;AAGD,KAJS,EAIP,IAJO,CAAVU;AAKD,GA1BC,CAAFZ;AA4BAA,EAAAA,EAAE,CAAC,6BAAD,EAAgCC,YAAY;AAC5C,UAAMe,QAAAA,GAAWC,IAAI,CAACC,KAALD,EAAWZ,MAAMT,EAAE,CAACuB,QAAHvB,CAAYE,IAAI,CAACsB,IAALtB,CAAUuB,SAAVvB,EAAqB,uBAArBA,CAAZF,CAAjBqB,EAAjB;AAEA,UAAMK,UAAAA,GAAa,IAAInB,eAAJ,CACjB,MAAM;AACJ,YAAM,IAAIoB,KAAJ,CAAU,yBAAV,CAAN;AACD,KAHgB,EAIjB,WAJiB,EAKjB,IALiB,EAMjBzB,IAAI,CAACsB,IAALtB,CAAUuB,SAAVvB,EAAqB,uBAArBA,CANiB,CAAnB,CAH4C,CAY5C;;AACA,QAAI;AACFO,YAAMiB,UAAU,CAAChB,UAAXgB,EAANjB;AACF,KAFA,CAEE,OAAOE,CAAP,EAAU,CACV;AACF;;AAEA,UAAMiB,KAAAA,GAAQnB,MAAMiB,UAAU,CAACb,QAAXa,EAApB;AAEAZ,IAAAA,MAAM,CAACc,KAAD,CAANd,CAAcC,OAAdD,CAAsBM,QAAtBN;AACD,GAtBC,CAAFV;AAuBD,CApDO,CAARD","file":"../../../__tests__/tools/FsCache-test.js","sourcesContent":["/* @flow */\nimport { Cacher } from '../../tools/FsCache';\n\njest.mock('analytics-node');\n\nconst fs = require('fs-extra');\nconst path = require('path');\n\ndescribe('Cacher', () => {\n  it('works without a bootstrap file', async () => {\n    const dateCacher: Cacher<Date> = new Cacher(\n      async () => {\n        return new Date();\n      },\n      'dateslol',\n      1000\n    );\n\n    try {\n      await dateCacher.clearAsync();\n    } catch (e) {\n      // this is ok\n    }\n\n    const date1 = new Date(await dateCacher.getAsync());\n\n    // should be well within the TTL, should be identical value\n    expect(date1).toEqual(new Date(await dateCacher.getAsync()));\n\n    // should be outside of the TTL -- just making sure that sufficient delay will change the value\n    setTimeout(() => {\n      dateCacher.getAsync().then(d => {\n        expect(date1).not.toEqual(new Date(d));\n      });\n    }, 3000);\n  });\n\n  it('works with a bootstrap file', async () => {\n    const expected = JSON.parse(await fs.readFile(path.join(__dirname, '../../../package.json')));\n\n    const failCacher = new Cacher(\n      () => {\n        throw new Error('lol this never succeeds');\n      },\n      'bootstrap',\n      1000,\n      path.join(__dirname, '../../../package.json')\n    );\n\n    // since we don't mock the fs here (.cache is transient), need to make sure it's empty\n    try {\n      await failCacher.clearAsync();\n    } catch (e) {\n      // noop\n    }\n\n    const found = await failCacher.getAsync();\n\n    expect(found).toEqual(expected);\n  });\n});\n"],"sourceRoot":"/@expo/xdl@55.0.14/src"}