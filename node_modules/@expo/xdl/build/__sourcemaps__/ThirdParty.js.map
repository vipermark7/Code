{"version":3,"sources":["ThirdParty.js"],"names":["async","getManifest","publicUrl","opts","req","url","method","headers","Accept","let","exp","resp","await","axios","request","data","e","XDLError","toString","_extractManifest","platform","expOrArray","Array","isArray","sdkVersions","Versions","versionsAsync","i","length","manifestCandidate","sdkVersion","versionObj","isDeprecated","supportedVersions","Object","keys","JSON","stringify"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;;;;;AAEOA,eAAeC,WAAfD,CAA2BE,SAA3BF,EAAsCG,IAAAA,GAAO,EAA7CH,EAAiD;AACtD,QAAMI,GAAAA,GAAM;AACVC,IAAAA,GAAG,EAAEH,SADK;AAEVI,IAAAA,MAAM,EAAE,KAFE;AAGVC,IAAAA,OAAO,EAAE;AAAEC,MAAAA,MAAM,EAAE;AAAV;AAHC,GAAZ;AAMAC,MAAIC,GAAJD;;AACA,MAAI;AACF,UAAME,IAAAA,GAAOC,MAAMC,eAAMC,OAAND,CAAcT,GAAdS,CAAnB;AACAH,IAAAA,GAAAA,GAAMC,IAAI,CAACI,IAAXL;AACF,GAHA,CAGE,OAAOM,CAAP,EAAU;AACV,UAAM,IAAIC,iBAAJ,CACJ,kBADI,EAEH,iCAAgCf,SAAU,IAA3C,GAAiDc,CAAC,CAACE,QAAFF,EAF7C,CAAN;AAIF;;AACAN,EAAAA,GAAAA,GAAME,MAAMO,gBAAgB,CAACT,GAAD,EAAMR,SAAN,CAA5BQ;;AACA,MAAIP,IAAI,CAACiB,QAALjB,IAAiBO,GAAG,CAACU,QAAJV,KAAiBP,IAAI,CAACiB,QAAvCjB,IAAmDA,IAAI,CAACiB,QAALjB,KAAkB,KAAzE,EAAgF;AAC9E,UAAM,IAAIc,iBAAJ,CACJ,kBADI,EAEH,iBAAgBf,SAAU,+BAA8BC,IAAI,CAACiB,QAAS,WAFnE,CAAN;AAIF;;AACA,SAAOV,GAAP;AACF,C,CAEA;AACA;;;AACAV,eAAemB,gBAAfnB,CAAgCqB,UAAhCrB,EAA4CE,SAA5CF,EAAuD;AACrD;AACA,MAAI,CAACsB,KAAK,CAACC,OAAND,CAAcD,UAAdC,CAAL,EAAgC;AAC9B,WAAOD,UAAP;AACF;;AAEA,QAAM;AAAEG,IAAAA;AAAF,MAAkBZ,MAAMa,QAAQ,CAACC,aAATD,EAA9B;;AACA,OAAKhB,IAAIkB,CAAAA,GAAI,CAAb,EAAgBA,CAAAA,GAAIN,UAAU,CAACO,MAA/B,EAAuCD,CAAC,EAAxC,EAA4C;AAC1C,UAAME,iBAAAA,GAAoBR,UAAU,CAACM,CAAD,CAApC;AACA,UAAMG,UAAAA,GAAaD,iBAAiB,CAACC,UAArC;;AACA,QAAI,CAACA,UAAL,EAAiB;AACf;AACF;;AACA,UAAMC,UAAAA,GAAaP,WAAW,CAACM,UAAD,CAA9B;;AACA,QAAI,CAACC,UAAL,EAAiB;AACf;AACF;;AAEA,UAAMC,YAAAA,GAAeD,UAAU,CAACC,YAAXD,IAA2B,KAAhD;;AACA,QAAI,CAACC,YAAL,EAAmB;AACjB,aAAOH,iBAAP;AACF;AACF;;AACA,QAAMI,iBAAAA,GAAoBC,MAAM,CAACC,IAAPD,CAAYV,WAAZU,CAA1B;AACA,QAAM,IAAIjB,iBAAJ,CACJ,kBADI,EAEH,mCAAkCf,SAAU,mDAAkDkC,IAAI,CAACC,SAALD,CAC7FH,iBAD6FG,CAE7F,EAJE,CAAN;AAMF","file":"../ThirdParty.js","sourcesContent":["import axios from 'axios';\nimport * as Versions from './Versions';\nimport XDLError from './XDLError';\n\nexport async function getManifest(publicUrl, opts = {}) {\n  const req = {\n    url: publicUrl,\n    method: 'get',\n    headers: { Accept: 'application/expo+json,application/json' },\n  };\n\n  let exp;\n  try {\n    const resp = await axios.request(req);\n    exp = resp.data;\n  } catch (e) {\n    throw new XDLError(\n      'INVALID_MANIFEST',\n      `Unable to fetch manifest from ${publicUrl}. ` + e.toString()\n    );\n  }\n  exp = await _extractManifest(exp, publicUrl);\n  if (opts.platform && exp.platform !== opts.platform && opts.platform !== 'all') {\n    throw new XDLError(\n      'INVALID_MANIFEST',\n      `Manifest from ${publicUrl} is not compatible with the ${opts.platform} platform`\n    );\n  }\n  return exp;\n}\n\n// Third party publicUrls can return an array of manifests\n// We need to choose the first compatible one\nasync function _extractManifest(expOrArray, publicUrl) {\n  // if its not an array, assume it was a single manifest obj\n  if (!Array.isArray(expOrArray)) {\n    return expOrArray;\n  }\n\n  const { sdkVersions } = await Versions.versionsAsync();\n  for (let i = 0; i < expOrArray.length; i++) {\n    const manifestCandidate = expOrArray[i];\n    const sdkVersion = manifestCandidate.sdkVersion;\n    if (!sdkVersion) {\n      continue;\n    }\n    const versionObj = sdkVersions[sdkVersion];\n    if (!versionObj) {\n      continue;\n    }\n\n    const isDeprecated = versionObj.isDeprecated || false;\n    if (!isDeprecated) {\n      return manifestCandidate;\n    }\n  }\n  const supportedVersions = Object.keys(sdkVersions);\n  throw new XDLError(\n    'INVALID_MANIFEST',\n    `No compatible manifest found at ${publicUrl}. Please use one of the SDK versions supported: ${JSON.stringify(\n      supportedVersions\n    )}`\n  );\n}\n"],"sourceRoot":"/@expo/xdl@55.0.14/src"}