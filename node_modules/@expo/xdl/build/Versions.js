"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.versionsAsync = versionsAsync;
exports.sdkVersionsAsync = sdkVersionsAsync;
exports.setVersionsAsync = setVersionsAsync;
exports.gteSdkVersion = gteSdkVersion;
exports.lteSdkVersion = lteSdkVersion;
exports.parseSdkVersionFromTag = parseSdkVersionFromTag;
exports.newestSdkVersionAsync = newestSdkVersionAsync;
exports.oldestSupportedMajorVersionAsync = oldestSupportedMajorVersionAsync;
exports.facebookReactNativeVersionsAsync = facebookReactNativeVersionsAsync;
exports.facebookReactNativeVersionToExpoVersionAsync = facebookReactNativeVersionToExpoVersionAsync;
exports.canTurtleBuildSdkVersion = canTurtleBuildSdkVersion;

var _path = _interopRequireDefault(require("path"));

var _forEach = _interopRequireDefault(require("lodash/forEach"));

var _pickBy = _interopRequireDefault(require("lodash/pickBy"));

var _get = _interopRequireDefault(require("lodash/get"));

var _semver = _interopRequireDefault(require("semver"));

var _ApiV = _interopRequireDefault(require("./ApiV2"));

var _FsCache = require("./tools/FsCache");

var _XDLError = _interopRequireDefault(require("./XDLError"));

var _User = _interopRequireDefault(require("./User"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function versionsAsync() {
  const api = new _ApiV.default();
  const versionCache = new _FsCache.Cacher(() => api.getAsync('versions/latest'), 'versions.json', 0, _path.default.join(__dirname, '../caches/versions.json'));
  return await versionCache.getAsync();
}

async function sdkVersionsAsync() {
  const {
    sdkVersions
  } = await versionsAsync();
  return sdkVersions;
}

async function setVersionsAsync(value) {
  const user = await _User.default.getCurrentUserAsync();

  const api = _ApiV.default.clientForUser(user);

  const secret = process.env.EXPO_VERSIONS_SECRET;
  if (!secret) throw new Error('Versions.setVersionsAsync: EXPO_VERSIONS_SECRET environment variable is required');
  await api.postAsync('versions/update', {
    value: value,
    secret
  });
}

function gteSdkVersion(expJson, sdkVersion) {
  if (!expJson.sdkVersion) {
    return false;
  }

  if (expJson.sdkVersion === 'UNVERSIONED') {
    return true;
  }

  try {
    return _semver.default.gte(expJson.sdkVersion, sdkVersion);
  } catch (e) {
    throw new _XDLError.default('INVALID_VERSION', `${expJson.sdkVersion} is not a valid version. Must be in the form of x.y.z`);
  }
}

function lteSdkVersion(expJson, sdkVersion) {
  if (!expJson.sdkVersion) {
    return false;
  }

  if (expJson.sdkVersion === 'UNVERSIONED') {
    return false;
  }

  try {
    return _semver.default.lte(expJson.sdkVersion, sdkVersion);
  } catch (e) {
    throw new _XDLError.default('INVALID_VERSION', `${expJson.sdkVersion} is not a valid version. Must be in the form of x.y.z`);
  }
}

function parseSdkVersionFromTag(tag) {
  if (tag.startsWith('sdk-')) {
    return tag.substring(4);
  }

  return tag;
}

async function newestSdkVersionAsync() {
  let sdkVersions = await sdkVersionsAsync();
  let result = null;
  let highestMajorVersion = '0.0.0';
  (0, _forEach.default)(sdkVersions, (value, key) => {
    if (_semver.default.major(key) > _semver.default.major(highestMajorVersion)) {
      highestMajorVersion = key;
      result = value;
    }
  });
  return {
    version: highestMajorVersion,
    data: result
  };
}

async function oldestSupportedMajorVersionAsync() {
  const sdkVersions = await sdkVersionsAsync();
  const supportedVersions = (0, _pickBy.default)(sdkVersions, v => !v.isDeprecated);
  let versionNumbers = [];
  (0, _forEach.default)(supportedVersions, (value, key) => {
    versionNumbers.push(_semver.default.major(key));
  });
  return Math.min(...versionNumbers);
}

async function facebookReactNativeVersionsAsync() {
  let sdkVersions = await sdkVersionsAsync();
  let facebookReactNativeVersions = new Set();
  (0, _forEach.default)(sdkVersions, value => {
    if (value.facebookReactNativeVersion) {
      facebookReactNativeVersions.add(value.facebookReactNativeVersion);
    }
  });
  return Array.from(facebookReactNativeVersions);
}

async function facebookReactNativeVersionToExpoVersionAsync(facebookReactNativeVersion) {
  if (!_semver.default.valid(facebookReactNativeVersion)) {
    throw new _XDLError.default('INVALID_VERSION', `${facebookReactNativeVersion} is not a valid version. Must be in the form of x.y.z`);
  }

  let sdkVersions = await sdkVersionsAsync();
  let currentSdkVersion = null;
  (0, _forEach.default)(sdkVersions, (value, key) => {
    if (_semver.default.major(value.facebookReactNativeVersion) === _semver.default.major(facebookReactNativeVersion) && _semver.default.minor(value.facebookReactNativeVersion) === _semver.default.minor(facebookReactNativeVersion) && (!currentSdkVersion || _semver.default.gt(key, currentSdkVersion))) {
      currentSdkVersion = key;
    }
  });
  return currentSdkVersion;
}

async function canTurtleBuildSdkVersion(sdkVersion, platform) {
  if (sdkVersion === 'UNVERSIONED') {
    return true;
  }

  if (_semver.default.valid(sdkVersion) == null) {
    throw new _XDLError.default('INVALID_VERSION', `"${sdkVersion}" is not a valid version. Must be in the form of x.y.z`);
  }

  const supportedVersions = await getSdkVersionsSupportedByTurtle();
  const supportedVersionsForPlatform = (0, _get.default)(supportedVersions, platform, []);
  return supportedVersionsForPlatform.indexOf(sdkVersion) !== -1;
}

async function getSdkVersionsSupportedByTurtle() {
  const api = new _ApiV.default();
  return await api.getAsync('standalone-build/supportedSDKVersions');
}
//# sourceMappingURL=__sourcemaps__/Versions.js.map
