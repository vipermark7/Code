"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPlatformSupported = isPlatformSupported;
exports.addToPathAsync = addToPathAsync;
exports.unblockAndGetVersionAsync = unblockAndGetVersionAsync;

var _lodash = _interopRequireDefault(require("lodash"));

var _spawnAsync = _interopRequireDefault(require("@expo/spawn-async"));

var _delayAsync = _interopRequireDefault(require("delay-async"));

var _rimraf = _interopRequireDefault(require("rimraf"));

var _path = _interopRequireDefault(require("path"));

var Analytics = _interopRequireWildcard(require("./Analytics"));

var Binaries = _interopRequireWildcard(require("./Binaries"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const WAIT_FOR_WATCHMAN_VERSION_MS = 3000;

function isPlatformSupported() {
  return process.platform === 'darwin';
}

async function addToPathAsync() {
  if (!isPlatformSupported()) {
    return;
  }

  await Binaries.addToPathAsync('watchman');
}

async function unblockAndGetVersionAsync(projectRoot) {
  if (!isPlatformSupported()) {
    return null;
  }

  try {
    // `watchman version` returns:
    // {
    //  "version": "4.7.0"
    // }
    let result = await _unblockAndVersionAsync(projectRoot);
    let watchmanVersion = JSON.parse(_lodash.default.trim(result.stdout)).version;
    return watchmanVersion;
  } catch (e) {
    // TODO: Maybe check to make sure this is ENOENT (which means watchman isn't installed)
    // We might want to report other errors
    return null;
  }
}

async function _unblockAndVersionAsync(projectRoot) {
  let cancelObject = {
    isDoneWithVersionCheck: false
  };
  let result = await Promise.race([_unblockAsync(projectRoot, cancelObject), _versionAsync(cancelObject)]);

  if (result.isUnblock) {
    result = await Promise.race([_versionAsync(), async () => {
      await (0, _delayAsync.default)(WAIT_FOR_WATCHMAN_VERSION_MS);
      throw new Error(`\`watchman version\` failed even after \`launchctl unload\``);
    }]);
    Analytics.logEvent('version after launchctl unload');
    return result;
  } else {
    return result;
  }
}

async function _unblockAsync(projectRoot, cancelObject) {
  await (0, _delayAsync.default)(WAIT_FOR_WATCHMAN_VERSION_MS);

  if (!cancelObject.isDoneWithVersionCheck) {
    Analytics.logEvent('launchctl unload');

    if (process.env.TMPDIR && process.env.USER) {
      // XDL's copy of watchman:
      _rimraf.default.sync(_path.default.join(process.env.TMPDIR, `${process.env.USER}-state`)); // homebrew's watchman:


      _rimraf.default.sync(`/usr/local/var/run/watchman/${process.env.USER}-state`);
    }

    if (process.platform === 'darwin') {
      await (0, _spawnAsync.default)('launchctl', ['unload', '-F', '~/Library/LaunchAgents/com.github.facebook.watchman.plist']);
    }

    if (projectRoot) {
      await (0, _spawnAsync.default)('watchman', ['watch-del', projectRoot]);
      await (0, _spawnAsync.default)('watchman', ['watch-project', projectRoot]);
    }
  }

  return {
    isUnblock: true
  };
}

async function _versionAsync(cancelObject) {
  let result = await (0, _spawnAsync.default)('watchman', ['version']);

  if (cancelObject) {
    cancelObject.isDoneWithVersionCheck = true;
  }

  return result;
}
//# sourceMappingURL=__sourcemaps__/Watchman.js.map
