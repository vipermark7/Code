"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pipeOutputToLogger = pipeOutputToLogger;
exports.default = exports.Logger = void 0;

var _bunyan = _interopRequireDefault(require("@expo/bunyan"));

var _lodash = _interopRequireDefault(require("lodash"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Logger {
  constructor() {
    this.configured = process.env.JSON_LOGS === '1';
    this.loggerObj = this.configured ? _bunyan.default.createLogger({
      name: 'xdl-detach'
    }) : console;
    this.selfConfigured = this.configured && true;
    this.extraFields = {};
  }

  configure(loggerObj) {
    this.loggerObj = loggerObj;
    this.configured = true;
    this.selfConfigured = false;
  }

  withFields(extraFields) {
    return Object.assign(new Logger(), this, {
      extraFields: { ...this.extraFields,
        ...extraFields
      }
    });
  }

  trace(...args) {
    this.logLine('trace', ...args);
  }

  debug(...args) {
    this.logLine('debug', ...args);
  }

  info(...args) {
    this.logLine('info', ...args);
  }

  warn(...args) {
    this.logLine('warn', ...args);
  }

  error(...args) {
    this.logLine('error', ...args);
  }

  fatal(...args) {
    this.logLine('fatal', ...args);
  }

  logLine(level, ...args) {
    const argsToLog = [...args];

    const extraFieldsFromArgsExist = _lodash.default.isPlainObject(_lodash.default.first(args));

    const extraFieldsFromArgs = extraFieldsFromArgsExist ? args[0] : {};

    if (extraFieldsFromArgsExist) {
      argsToLog.shift();
    }

    const extraFields = { ...extraFieldsFromArgs,
      ...this.extraFields
    };

    if (!_lodash.default.isEmpty(extraFields)) {
      argsToLog.unshift(extraFields);
    }

    this.loggerObj[level](...argsToLog);
  }

}

exports.Logger = Logger;
const LoggerDetach = new Logger();
var _default = LoggerDetach;
exports.default = _default;

function pipeOutputToLogger({
  stdout,
  stderr
} = {
  stdout: null,
  stderr: null
}, extraFields = {}, {
  stdoutOnly = false,
  dontShowStdout = false
} = {}) {
  if (stdout) {
    const stdoutExtraFields = { ...extraFields,
      dontShowStdout: false
    };

    if (dontShowStdout) {
      stdoutExtraFields.dontShowStdout = true;
    }

    stdout.on('data', line => logMultiline(line, { ...stdoutExtraFields,
      source: 'stdout'
    }));
  }

  if (stderr) {
    const source = stdoutOnly ? 'stdout' : 'stderr';
    stderr.on('data', line => logMultiline(line, { ...extraFields,
      source
    }));
  }
}

function logMultiline(data, extraFields) {
  if (!data) {
    return;
  }

  const lines = String(data).split('\n');
  lines.forEach(line => {
    if (line) {
      const args = [line];

      if (LoggerDetach.configured) {
        args.unshift(extraFields);
      }

      const shouldntLogMessage = extraFields.source === 'stdout' && extraFields.dontShowStdout && LoggerDetach.configured && !LoggerDetach.selfConfigured;

      if (!shouldntLogMessage) {
        LoggerDetach.info(...args);
      }
    }
  });
}
//# sourceMappingURL=../__sourcemaps__/detach/Logger.js.map
