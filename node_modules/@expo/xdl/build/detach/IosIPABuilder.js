"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createIPABuilder;

var _lodash = _interopRequireDefault(require("lodash"));

var _os = _interopRequireDefault(require("os"));

var _path = _interopRequireDefault(require("path"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _plist = _interopRequireDefault(require("plist"));

var _Logger = _interopRequireDefault(require("./Logger"));

var _ExponentTools = require("./ExponentTools");

var IosCodeSigning = _interopRequireWildcard(require("./IosCodeSigning"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const logger = _Logger.default.withFields({
  buildPhase: 'building and signing IPA'
});

function createIPABuilder(buildParams) {
  const {
    appUUID,
    keychainPath,
    bundleIdentifier,
    teamID,
    manifest,
    workspacePath
  } = buildParams;

  const appDir = _path.default.join('/private/tmp/turtle', appUUID);

  const buildDir = _path.default.join(appDir, 'build');

  const provisionDir = _path.default.join(appDir, 'provisioning');

  const outputPath = _path.default.join(appDir, 'archive.xcarchive');

  const uploadPath = _path.default.join(buildDir, 'archive.ipa');

  async function build() {
    const {
      provisioningProfilePath,
      clientBuild
    } = buildParams;
    await copyProvisioningProfileToHomedir(provisioningProfilePath, appUUID);
    logger.info('provisioning profile copied to home directory');

    try {
      const plistData = await readCMSMessage(provisioningProfilePath);
      logger.info('done retrieving provisioning profile data');
      logger.info('checking if teamID is present in keychain and that certificate is valid...');
      const codeSignIdentity = await IosCodeSigning.ensureCertificateValid(buildParams);
      logger.info('ensured certificate is valid');
      logger.info('validating provisioning profile...');
      IosCodeSigning.validateProvisioningProfile(plistData, {
        distCertFingerprint: codeSignIdentity,
        teamID,
        bundleIdentifier
      });
      logger.info('provisioning profile is valid');
      logger.info('writing export-options.plist file...');
      const exportMethod = IosCodeSigning.resolveExportMethod(plistData);

      const exportOptionsPlistPath = _path.default.join(provisionDir, 'export-options.plist');

      const exportOptionsData = {
        bundleIdentifier,
        provisioningProfileUUID: plistData.UUID,
        exportMethod,
        teamID
      };
      await IosCodeSigning.writeExportOptionsPlistFile(exportOptionsPlistPath, exportOptionsData);
      logger.info('created export-options.plist file');
      logger.info('generating IPA...');

      const unsignedIpaPath = _path.default.join(buildDir, `${appUUID}-unsigned.ipa`);

      const ipaBuilderArgs = {
        ipaPath: unsignedIpaPath,
        workspacePath,
        archivePath: outputPath,
        codeSignIdentity,
        exportOptionsPlistPath,
        plistData,
        keychainPath,
        exportMethod
      };
      await IosCodeSigning.buildIPA(ipaBuilderArgs, buildParams, clientBuild);
      logger.info('generated IPA');
      logger.info('creating entitlements file...');

      const generatedEntitlementsPath = _path.default.join(appDir, 'generatedEntitlements.entitlements');

      await IosCodeSigning.createEntitlementsFile({
        generatedEntitlementsPath,
        plistData,
        archivePath: outputPath,
        manifest
      });
      logger.info('created entitlements file');
      logger.info('resigning IPA...');
      await IosCodeSigning.resignIPA({
        codeSignIdentity,
        entitlementsPath: generatedEntitlementsPath,
        provisioningProfilePath,
        sourceIpaPath: unsignedIpaPath,
        destIpaPath: uploadPath,
        keychainPath
      }, buildParams);
      logger.info('resigned IPA');
    } finally {
      await removeProvisioningProfileFromHomedir(appUUID);
      logger.info('removed provisioning profile from the home directory');
    }
  }

  async function cleanup() {
    try {
      await _fsExtra.default.remove(getProvisioningProfilePath(appUUID));
    } catch (err) {
      logger.error('failed to perform cleanup, error:', err);
    }
  }

  async function copyProvisioningProfileToHomedir(provisioningProfilePath, appUUID) {
    await _fsExtra.default.mkdirp(getProvisioningProfileDirPath());
    const newProvisioningProfilePath = getProvisioningProfilePath(appUUID);
    await _fsExtra.default.copy(provisioningProfilePath, newProvisioningProfilePath);
  }

  async function removeProvisioningProfileFromHomedir(appUUID) {
    const provisioningProfilePath = getProvisioningProfilePath(appUUID);
    await _fsExtra.default.remove(provisioningProfilePath);
  }

  async function readCMSMessage(provisioningProfilePath) {
    const {
      output
    } = await (0, _ExponentTools.spawnAsyncThrowError)('security', ['cms', '-D', '-i', provisioningProfilePath], {
      stdio: 'pipe'
    });
    const plistRaw = output.join('');

    const plistData = _lodash.default.attempt(_plist.default.parse, plistRaw);

    if (_lodash.default.isError(plistData)) {
      throw new Error(`Error when parsing plist: ${plistData.message}`);
    }

    return plistData;
  }

  const getProvisioningProfileDirPath = () => _path.default.join(_os.default.homedir(), 'Library/MobileDevice/Provisioning Profiles');

  const getProvisioningProfilePath = appUUID => _path.default.join(getProvisioningProfileDirPath(), `${appUUID}.mobileprovision`);

  return {
    build,
    cleanup
  };
}
//# sourceMappingURL=../__sourcemaps__/detach/IosIPABuilder.js.map
