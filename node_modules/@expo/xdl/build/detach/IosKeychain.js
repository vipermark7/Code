"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createKeychain = createKeychain;
exports.deleteKeychain = deleteKeychain;
exports.importIntoKeychain = importIntoKeychain;
exports.cleanUpKeychains = cleanUpKeychains;

var _v = _interopRequireDefault(require("uuid/v1"));

var _lodash = _interopRequireDefault(require("lodash"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _Logger = _interopRequireDefault(require("./Logger"));

var _ExponentTools = require("./ExponentTools");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function createKeychain(appUUID, saveResultToFile = true) {
  const BUILD_PHASE = 'creating keychain';

  const logger = _Logger.default.withFields({
    buildPhase: BUILD_PHASE
  });

  const spawn = (0, _ExponentTools.createSpawner)(BUILD_PHASE, logger);
  const name = (0, _v.default)();
  const password = (0, _v.default)();
  const path = getKeychainPath(name);
  logger.info('creating new keychain...');
  await runFastlane(['run', 'create_keychain', `path:${path}`, `password:${password}`, 'unlock:true', 'timeout:360000']);
  await spawn('security', 'show-keychain-info', path, {
    stdoutOnly: true
  });
  logger.info('created new keychain');
  const keychainInfo = {
    name,
    path,
    password
  };

  if (saveResultToFile) {
    const keychainInfoPath = getKeychainInfoPath(appUUID);
    await _fsExtra.default.writeFile(keychainInfoPath, JSON.stringify(keychainInfo));
    logger.info('saved keychain info to %s', keychainInfoPath);
  }

  return keychainInfo;
}

async function deleteKeychain({
  path,
  appUUID
}) {
  const BUILD_PHASE = 'deleting keychain';

  const logger = _Logger.default.withFields({
    buildPhase: BUILD_PHASE
  });

  logger.info('deleting keychain...');
  await runFastlane(['run', 'delete_keychain', `keychain_path:${path}`]);

  if (appUUID) {
    const keychainInfoPath = getKeychainInfoPath(appUUID);
    await _fsExtra.default.remove(keychainInfoPath);
  }
}

async function importIntoKeychain({
  keychainPath,
  certPath,
  certPassword
}) {
  const BUILD_PHASE = 'importing certificate into keychain';

  const logger = _Logger.default.withFields({
    buildPhase: BUILD_PHASE
  });

  const spawn = (0, _ExponentTools.createSpawner)(BUILD_PHASE);
  logger.info('importing certificate into keychain...');
  const args = ['import', certPath, '-A', '-k', keychainPath, '-f', 'pkcs12'];

  if (certPassword) {
    logger.info('certificate has password');
    args.push('-P', certPassword);
  } else {
    logger.info("certificate doesn't have password");
  }

  await spawn('security', ...args);
  logger.info('imported certificate into keychain');
}

async function cleanUpKeychains() {
  try {
    _Logger.default.info('Cleaning up keychains...');

    const {
      stdout: keychainsListRaw
    } = await (0, _ExponentTools.spawnAsyncThrowError)('security', ['list-keychains'], {
      stdio: 'pipe'
    });
    const allKeychainsList = keychainsListRaw.match(/"(.*)"/g).map(i => i.slice(1, i.length - 1));
    const turtleKeychainsList = keychainsListRaw.match(/\/private\/tmp\/xdl\/(.*).keychain/g);
    let shouldCleanSearchList = false;

    if (turtleKeychainsList) {
      for (const keychainPath of turtleKeychainsList) {
        try {
          await deleteKeychain({
            path: keychainPath
          });
        } catch (err) {
          _Logger.default.warn(`Failed to delete keychain: ${keychainPath}`, err);

          shouldCleanSearchList = true;
        }
      }

      if (shouldCleanSearchList) {
        const newSearchList = _lodash.default.difference(allKeychainsList, turtleKeychainsList);

        await (0, _ExponentTools.spawnAsyncThrowError)('security', ['list-keychains', '-s', ...newSearchList], {
          stdio: 'pipe'
        });
      }
    }

    _Logger.default.info('Cleaned up keychains');
  } catch (err) {
    _Logger.default.error(err);

    throw new Error('Failed to clean up keychains');
  }
}

async function runFastlane(fastlaneArgs) {
  const fastlaneEnvVars = {
    FASTLANE_DISABLE_COLORS: 1,
    FASTLANE_SKIP_UPDATE_CHECK: 1,
    CI: 1,
    LC_ALL: 'en_US.UTF-8'
  };
  await (0, _ExponentTools.spawnAsyncThrowError)('fastlane', fastlaneArgs, {
    env: { ...process.env,
      ...fastlaneEnvVars
    }
  });
}

const getKeychainPath = name => `/private/tmp/xdl/${name}.keychain`;

const getKeychainInfoPath = appUUID => `/private/tmp/${appUUID}-keychain-info.json`;
//# sourceMappingURL=../__sourcemaps__/detach/IosKeychain.js.map
