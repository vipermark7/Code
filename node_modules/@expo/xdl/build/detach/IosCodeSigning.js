"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ensureCertificateValid = ensureCertificateValid;
exports.findP12CertSerialNumber = findP12CertSerialNumber;
exports.validateProvisioningProfile = validateProvisioningProfile;
exports.writeExportOptionsPlistFile = writeExportOptionsPlistFile;
exports.buildIPA = buildIPA;
exports.createEntitlementsFile = createEntitlementsFile;
exports.resignIPA = resignIPA;
exports.resolveExportMethod = void 0;

var _nodeForge = _interopRequireDefault(require("node-forge"));

var _lodash = _interopRequireDefault(require("lodash"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _globPromise = _interopRequireDefault(require("glob-promise"));

var _plist = _interopRequireDefault(require("plist"));

var _crypto = _interopRequireDefault(require("crypto"));

var _ExponentTools = require("./ExponentTools");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function ensureCertificateValid({
  certPath,
  certPassword,
  teamID
}) {
  const certData = await _fsExtra.default.readFile(certPath);

  const fingerprint = _genP12CertFingerprint(certData, certPassword);

  const identities = await _findIdentitiesByTeamID(teamID);
  const isValid = identities.indexOf(fingerprint) !== -1;

  if (!isValid) {
    throw new Error(`codesign ident not present in find-identity: ${fingerprint}\n${identities}`);
  }

  return fingerprint;
}

function _genP12CertFingerprint(p12Buffer, passwordRaw) {
  const certData = _getCertData(p12Buffer, passwordRaw);

  const certAsn1 = _nodeForge.default.pki.certificateToAsn1(certData);

  const certDer = _nodeForge.default.asn1.toDer(certAsn1).getBytes();

  return _nodeForge.default.md.sha1.create().update(certDer).digest().toHex().toUpperCase();
}

function findP12CertSerialNumber(p12Buffer, passwordRaw) {
  const certData = _getCertData(p12Buffer, passwordRaw);

  const {
    serialNumber
  } = certData;
  return serialNumber ? certData.serialNumber.replace(/^0+/, '').toUpperCase() : null;
}

function _getCertData(p12Buffer, passwordRaw) {
  if (Buffer.isBuffer(p12Buffer)) {
    p12Buffer = p12Buffer.toString('base64');
  } else if (typeof p12Buffer !== 'string') {
    throw new Error('_getCertData only takes strings and buffers.');
  }

  const password = String(passwordRaw || '');

  const p12Der = _nodeForge.default.util.decode64(p12Buffer);

  const p12Asn1 = _nodeForge.default.asn1.fromDer(p12Der);

  const p12 = _nodeForge.default.pkcs12.pkcs12FromAsn1(p12Asn1, password);

  const certBagType = _nodeForge.default.pki.oids.certBag;

  const certData = _lodash.default.get(p12.getBags({
    bagType: certBagType
  }), [certBagType, 0, 'cert']);

  if (!certData) {
    throw new Error("_getCertData: couldn't find cert bag");
  }

  return certData;
}

async function _findIdentitiesByTeamID(teamID) {
  const {
    output
  } = await (0, _ExponentTools.spawnAsyncThrowError)('security', ['find-identity', '-v', '-s', `(${teamID})`], {
    stdio: 'pipe'
  });
  return output.join('');
}

function validateProvisioningProfile(plistData, {
  distCertFingerprint,
  bundleIdentifier
}) {
  _ensureDeveloperCertificateIsValid(plistData, distCertFingerprint);

  _ensureBundleIdentifierIsValid(plistData, bundleIdentifier);
}

function _ensureDeveloperCertificateIsValid(plistData, distCertFingerprint) {
  const devCertBase64 = plistData.DeveloperCertificates[0];

  const devCertFingerprint = _genDerCertFingerprint(devCertBase64);

  if (devCertFingerprint !== distCertFingerprint) {
    throw new Error('validateProvisioningProfile: provisioning profile is not associated with uploaded distribution certificate');
  }
}

function _genDerCertFingerprint(certBase64) {
  const certBuffer = Buffer.from(certBase64, 'base64');
  return _crypto.default.createHash('sha1').update(certBuffer).digest('hex').toUpperCase();
}

function _ensureBundleIdentifierIsValid(plistData, expectedBundleIdentifier) {
  const actualApplicationIdentifier = plistData.Entitlements['application-identifier'];
  const actualBundleIdentifier = /\.(.+)/.exec(actualApplicationIdentifier)[1];

  if (expectedBundleIdentifier !== actualBundleIdentifier) {
    throw new Error(`validateProvisioningProfile: wrong bundleIdentifier found in provisioning profile; expected: ${expectedBundleIdentifier}, found (in provisioning profile): ${actualBundleIdentifier}`);
  }
}

async function writeExportOptionsPlistFile(plistPath, data) {
  const toWrite = createExportOptionsPlist(data);
  await _fsExtra.default.writeFile(plistPath, toWrite);
}

const createExportOptionsPlist = ({
  bundleIdentifier,
  provisioningProfileUUID,
  exportMethod,
  teamID
}) => {
  const disableBitcodeCompiling = `<key>uploadBitcode</key>
    <false/>
    <key>compileBitcode</key>
    <false/>
    <key>uploadSymbols</key>
    <false/>`;
  return `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict>
    <key>method</key>
    <string>${exportMethod}</string>
    <key>teamID</key>
    <string>${teamID}</string>
    <key>provisioningProfiles</key>
    <dict>
      <key>${bundleIdentifier}</key>
      <string>${provisioningProfileUUID}</string>
    </dict>
    ${exportMethod === 'ad-hoc' || exportMethod === 'enterprise' ? disableBitcodeCompiling : ''}
  </dict>
</plist>`;
};

async function buildIPA({
  ipaPath,
  workspacePath,
  archivePath,
  codeSignIdentity,
  exportOptionsPlistPath,
  plistData,
  keychainPath,
  exportMethod
}, credentials, client = false) {
  if (client) {
    await (0, _ExponentTools.spawnAsyncThrowError)('xcodebuild', ['-exportArchive', '-archivePath', archivePath, '-exportOptionsPlist', exportOptionsPlistPath, '-exportPath', _path.default.Dir(ipaPath), `OTHER_CODE_SIGN_FLAGS="--keychain ${keychainPath}"`], {
      env: { ...process.env,
        CI: 1
      }
    });
  } else {
    await runFastlane(credentials, ['gym', '-n', _path.default.basename(ipaPath), '--workspace', workspacePath, '--archive_path', archivePath, '--skip_build_archive', 'true', '-i', codeSignIdentity, '--export_options', exportOptionsPlistPath, '--export_method', exportMethod, '--export_xcargs', `OTHER_CODE_SIGN_FLAGS="--keychain ${keychainPath}"`, '-o', _path.default.dirname(ipaPath), '--verbose'], {
      buildPhase: 'building and signing IPA'
    });
  }
}

const resolveExportMethod = plistData => {
  if (plistData.ProvisionedDevices) {
    return 'ad-hoc';
  } else if (plistData.ProvisionsAllDevices === true) {
    return 'enterprise';
  } else {
    return 'app-store';
  }
};

exports.resolveExportMethod = resolveExportMethod;
const entitlementTransferRules = ['com.apple.developer.associated-domains', 'com.apple.developer.healthkit', 'com.apple.developer.homekit', 'com.apple.developer.icloud-container-identifiers', 'com.apple.developer.icloud-services', 'com.apple.developer.in-app-payments', 'com.apple.developer.networking.vpn.api', 'com.apple.developer.ubiquity-container-identifiers', 'com.apple.developer.ubiquity-kvstore-identifier', 'com.apple.external-accessory.wireless-configuration', 'com.apple.security.application-groups', 'inter-app-audio', 'keychain-access-groups'];
const blacklistedEntitlementKeysWithoutICloud = ['com.apple.developer.icloud-container-environment', 'com.apple.developer.icloud-container-identifiers', 'com.apple.developer.icloud-services', 'com.apple.developer.ubiquity-container-identifiers', 'com.apple.developer.ubiquity-kvstore-identifier'];
const blacklistedEntitlementKeys = ['com.apple.developer.icloud-container-development-container-identifiers', 'com.apple.developer.restricted-resource-mode', 'inter-app-audio', 'com.apple.developer.homekit', 'com.apple.developer.healthkit', 'com.apple.developer.in-app-payments', 'com.apple.developer.maps', 'com.apple.external-accessory.wireless-configuration'];
const icloudContainerEnvKey = 'com.apple.developer.icloud-container-environment';

async function createEntitlementsFile({
  generatedEntitlementsPath,
  plistData,
  archivePath,
  manifest
}) {
  const decodedProvisioningProfileEntitlements = plistData.Entitlements;

  const entitlementsPattern = _path.default.join(archivePath, 'Products/Applications/*.app/*.entitlements');

  const entitlementsPaths = await (0, _globPromise.default)(entitlementsPattern);

  if (entitlementsPaths.length === 0) {
    throw new Error("Didn't find any generated entitlements file in archive.");
  } else if (entitlementsPaths.length !== 1) {
    throw new Error('Found more than one entitlements file.');
  }

  const archiveEntitlementsPath = entitlementsPaths[0];
  const archiveEntitlementsRaw = await _fsExtra.default.readFile(archiveEntitlementsPath);

  const archiveEntitlementsData = _lodash.default.attempt(_plist.default.parse, String(archiveEntitlementsRaw));

  if (_lodash.default.isError(archiveEntitlementsData)) {
    throw new Error(`Error when parsing plist: ${archiveEntitlementsData.message}`);
  }

  const entitlements = { ...decodedProvisioningProfileEntitlements
  };
  entitlementTransferRules.forEach(rule => {
    if (rule in archiveEntitlementsData) {
      entitlements[rule] = archiveEntitlementsData[rule];
    }
  });

  let generatedEntitlements = _lodash.default.omit(entitlements, blacklistedEntitlementKeys);

  if (!manifest.ios.usesIcloudStorage) {
    generatedEntitlements = _lodash.default.omit(generatedEntitlements, blacklistedEntitlementKeysWithoutICloud);
  } else {
    const ubiquityKvKey = 'com.apple.developer.ubiquity-kvstore-identifier';

    if (generatedEntitlements[ubiquityKvKey]) {
      const teamId = generatedEntitlements[ubiquityKvKey].split('.')[0];
      generatedEntitlements[ubiquityKvKey] = `${teamId}.${manifest.ios.bundleIdentifier}`;
    }

    generatedEntitlements['com.apple.developer.icloud-services'] = ['CloudDocuments'];
  }

  if (!manifest.ios.associatedDomains) {
    generatedEntitlements = _lodash.default.omit(generatedEntitlements, 'com.apple.developer.associated-domains');
  }

  if (generatedEntitlements[icloudContainerEnvKey]) {
    const envs = generatedEntitlements[icloudContainerEnvKey].filter(i => i === 'Production');
    generatedEntitlements[icloudContainerEnvKey] = envs;
  }

  const generatedEntitlementsPlistData = _lodash.default.attempt(_plist.default.build, generatedEntitlements);

  await _fsExtra.default.writeFile(generatedEntitlementsPath, generatedEntitlementsPlistData, {
    mode: 0o755
  });
  const {
    output
  } = await (0, _ExponentTools.spawnAsyncThrowError)('/usr/libexec/PlistBuddy', ['-x', '-c', 'Print', generatedEntitlementsPath], {
    stdio: 'pipe'
  });
  const plistDataReformatted = output.join('');
  await _fsExtra.default.writeFile(generatedEntitlementsPath, plistDataReformatted, {
    mode: 0o755
  });
}

async function resignIPA({
  codeSignIdentity,
  entitlementsPath,
  provisioningProfilePath,
  sourceIpaPath,
  destIpaPath,
  keychainPath
}, credentials) {
  await (0, _ExponentTools.spawnAsyncThrowError)('cp', ['-rf', sourceIpaPath, destIpaPath]);
  await runFastlane(credentials, ['sigh', 'resign', '--verbose', '--entitlements', entitlementsPath, '--signing_identity', codeSignIdentity, '--keychain_path', keychainPath, '--provisioning_profile', provisioningProfilePath, destIpaPath], {
    buildPhase: 'building and signing IPA'
  });
}

async function runFastlane({
  teamID
}, fastlaneArgs, loggerFields) {
  const fastlaneEnvVars = {
    FASTLANE_SKIP_UPDATE_CHECK: 1,
    FASTLANE_DISABLE_COLORS: 1,
    FASTLANE_TEAM_ID: teamID,
    CI: 1,
    LC_ALL: 'en_US.UTF-8'
  };
  await (0, _ExponentTools.spawnAsyncThrowError)('fastlane', fastlaneArgs, {
    env: { ...process.env,
      ...fastlaneEnvVars
    },
    pipeToLogger: true,
    dontShowStdout: false,
    loggerFields
  });
}
//# sourceMappingURL=../__sourcemaps__/detach/IosCodeSigning.js.map
