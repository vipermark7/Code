"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDeviceInfoAsync = getDeviceInfoAsync;

var _lodash = _interopRequireDefault(require("lodash"));

var _child_process = _interopRequireDefault(require("child_process"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _jsonFile = _interopRequireDefault(require("@expo/json-file"));

var _os = _interopRequireDefault(require("os"));

var _path = _interopRequireDefault(require("path"));

var _rimraf = _interopRequireDefault(require("rimraf"));

var _spawnAsync = _interopRequireDefault(require("@expo/spawn-async"));

var _tar = _interopRequireDefault(require("tar"));

var _ip = _interopRequireDefault(require("./ip"));

var _Api = _interopRequireDefault(require("./Api"));

var Binaries = _interopRequireWildcard(require("./Binaries"));

var Env = _interopRequireWildcard(require("./Env"));

var _FormData = _interopRequireDefault(require("./tools/FormData"));

var _User = _interopRequireWildcard(require("./User"));

var _UserSettings = _interopRequireDefault(require("./UserSettings"));

var Utils = _interopRequireWildcard(require("./Utils"));

var Watchman = _interopRequireWildcard(require("./Watchman"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function _uploadLogsAsync(info) {
  let user = await _User.default.getCurrentUserAsync();
  let username = user ? user.username : _User.ANONYMOUS_USERNAME; // write info to file

  let expoHome = _UserSettings.default.dotExpoHomeDirectory();

  let infoJsonFile = new _jsonFile.default(_path.default.join(expoHome, 'debug-info.json'));
  await infoJsonFile.writeAsync(info); // copy files to tempDir

  let tempDir = _path.default.join(Env.home(), `${username}-diagnostics`);

  let archivePath = _path.default.join(expoHome, 'diagnostics.tar.gz');

  await Utils.ncpAsync(expoHome, tempDir, {
    filter: filename => {
      if (filename.includes('diagnostics') || filename.includes('starter-app-cache') || filename.includes('android-apk-cache') || filename.includes('ios-simulator-app-cache') || filename.includes('state.json~')) {
        return false;
      } else {
        return true;
      }
    }
  }); // remove access token

  try {
    let settingsJsonFile = new _jsonFile.default(_path.default.join(tempDir, _UserSettings.default.SETTINGS_FILE_NAME));
    let settingsJson = await settingsJsonFile.readAsync();

    for (let key of ['accessToken', 'auth', 'uuid', 'sendTo']) {
      if (settingsJson[key]) {
        settingsJson[key] = 'redacted';
      }
    }

    await settingsJsonFile.writeAsync(settingsJson);
  } catch (e) {
    console.error(e);
  } // compress


  await _tar.default.create({
    file: archivePath,
    gzip: true,
    cwd: Env.home()
  }, [_path.default.relative(Env.home(), tempDir)]);

  _rimraf.default.sync(tempDir); // upload


  let formData = new _FormData.default();
  formData.append('archive', _fsExtra.default.createReadStream(archivePath));
  let response = await _Api.default.callMethodAsync('uploadDiagnostics', [{}], 'put', null, {
    formData
  });
  return response.url;
}
/* eslint-disable prefer-template */
// From http://stackoverflow.com/questions/15900485/correct-way-to-convert-size-in-bytes-to-kb-mb-gb-in-javascript


function _formatBytes(bytes) {
  if (bytes >= 1000000000) {
    return (bytes / 1000000000).toFixed(2) + ' GB';
  } else if (bytes >= 1000000) {
    return (bytes / 1000000).toFixed(2) + ' MB';
  } else if (bytes >= 1000) {
    return (bytes / 1000).toFixed(2) + ' KB';
  } else if (bytes > 1) {
    return bytes + ' bytes';
  } else if (bytes === 1) {
    return bytes + '${bytes} byte';
  } else {
    return '0 bytes';
  }
}
/* eslint-enable prefer-template */


async function getDeviceInfoAsync(options = {}) {
  let info = {};
  let whichCommand = process.platform === 'win32' ? 'where' : 'which';

  try {
    let result = await (0, _spawnAsync.default)('node', ['--version']);
    info.nodeVersion = _lodash.default.trim(result.stdout);
  } catch (e) {}

  try {
    let result = await (0, _spawnAsync.default)(whichCommand, ['node']);
    info.nodePath = _lodash.default.trim(result.stdout);
  } catch (e) {}

  try {
    let result = await (0, _spawnAsync.default)('npm', ['--version']);
    info.npmVersion = _lodash.default.trim(result.stdout);
  } catch (e) {}

  try {
    let result = await (0, _spawnAsync.default)(whichCommand, ['npm']);
    info.npmPath = _lodash.default.trim(result.stdout);
  } catch (e) {}

  try {
    info.watchmanVersion = await Watchman.unblockAndGetVersionAsync();
  } catch (e) {}

  try {
    let result = await (0, _spawnAsync.default)(whichCommand, ['watchman']);
    info.watchmanPath = _lodash.default.trim(result.stdout);
  } catch (e) {}

  try {
    let result = await (0, _spawnAsync.default)('adb', ['version']);
    info.adbVersion = _lodash.default.trim(result.stdout);
  } catch (e) {}

  try {
    let result = await (0, _spawnAsync.default)(whichCommand, ['adb']);
    info.adbPath = _lodash.default.trim(result.stdout);
  } catch (e) {}

  info.path = process.env.PATH;
  info.shell = process.env.SHELL;
  info.home = _os.default.homedir();
  info.nvmPath = process.env.NVM_PATH;
  info.lang = process.env.LANG;
  info.dirname = __dirname;
  info.memoryFree = _formatBytes(_os.default.freemem());
  info.memoryTotal = _formatBytes(_os.default.totalmem());
  info.ip = _ip.default.address();
  info.hostname = _os.default.hostname(); // TODO: fix these commands on linux

  if (process.platform === 'darwin') {
    // || process.platform === 'linux') {
    try {
      info.xdeProcesses = _lodash.default.trim(_child_process.default.execSync('pgrep XDE | xargs ps -p').toString());
    } catch (e) {}

    try {
      info.numXdeProcesses = _lodash.default.trim(_child_process.default.execSync('pgrep XDE | wc -l').toString());
    } catch (e) {}

    try {
      info.watchmanProcesses = _lodash.default.trim(_child_process.default.execSync('pgrep watchman | xargs ps -p').toString());
    } catch (e) {}

    try {
      info.numWatchmanProcesses = _lodash.default.trim(_child_process.default.execSync('pgrep watchman | wc -l').toString());
    } catch (e) {}

    try {
      info.ngrokProcesses = _lodash.default.trim(_child_process.default.execSync('pgrep ngrok | xargs ps -p').toString());
    } catch (e) {}

    try {
      info.numNgrokProcesses = _lodash.default.trim(_child_process.default.execSync('pgrep ngrok | wc -l').toString());
    } catch (e) {}
  }

  if (process.platform === 'darwin') {
    // `xcrun` and `xcodebuild` will pop up a dialog if Xcode isn't installed
    if (Binaries.isXcodeInstalled()) {
      try {
        let result = await (0, _spawnAsync.default)('xcrun', ['--version']);
        info.xcrunVersion = _lodash.default.trim(result.stdout);
      } catch (e) {}

      try {
        let result = await (0, _spawnAsync.default)('xcodebuild', ['-version']);
        info.xcodebuildVersion = _lodash.default.trim(result.stdout);
      } catch (e) {}
    }

    try {
      let result = await (0, _spawnAsync.default)('launchctl', ['limit']);
      info.launchctlLimit = _lodash.default.trim(result.stdout);
    } catch (e) {}
  } // TODO: can probably get rid of these options if we remove Intercom


  if (options.uploadLogs) {
    info.url = await _uploadLogsAsync(info);
  }

  if (options.limitLengthForIntercom) {
    info = _lodash.default.mapValues(info, value => {
      if (value && value.length > 100 && !value.startsWith('http')) {
        return value.substring(0, 100);
      } else {
        return value;
      }
    });
  }

  return info;
}
//# sourceMappingURL=__sourcemaps__/Diagnostics.js.map
