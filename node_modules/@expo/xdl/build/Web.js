"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDebugModeEnabled = isDebugModeEnabled;
exports.isInfoEnabled = isInfoEnabled;
exports.shouldWebpackClearLogs = shouldWebpackClearLogs;
exports.logEnvironmentInfo = logEnvironmentInfo;
exports.invokeWebpackConfigAsync = invokeWebpackConfigAsync;
exports.openProjectAsync = openProjectAsync;
exports.onlySupportsWebAsync = onlySupportsWebAsync;

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _openBrowser = _interopRequireDefault(require("react-dev-utils/openBrowser"));

var _getenv = _interopRequireDefault(require("getenv"));

var _chalk = _interopRequireDefault(require("chalk"));

var _Logger = _interopRequireDefault(require("./Logger"));

var Doctor = _interopRequireWildcard(require("./project/Doctor"));

var _ProjectUtils = require("./project/ProjectUtils");

var UrlUtils = _interopRequireWildcard(require("./UrlUtils"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// When you have errors in the production build that aren't present in the development build you can use `EXPO_WEB_DEBUG=true expo start --no-dev` to debug those errors.
// - Prevent the production build from being minified
// - Include file path info comments in the bundle
function isDebugModeEnabled() {
  return _getenv.default.boolish('EXPO_WEB_DEBUG', false);
}

function isInfoEnabled() {
  return _getenv.default.boolish('EXPO_WEB_INFO', false);
}

function shouldWebpackClearLogs() {
  return !isInfoEnabled() && !_getenv.default.boolish('EXPO_DEBUG', false);
}

function logEnvironmentInfo(projectRoot, tag, config) {
  if (isDebugModeEnabled() && config.mode === 'production') {
    (0, _ProjectUtils.logWarning)(projectRoot, tag, `Webpack is bundling your project in \`production\` mode with the ${_chalk.default.bold('`EXPO_WEB_DEBUG`')} environment variable enabled. You should toggle it off before building for production.`);
  }
}

async function invokePossibleFunctionAsync(objectOrMethod, ...args) {
  if (typeof objectOrMethod === 'function') {
    return await objectOrMethod(...args);
  } else {
    return objectOrMethod;
  }
}

function applyEnvironmentVariables(config) {
  // Use EXPO_DEBUG_WEB=true to enable debugging features for cases where the prod build
  // has errors that aren't caught in development mode.
  // Related: https://github.com/expo/expo-cli/issues/614
  if (isDebugModeEnabled() && config.mode === 'production') {
    // TODO: Bacon: Should this throw if not running in prod mode?
    // Add comments that describe the file import/exports.
    // This will make it easier to debug.
    config.output.pathinfo = true; // Prevent minimizing when running in debug mode.

    config.optimization.minimize = false;
  }

  return config;
}

async function invokeWebpackConfigAsync(env, argv) {
  // Check if the project has a webpack.config.js in the root.
  const projectWebpackConfig = _path.default.resolve(env.projectRoot, 'webpack.config.js');

  let config;

  if (_fsExtra.default.existsSync(projectWebpackConfig)) {
    const webpackConfig = require(projectWebpackConfig);

    config = await invokePossibleFunctionAsync(webpackConfig, env, argv);
  } else {
    // Fallback to the default expo webpack config.
    const createExpoWebpackConfigAsync = require('@expo/webpack-config');

    config = await createExpoWebpackConfigAsync(env, argv);
  }

  return applyEnvironmentVariables(config);
}

async function openProjectAsync(projectRoot) {
  await Doctor.validateWebSupportAsync(projectRoot);

  try {
    let url = await UrlUtils.constructWebAppUrlAsync(projectRoot);
    (0, _openBrowser.default)(url);
    return {
      success: true,
      url
    };
  } catch (e) {
    _Logger.default.global.error(`Couldn't start project on web: ${e.message}`);

    return {
      success: false,
      error: e
    };
  }
} // If platforms only contains the "web" field


async function onlySupportsWebAsync(projectRoot) {
  const {
    exp
  } = await (0, _ProjectUtils.readConfigJsonAsync)(projectRoot);

  if (Array.isArray(exp.platforms) && exp.platforms.length === 1) {
    return exp.platforms[0] === 'web';
  }

  return false;
}
//# sourceMappingURL=__sourcemaps__/Web.js.map
