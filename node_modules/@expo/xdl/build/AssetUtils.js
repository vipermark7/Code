"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNewFilename = exports.readAssetJsonAsync = exports.getAssetFilesAsync = exports.hasUnoptimizedAssetsAsync = exports.optimizeImageAsync = exports.calculateHash = exports.toReadableValue = void 0;

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _crypto = _interopRequireDefault(require("crypto"));

var _chalk = _interopRequireDefault(require("chalk"));

var _glob = _interopRequireDefault(require("glob"));

var _imageUtils = require("@expo/image-utils");

var _jsonFile = _interopRequireDefault(require("@expo/json-file"));

var _tempy = _interopRequireDefault(require("tempy"));

var _Logger = _interopRequireDefault(require("./Logger"));

var _ProjectUtils = require("./project/ProjectUtils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Converts a raw number of bytes into a human readable value
 */
const toReadableValue = bytes => {
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const index = Math.floor(Math.log(bytes) / Math.log(1024));
  const reduced = (bytes / Math.pow(1024, index)).toFixed(2) * 1;
  return `${reduced} ${sizes[index]}`;
};
/*
 * Calculate SHA256 Checksum value of a file based on its contents
 */


exports.toReadableValue = toReadableValue;

const calculateHash = file => {
  const contents = _fsExtra.default.readFileSync(file);

  return _crypto.default.createHash('sha256').update(contents).digest('hex');
};
/*
 * Compress an inputted jpg or png
 */


exports.calculateHash = calculateHash;

const optimizeImageAsync = async (inputPath, quality) => {
  _Logger.default.global.info(`Optimizing ${inputPath}`);

  const outputPath = _tempy.default.directory();

  await (0, _imageUtils.sharpAsync)({
    input: inputPath,
    output: outputPath,
    quality
  });
  return _path.default.join(outputPath, _path.default.basename(inputPath));
};
/*
 * Returns a boolean indicating whether or not there are assets to optimize
 */


exports.optimizeImageAsync = optimizeImageAsync;

const hasUnoptimizedAssetsAsync = async (projectDir, options) => {
  if (!_fsExtra.default.existsSync(_path.default.join(projectDir, '.expo-shared/assets.json'))) {
    return true;
  }

  const {
    selectedFiles
  } = await getAssetFilesAsync(projectDir, options);
  const {
    assetInfo
  } = await readAssetJsonAsync(projectDir);

  for (const file of selectedFiles) {
    const hash = calculateHash(file);

    if (!assetInfo[hash]) {
      return true;
    }
  }

  return false;
};
/*
 * Find all project assets under assetBundlePatterns in app.json excluding node_modules.
 * If --include of --exclude flags were passed in those results are filtered out.
 */


exports.hasUnoptimizedAssetsAsync = hasUnoptimizedAssetsAsync;

const getAssetFilesAsync = async (projectDir, options) => {
  const {
    exp
  } = await (0, _ProjectUtils.readConfigJsonAsync)(projectDir);
  const {
    assetBundlePatterns
  } = exp;
  const globOptions = {
    cwd: projectDir,
    ignore: ['**/node_modules/**', '**/ios/**', '**/android/**']
  }; // All files must be returned even if flags are passed in to properly update assets.json

  const allFiles = [];
  const patterns = assetBundlePatterns || ['**/*'];
  patterns.forEach(pattern => {
    allFiles.push(..._glob.default.sync(pattern, globOptions));
  }); // If --include is passed in, only return files matching that pattern

  const included = options && options.include ? [..._glob.default.sync(options.include, globOptions)] : allFiles;
  const toExclude = new Set();

  if (options && options.exclude) {
    _glob.default.sync(options.exclude, globOptions).forEach(file => toExclude.add(file));
  } // If --exclude is passed in, filter out files matching that pattern


  const excluded = included.filter(file => !toExclude.has(file));
  const filtered = options && options.exclude ? excluded : included;
  return {
    allFiles: filterImages(allFiles, projectDir),
    selectedFiles: filterImages(filtered, projectDir)
  };
};
/*
 * Formats an array of files to include the project directory and filters out PNGs and JPGs.
 */


exports.getAssetFilesAsync = getAssetFilesAsync;

const filterImages = (files, projectDir) => {
  const regex = /\.(png|jpg|jpeg)$/;
  const withDirectory = files.map(file => `${projectDir}/${file}`.replace('//', '/'));
  const allImages = withDirectory.filter(file => regex.test(file.toLowerCase()));
  return allImages;
};
/*
 * Read the contents of assets.json under .expo-shared folder. Create the file/directory if they don't exist.
 */


const readAssetJsonAsync = async projectDir => {
  const dirPath = _path.default.join(projectDir, '.expo-shared');

  if (!_fsExtra.default.existsSync(dirPath)) {
    _fsExtra.default.mkdirSync(dirPath);
  }

  const assetJson = new _jsonFile.default(_path.default.join(dirPath, 'assets.json'));

  if (!_fsExtra.default.existsSync(assetJson.file)) {
    const message = `Creating ${_chalk.default.italic('.expo-shared/assets.json')} in the project's root directory.\n` + `This file is autogenerated and should not be edited directly.\n` + 'You should commit this to git so that asset state is shared between collaborators.';

    _Logger.default.global.info(message);

    await assetJson.writeAsync({});
  }

  const assetInfo = await assetJson.readAsync();
  return {
    assetJson,
    assetInfo
  };
};
/*
 * Add .orig extension to a filename in a path string
 */


exports.readAssetJsonAsync = readAssetJsonAsync;

const createNewFilename = image => {
  const {
    dir,
    name,
    ext
  } = _path.default.parse(image);

  return _path.default.join(dir, name + '.orig' + ext);
};

exports.createNewFilename = createNewFilename;
//# sourceMappingURL=__sourcemaps__/AssetUtils.js.map
