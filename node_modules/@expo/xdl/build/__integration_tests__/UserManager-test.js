"use strict";

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _hashids = _interopRequireDefault(require("hashids"));

var _uuid = _interopRequireDefault(require("uuid"));

var _ApiV = _interopRequireDefault(require("../ApiV2"));

var _User = require("../User");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const _makeShortId = (salt, minLength = 10) => {
  const hashIds = new _hashids.default(salt, minLength);
  return hashIds.encode(Date.now());
};

describe('UserManager', () => {
  let userForTest;
  let userForTestPassword;
  beforeAll(async () => {
    process.env.__UNSAFE_EXPO_HOME_DIRECTORY = _path.default.join('/', 'tmp', `.expo-${_makeShortId(_uuid.default.v1())}`);

    const UserManager = _newTestUserManager();

    const username = `xdl-test-${_makeShortId(_uuid.default.v1())}`;

    const password = _uuid.default.v1(); // Register a new user that we can use for this test run


    const newUser = await UserManager.registerAsync({
      username,
      password,
      email: `adam+${username}@getexponent.com`,
      givenName: 'XDL',
      familyName: 'Test User'
    });
    userForTest = newUser;
    userForTestPassword = password; // save password so we can use it to login

    await UserManager.logoutAsync(); // log us out so we're in a clean state for these tests
  });
  afterAll(async () => {
    if (process.env.__UNSAFE_EXPO_HOME_DIRECTORY) {
      _fsExtra.default.removeSync(process.env.__UNSAFE_EXPO_HOME_DIRECTORY);
    }

    const api = _ApiV.default.clientForUser(userForTest);

    try {
      await api.postAsync('auth/deleteUser');
    } catch (e) {
      console.error(e);
    }
  });
  it('should make available a global, shared UserManager singleton', () => {
    const {
      default: UserManager
    } = require('../User');

    expect(UserManager).toBeDefined();
    expect(UserManager.initialize).toBeDefined();
  });
  it('should not have a currently logged in user', async () => {
    const UserManager = _newTestUserManager();

    try {
      await UserManager.ensureLoggedInAsync();
    } catch (e) {
      expect(e.message).toEqual('Not logged in');
    }
  });
  it('should login successfully', async () => {
    const UserManager = _newTestUserManager();

    await UserManager.loginAsync('user-pass', {
      username: userForTest.username,
      password: userForTestPassword
    });
    const user = await UserManager.getCurrentUserAsync();
    expect(user).not.toBeNull();

    if (!user) {
      return;
    }

    expect(user.username).toBe(userForTest.username);
    expect(user.sessionSecret).not.toBeFalsy();
  });
  it('should use cached user after first run of getCurrentUserAsync() instead of making call to www', async () => {
    const UserManager = _newTestUserManager();

    await UserManager.loginAsync('user-pass', {
      username: userForTest.username,
      password: userForTestPassword
    }); // Spy on getProfileAsync

    const _getProfileSpy = jest.fn(UserManager._getProfileAsync); // $FlowFixMe


    UserManager._getProfileAsync = _getProfileSpy;
    await UserManager.getCurrentUserAsync();
    expect(_getProfileSpy).not.toHaveBeenCalled();
  });
  it('should correctly use lock to prevent getting session twice, simulatenously', async () => {
    const UserManager = _newTestUserManager();

    await UserManager.loginAsync('user-pass', {
      username: userForTest.username,
      password: userForTestPassword
    });
    UserManager._currentUser = null; // Spy on getProfileAsync

    const _getProfileSpy = jest.fn(UserManager._getProfileAsync); // $FlowFixMe


    UserManager._getProfileAsync = _getProfileSpy;
    const users = await Promise.all([UserManager.getCurrentUserAsync(), UserManager.getCurrentUserAsync()]);
    expect(_getProfileSpy).toHaveBeenCalledTimes(1); // This shouldn't have changed, but just double check it

    expect(users[0].sessionSecret).toEqual(users[1].sessionSecret);
  });
});

function _newTestUserManager() {
  const UserManager = new _User.UserManagerInstance();
  UserManager.initialize();
  return UserManager;
}
//# sourceMappingURL=../__sourcemaps__/__integration_tests__/UserManager-test.js.map
