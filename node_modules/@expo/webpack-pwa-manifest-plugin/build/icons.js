'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseIcons = undefined;

var _getIterator2;

function _load_getIterator() {
  return _getIterator2 = _interopRequireDefault(require('babel-runtime/core-js/get-iterator'));
}

var _promise;

function _load_promise() {
  return _promise = _interopRequireDefault(require('babel-runtime/core-js/promise'));
}

var _toConsumableArray2;

function _load_toConsumableArray() {
  return _toConsumableArray2 = _interopRequireDefault(require('babel-runtime/helpers/toConsumableArray'));
}

var _objectWithoutProperties2;

function _load_objectWithoutProperties() {
  return _objectWithoutProperties2 = _interopRequireDefault(require('babel-runtime/helpers/objectWithoutProperties'));
}

var _regenerator;

function _load_regenerator() {
  return _regenerator = _interopRequireDefault(require('babel-runtime/regenerator'));
}

var _asyncToGenerator2;

function _load_asyncToGenerator() {
  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));
}

var getBufferWithMimeAsync = function () {
  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee(_ref2, mimeType, _ref3) {
    var src = _ref2.src,
        resizeMode = _ref2.resizeMode,
        color = _ref2.color;
    var width = _ref3.width,
        height = _ref3.height;
    var imagePath, localSrc;
    return (_regenerator || _load_regenerator()).default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            imagePath = void 0;

            if (supportedMimeTypes.includes(mimeType)) {
              _context.next = 5;
              break;
            }

            imagePath = src;
            _context.next = 13;
            break;

          case 5:
            localSrc = src;

            // In case the icon is a remote URL we need to download it first

            if (!src.startsWith('http')) {
              _context.next = 10;
              break;
            }

            _context.next = 9;
            return downloadImage(src);

          case 9:
            localSrc = _context.sent;

          case 10:
            _context.next = 12;
            return resize(localSrc, mimeType, width, height, resizeMode, color);

          case 12:
            imagePath = _context.sent;

          case 13:
            _context.prev = 13;
            _context.next = 16;
            return (_fsExtra || _load_fsExtra()).default.readFile(imagePath);

          case 16:
            return _context.abrupt('return', _context.sent);

          case 19:
            _context.prev = 19;
            _context.t0 = _context['catch'](13);
            throw new (_IconError || _load_IconError()).default('It was not possible to read \'' + src + '\'.');

          case 22:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this, [[13, 19]]);
  }));

  return function getBufferWithMimeAsync(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();

var downloadImage = function () {
  var _ref4 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee2(url) {
    var outputPath, localPath, response, streamPipeline;
    return (_regenerator || _load_regenerator()).default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            outputPath = (_tempy || _load_tempy()).default.directory();
            localPath = _path.default.join(outputPath, _path.default.basename(url));
            _context2.next = 4;
            return (0, (_nodeFetch || _load_nodeFetch()).default)(url);

          case 4:
            response = _context2.sent;

            if (response.ok) {
              _context2.next = 7;
              break;
            }

            throw new (_IconError || _load_IconError()).default('It was not possible to download splash screen from \'' + url + '\'');

          case 7:

            // Download to local file
            streamPipeline = _util.default.promisify(_stream.default.pipeline);
            _context2.next = 10;
            return streamPipeline(response.body, (_fsExtra || _load_fsExtra()).default.createWriteStream(localPath));

          case 10:
            return _context2.abrupt('return', localPath);

          case 11:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));

  return function downloadImage(_x4) {
    return _ref4.apply(this, arguments);
  };
}();

var processImage = function () {
  var _ref5 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee3(size, icon, fingerprint, publicPath) {
    var _parseSize, width, height, mimeType, _buffer;

    return (_regenerator || _load_regenerator()).default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _parseSize = parseSize(size), width = _parseSize.width, height = _parseSize.height;

            if (!(width <= 0 || height <= 0)) {
              _context3.next = 3;
              break;
            }

            return _context3.abrupt('return');

          case 3:
            mimeType = (_mime || _load_mime()).default.getType(icon.src);
            _context3.next = 6;
            return getBufferWithMimeAsync(icon, mimeType, { width: width, height: height });

          case 6:
            _buffer = _context3.sent;
            return _context3.abrupt('return', processIcon(width, height, icon, _buffer, mimeType, publicPath, fingerprint));

          case 8:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));

  return function processImage(_x5, _x6, _x7, _x8) {
    return _ref5.apply(this, arguments);
  };
}();

var resize = function () {
  var _ref6 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee4(inputPath, mimeType, width, height) {
    var fit = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'contain';
    var background = arguments[5];
    var outputPath, message;
    return (_regenerator || _load_regenerator()).default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            outputPath = (_tempy || _load_tempy()).default.directory();
            _context4.next = 4;
            return (0, (_imageUtils || _load_imageUtils()).sharpAsync)({
              input: inputPath,
              output: outputPath,
              format: mimeType.split('/')[1]
            }, [{
              operation: 'flatten',
              background: background
            }, {
              operation: 'resize',
              width: width,
              height: height,
              fit: fit,
              background: background
            }]);

          case 4:
            return _context4.abrupt('return', _path.default.join(outputPath, _path.default.basename(inputPath)));

          case 7:
            _context4.prev = 7;
            _context4.t0 = _context4['catch'](0);
            message = _context4.t0.message;
            throw new (_IconError || _load_IconError()).default('It was not possible to generate splash screen \'' + inputPath + '\'. ' + message);

          case 11:
          case 'end':
            return _context4.stop();
        }
      }
    }, _callee4, this, [[0, 7]]);
  }));

  return function resize(_x9, _x10, _x11, _x12) {
    return _ref6.apply(this, arguments);
  };
}();

var parseIcons = exports.parseIcons = function () {
  var _ref8 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee6(inputIcons, fingerprint, publicPath) {
    var _this = this;

    var icons, assets, promises, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _loop, _iterator, _step;

    return (_regenerator || _load_regenerator()).default.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (inputIcons.length) {
              _context6.next = 2;
              break;
            }

            return _context6.abrupt('return', {});

          case 2:
            icons = [];
            assets = [];
            promises = [];
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            _context6.prev = 8;

            _loop = function _loop() {
              var icon = _step.value;
              var sizes = icon.sizes;

              promises = [].concat((0, (_toConsumableArray2 || _load_toConsumableArray()).default)(promises), (0, (_toConsumableArray2 || _load_toConsumableArray()).default)(sizes.map(function () {
                var _ref11 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee5(size) {
                  var _ref12, manifestIcon, webpackAsset;

                  return (_regenerator || _load_regenerator()).default.wrap(function _callee5$(_context5) {
                    while (1) {
                      switch (_context5.prev = _context5.next) {
                        case 0:
                          _context5.next = 2;
                          return processImage(size, icon, fingerprint, publicPath);

                        case 2:
                          _ref12 = _context5.sent;
                          manifestIcon = _ref12.manifestIcon;
                          webpackAsset = _ref12.webpackAsset;

                          icons.push(manifestIcon);
                          assets.push(webpackAsset);

                        case 7:
                        case 'end':
                          return _context5.stop();
                      }
                    }
                  }, _callee5, _this);
                }));

                return function (_x17) {
                  return _ref11.apply(this, arguments);
                };
              }())));
            };

            for (_iterator = (0, (_getIterator2 || _load_getIterator()).default)(inputIcons); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              _loop();
            }
            _context6.next = 17;
            break;

          case 13:
            _context6.prev = 13;
            _context6.t0 = _context6['catch'](8);
            _didIteratorError = true;
            _iteratorError = _context6.t0;

          case 17:
            _context6.prev = 17;
            _context6.prev = 18;

            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }

          case 20:
            _context6.prev = 20;

            if (!_didIteratorError) {
              _context6.next = 23;
              break;
            }

            throw _iteratorError;

          case 23:
            return _context6.finish(20);

          case 24:
            return _context6.finish(17);

          case 25:
            _context6.next = 27;
            return (_promise || _load_promise()).default.all(promises);

          case 27:
            return _context6.abrupt('return', {
              icons: icons.filter(function (icon) {
                return icon;
              }).sort(function (_ref9, _ref10) {
                var sizes = _ref9.sizes;
                var sizesB = _ref10.sizes;

                if (sizes < sizesB) return -1;else if (sizes > sizesB) return 1;
                return 0;
              }),
              // startupImages: icons.filter(({ isStartupImage }) => isStartupImage),
              assets: assets
            });

          case 28:
          case 'end':
            return _context6.stop();
        }
      }
    }, _callee6, this, [[8, 13, 17, 25], [18,, 20, 24]]);
  }));

  return function parseIcons(_x14, _x15, _x16) {
    return _ref8.apply(this, arguments);
  };
}();

exports.retrieveIcons = retrieveIcons;

var _fsExtra;

function _load_fsExtra() {
  return _fsExtra = _interopRequireDefault(require('fs-extra'));
}

var _mime;

function _load_mime() {
  return _mime = _interopRequireDefault(require('mime'));
}

var _nodeFetch;

function _load_nodeFetch() {
  return _nodeFetch = _interopRequireDefault(require('node-fetch'));
}

var _path = _interopRequireDefault(require('path'));

var _stream = _interopRequireDefault(require('stream'));

var _tempy;

function _load_tempy() {
  return _tempy = _interopRequireDefault(require('tempy'));
}

var _util = _interopRequireDefault(require('util'));

var _imageUtils;

function _load_imageUtils() {
  return _imageUtils = require('@expo/image-utils');
}

var _uri;

function _load_uri() {
  return _uri = require('./helpers/uri');
}

var _fingerprint;

function _load_fingerprint() {
  return _fingerprint = _interopRequireDefault(require('./helpers/fingerprint'));
}

var _IconError;

function _load_IconError() {
  return _IconError = _interopRequireDefault(require('./errors/IconError'));
}

var _Apple;

function _load_Apple() {
  return _Apple = require('./validators/Apple');
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var supportedMimeTypes = ['image/png', 'image/jpeg', 'image/webp'];

function parseArray(i) {
  if (i == null) return [];
  return i && !Array.isArray(i) ? [i] : i;
}

function sanitizeIcon(iconSnippet) {
  if (!iconSnippet.src) {
    throw new (_IconError || _load_IconError()).default('Unknown icon source.');
  }
  var sizes = parseArray(iconSnippet.size || iconSnippet.sizes);
  if (!sizes) {
    throw new (_IconError || _load_IconError()).default('Unknown icon sizes.');
  }
  return {
    src: iconSnippet.src,
    resizeMode: iconSnippet.resizeMode,
    sizes: sizes,
    media: iconSnippet.media,
    destination: iconSnippet.destination,
    ios: iconSnippet.ios || false,
    color: iconSnippet.color
  };
}

function processIcon(width, height, icon, buffer, mimeType, publicPath, shouldFingerprint) {
  var dimensions = width + 'x' + height;
  var fileName = shouldFingerprint ? 'icon_' + dimensions + '.' + (0, (_fingerprint || _load_fingerprint()).default)(buffer) + '.' + (_mime || _load_mime()).default.getExtension(mimeType) : 'icon_' + dimensions + '.' + (_mime || _load_mime()).default.getExtension(mimeType);
  var iconOutputDir = icon.destination ? (0, (_uri || _load_uri()).joinURI)(icon.destination, fileName) : fileName;
  var iconPublicUrl = (0, (_uri || _load_uri()).joinURI)(publicPath, iconOutputDir);

  var manifestIcon = null;
  if (width === height) {
    manifestIcon = {
      src: iconPublicUrl,
      sizes: dimensions,
      type: mimeType
    };
  }
  return {
    manifestIcon: manifestIcon,
    webpackAsset: {
      output: iconOutputDir,
      url: iconPublicUrl,
      source: buffer,
      size: buffer.length,
      ios: icon.ios ? { valid: icon.ios, media: icon.media, size: dimensions, href: iconPublicUrl } : false,
      resizeMode: icon.resizeMode,
      color: icon.color
    }
  };
}

function parseSize(size) {
  var width = void 0;
  var height = void 0;
  if (Array.isArray(size) && size.length) {
    // [0, 0] || [0]
    width = size[0];
    height = size.length > 1 ? size[1] : size[0];
  } else if (typeof size === 'number') {
    // 0
    width = size;
    height = size;
  } else if (typeof size === 'string') {
    // '0x0'
    var dimensions = size.split('x');
    width = dimensions[0];
    height = dimensions[1];
  }
  return { width: width, height: height };
}

function retrieveIcons(manifest) {
  // Remove these items so they aren't written to disk.
  var startupImages = manifest.startupImages,
      icons = manifest.icons,
      config = (0, (_objectWithoutProperties2 || _load_objectWithoutProperties()).default)(manifest, ['startupImages', 'icons']);

  var parsedStartupImages = parseArray(startupImages);

  var parsedIcons = parseArray(icons);

  if (parsedStartupImages.length) {
    // TODO: Bacon: use all of the startup images
    var startupImage = parsedStartupImages[0];
    parsedIcons = [].concat((0, (_toConsumableArray2 || _load_toConsumableArray()).default)(parsedIcons), (0, (_toConsumableArray2 || _load_toConsumableArray()).default)((0, (_Apple || _load_Apple()).fromStartupImage)(startupImage)));
  }

  var response = parsedIcons.map(function (icon) {
    return sanitizeIcon(icon);
  });
  return [response, config];
}
//# sourceMappingURL=__sourcemaps__/icons.js.map
