'use strict';

var _regenerator;

function _load_regenerator() {
  return _regenerator = _interopRequireDefault(require('babel-runtime/regenerator'));
}

var _keys;

function _load_keys() {
  return _keys = _interopRequireDefault(require('babel-runtime/core-js/object/keys'));
}

var _getIterator2;

function _load_getIterator() {
  return _getIterator2 = _interopRequireDefault(require('babel-runtime/core-js/get-iterator'));
}

var _asyncToGenerator2;

function _load_asyncToGenerator() {
  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));
}

var _extends2;

function _load_extends() {
  return _extends2 = _interopRequireDefault(require('babel-runtime/helpers/extends'));
}

var _classCallCheck2;

function _load_classCallCheck() {
  return _classCallCheck2 = _interopRequireDefault(require('babel-runtime/helpers/classCallCheck'));
}

var _createClass2;

function _load_createClass() {
  return _createClass2 = _interopRequireDefault(require('babel-runtime/helpers/createClass'));
}

var _typeof2;

function _load_typeof() {
  return _typeof2 = _interopRequireDefault(require('babel-runtime/helpers/typeof'));
}

var _createMetatagsFromConfig;

function _load_createMetatagsFromConfig() {
  return _createMetatagsFromConfig = _interopRequireDefault(require('./createMetatagsFromConfig'));
}

var _injector;

function _load_injector() {
  return _injector = require('./injector');
}

var _Colors;

function _load_Colors() {
  return _Colors = _interopRequireDefault(require('./validators/Colors'));
}

var _Presets;

function _load_Presets() {
  return _Presets = _interopRequireDefault(require('./validators/Presets'));
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TAP_CMD = 'webpack-pwa-manifest-plugin';
var TAP = 'WebpackPWAManifestPlugin';

function isObject(item) {
  return (typeof item === 'undefined' ? 'undefined' : (0, (_typeof2 || _load_typeof()).default)(item)) === 'object' && !Array.isArray(item) && item !== null;
}

var DEFAULT_OPTIONS = {
  fingerprints: true,
  inject: true,
  ios: false,
  publicPath: null,
  includeDirectory: true
};

/**
 * Generate a `manifest.json` for your PWA based on the `app.json`.
 * This plugin must be **after HtmlWebpackPlugin**.
 *
 * To test PWAs in chrome visit `chrome://flags#enable-desktop-pwas`
 */

var WebpackPwaManifest = function () {
  function WebpackPwaManifest(appJson, _ref) {
    var noResources = _ref.noResources,
        filename = _ref.filename,
        publicPath = _ref.publicPath,
        HtmlWebpackPlugin = _ref.HtmlWebpackPlugin;
    (0, (_classCallCheck2 || _load_classCallCheck()).default)(this, WebpackPwaManifest);

    this.HtmlWebpackPlugin = HtmlWebpackPlugin;
    if (!isObject(appJson)) {
      throw new Error('app.json must be an object');
    }

    var _ref2 = appJson.expo || appJson || {},
        _ref2$web = _ref2.web,
        web = _ref2$web === undefined ? {} : _ref2$web;

    this.assets = null;
    this.htmlPlugin = false;
    this.config = appJson;

    this.options = (0, (_extends2 || _load_extends()).default)({}, DEFAULT_OPTIONS, {
      publicPath: publicPath,
      // filename: options.fingerprints ? '[name].[hash].[ext]' : '[name].[ext]',
      noResources: noResources,
      filename: filename,
      includeDirectory: false,
      metatags: (0, (_createMetatagsFromConfig || _load_createMetatagsFromConfig()).default)(appJson)
    });

    this.manifest = {
      // PWA
      background_color: web.backgroundColor,
      description: web.description,
      dir: web.dir,
      display: web.display,
      lang: web.lang,
      name: web.name,
      orientation: web.orientation,
      prefer_related_applications: web.preferRelatedApplications,
      related_applications: web.relatedApplications,
      scope: web.scope,
      short_name: web.shortName,
      start_url: web.startUrl,
      theme_color: web.themeColor,
      crossorigin: web.crossorigin
    };
    if (!noResources) {
      this.manifest.startupImages = web.startupImages;
      this.manifest.icons = web.icons;
    }
    this.validateManifest(this.manifest);
  }

  (0, (_createClass2 || _load_createClass()).default)(WebpackPwaManifest, [{
    key: 'validateManifest',
    value: function validateManifest(manifest) {
      (0, (_Presets || _load_Presets()).default)(manifest, 'dir', 'display', 'orientation', 'crossorigin');
      (0, (_Colors || _load_Colors()).default)(manifest, 'background_color', 'theme_color');
    }
  }, {
    key: 'getManifest',
    value: function getManifest() {
      return this.manifest;
    }
  }, {
    key: 'apply',
    value: function apply(compiler) {
      var _this = this;

      // Hook into the html-webpack-plugin processing
      // and add the html
      var injectToHtml = function () {
        var _ref3 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee(htmlPluginData, compilation, callback) {
          var publicPath, manifestFile, tags, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, metatagName, content, manifestLink, tagsHTML;

          return (_regenerator || _load_regenerator()).default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!_this.htmlPlugin) {
                    _this.htmlPlugin = true;
                  }

                  publicPath = _this.options.publicPath || compilation.options.output.publicPath;

                  // The manifest (this.manifest) should be ready by this point.
                  // It will be written to disk here.

                  _context.next = 4;
                  return (0, (_injector || _load_injector()).buildResources)(_this, publicPath);

                case 4:
                  manifestFile = _context.sent;

                  if (_this.options.inject) {
                    _context.next = 8;
                    break;
                  }

                  callback(null, htmlPluginData);
                  return _context.abrupt('return');

                case 8:
                  tags = (0, (_injector || _load_injector()).generateAppleSplashAndIconTags)(_this.assets);
                  _iteratorNormalCompletion = true;
                  _didIteratorError = false;
                  _iteratorError = undefined;
                  _context.prev = 12;


                  for (_iterator = (0, (_getIterator2 || _load_getIterator()).default)((0, (_keys || _load_keys()).default)(_this.options.metatags)); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    metatagName = _step.value;
                    content = _this.options.metatags[metatagName];

                    tags = (0, (_injector || _load_injector()).applyTag)(tags, 'meta', {
                      name: metatagName,
                      content: content
                    });
                  }

                  _context.next = 20;
                  break;

                case 16:
                  _context.prev = 16;
                  _context.t0 = _context['catch'](12);
                  _didIteratorError = true;
                  _iteratorError = _context.t0;

                case 20:
                  _context.prev = 20;
                  _context.prev = 21;

                  if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                  }

                case 23:
                  _context.prev = 23;

                  if (!_didIteratorError) {
                    _context.next = 26;
                    break;
                  }

                  throw _iteratorError;

                case 26:
                  return _context.finish(23);

                case 27:
                  return _context.finish(20);

                case 28:
                  if (manifestFile) {
                    manifestLink = {
                      rel: 'manifest',
                      href: manifestFile.url
                    };

                    if (_this.manifest.crossorigin) {
                      manifestLink.crossorigin = _this.manifest.crossorigin;
                    }
                    tags = (0, (_injector || _load_injector()).applyTag)(tags, 'link', manifestLink);
                  }

                  tagsHTML = (0, (_injector || _load_injector()).generateHtmlTags)(tags);

                  htmlPluginData.html = htmlPluginData.html.replace(/(<\/head>)/i, tagsHTML + '</head>');

                  callback(null, htmlPluginData);

                case 32:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, _this, [[12, 16, 20, 28], [21,, 23, 27]]);
        }));

        return function injectToHtml(_x, _x2, _x3) {
          return _ref3.apply(this, arguments);
        };
      }();

      // webpack 4
      if (compiler.hooks) {
        compiler.hooks.compilation.tap(TAP, function (cmpp) {
          // This is set in html-webpack-plugin pre-v4.
          var hook = cmpp.hooks.htmlWebpackPluginAfterHtmlProcessing;
          if (!hook) {
            var HtmlWebpackPlugin = _this.HtmlWebpackPlugin || require('html-webpack-plugin');
            hook = HtmlWebpackPlugin.getHooks(cmpp).beforeEmit;
          }

          hook.tapAsync(TAP_CMD, function (htmlPluginData, cb) {
            injectToHtml(htmlPluginData, cmpp, function () {
              (0, (_injector || _load_injector()).injectResources)(cmpp, _this.assets, cb);
            });
          });
        });
      } else {
        compiler.plugin('compilation', function (compilation) {
          compilation.plugin('html-webpack-plugin-before-html-processing', function (htmlPluginData, callback) {
            return injectToHtml(htmlPluginData, compilation, callback);
          });
        });
      }
    }
  }]);
  return WebpackPwaManifest;
}();

module.exports = WebpackPwaManifest;
//# sourceMappingURL=__sourcemaps__/index.js.map
