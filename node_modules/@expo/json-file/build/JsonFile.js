'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

let readAsync = (() => {
  var _ref = _asyncToGenerator(function* /*:: <JSONObject: JSONT>*/(file /*: string*/, options /*:: ?: Options<JSONObject>*/) /*: Promise<JSONObject>*/ {
    let json;
    try {
      json = yield readFileAsync(file, 'utf8');
    } catch (error) {
      let defaultValue = cantReadFileDefault(options);
      if (defaultValue === undefined) {
        throw new _JsonFileError2.default(`Can't read JSON file: ${file}`, error, error.code);
      } else {
        return defaultValue;
      }
    }
    try {
      if (_getOption(options, 'json5')) {
        return _json2.default.parse(json);
      } else {
        return JSON.parse(json);
      }
    } catch (e) {
      let defaultValue = jsonParseErrorDefault(options);
      if (defaultValue === undefined) {
        let location = locationFromSyntaxError(e, json);
        if (location) {
          let codeFrame = (0, _codeFrame.codeFrameColumns)(json, { start: location });
          e.codeFrame = codeFrame;
          e.message += `\n${codeFrame}`;
        }
        throw new _JsonFileError2.default(`Error parsing JSON file: ${file}`, e, 'EJSONPARSE');
      } else {
        return defaultValue;
      }
    }
  });

  return function readAsync(_x, _x2) {
    return _ref.apply(this, arguments);
  };
})();

let getAsync = (() => {
  var _ref2 = _asyncToGenerator(function* /*:: <JSONObject: JSONT, K: $Keys<JSONObject>, DefaultValue>*/(file /*: string*/, key /*: K*/, defaultValue /*: DefaultValue*/, options /*:: ?: Options<JSONObject>*/) /*: Promise<any>*/ {
    const object = yield readAsync(file, options);
    if (defaultValue === undefined && !(0, _has2.default)(object, key)) {
      throw new _JsonFileError2.default(`No value at key path "${key}" in JSON object from: ${file}`);
    }
    return (0, _get2.default)(object, key, defaultValue);
  });

  return function getAsync(_x3, _x4, _x5, _x6) {
    return _ref2.apply(this, arguments);
  };
})();

let writeAsync = (() => {
  var _ref3 = _asyncToGenerator(function* /*:: <JSONObject: JSONT>*/(file /*: string*/, object /*: JSONObject*/, options /*:: ?: Options<JSONObject>*/) /*: Promise<JSONObject>*/ {
    const space = _getOption(options, 'space');
    const json5 = _getOption(options, 'json5');
    let json;
    try {
      if (json5) {
        json = _json2.default.stringify(object, null, space);
      } else {
        json = JSON.stringify(object, null, space);
      }
    } catch (e) {
      throw new _JsonFileError2.default(`Couldn't JSON.stringify object for file: ${file}`, e);
    }
    yield writeFileAtomicAsync(file, json, {});
    return object;
  });

  return function writeAsync(_x7, _x8, _x9) {
    return _ref3.apply(this, arguments);
  };
})();

let setAsync = (() => {
  var _ref4 = _asyncToGenerator(function* /*:: <JSONObject: JSONT>*/(file /*: string*/, key /*: string*/, value /*: mixed*/, options /*:: ?: Options<JSONObject>*/) /*: Promise<JSONObject>*/ {
    // TODO: Consider implementing some kind of locking mechanism, but
    // it's not critical for our use case, so we'll leave it out for now
    let object = yield readAsync(file, options);
    object = (0, _set2.default)(object, key, value);
    return writeAsync(file, object, options);
  });

  return function setAsync(_x10, _x11, _x12, _x13) {
    return _ref4.apply(this, arguments);
  };
})();

let mergeAsync = (() => {
  var _ref5 = _asyncToGenerator(function* /*:: <JSONObject: JSONT>*/(file /*: string*/, sources /*: Array<JSONObject> | JSONObject*/, options /*:: ?: Options<JSONObject>*/) /*: Promise<JSONObject>*/ {
    const object = yield readAsync(file, options);
    if (Array.isArray(sources)) {
      Object.assign(object, ...sources);
    } else {
      Object.assign(object, sources);
    }
    return writeAsync(file, object, options);
  });

  return function mergeAsync(_x14, _x15, _x16) {
    return _ref5.apply(this, arguments);
  };
})();

let deleteKeyAsync = (() => {
  var _ref6 = _asyncToGenerator(function* /*:: <JSONObject: JSONT>*/(file /*: string*/, key /*: string*/, options /*:: ?: Options<JSONObject>*/) /*: Promise<JSONObject>*/ {
    return deleteKeysAsync(file, [key], options);
  });

  return function deleteKeyAsync(_x17, _x18, _x19) {
    return _ref6.apply(this, arguments);
  };
})();

let deleteKeysAsync = (() => {
  var _ref7 = _asyncToGenerator(function* /*:: <JSONObject: JSONT>*/(file /*: string*/, keys /*: Array<string>*/, options /*:: ?: Options<JSONObject>*/) /*: Promise<JSONObject>*/ {
    const object = yield readAsync(file, options);
    let didDelete = false;

    for (let i = 0; i < keys.length; i++) {
      let key = keys[i];
      if (object.hasOwnProperty(key)) {
        delete object[key];
        didDelete = true;
      }
    }

    if (didDelete) {
      return writeAsync(file, object, options);
    }
    return object;
  });

  return function deleteKeysAsync(_x20, _x21, _x22) {
    return _ref7.apply(this, arguments);
  };
})();

let rewriteAsync = (() => {
  var _ref8 = _asyncToGenerator(function* /*:: <JSONObject: JSONT>*/(file /*: string*/, options /*:: ?: Options<JSONObject>*/) /*: Promise<JSONObject>*/ {
    const object = yield readAsync(file, options);
    return writeAsync(file, object, options);
  });

  return function rewriteAsync(_x23, _x24) {
    return _ref8.apply(this, arguments);
  };
})();

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _get = require('lodash/get');

var _get2 = _interopRequireDefault(_get);

var _has = require('lodash/has');

var _has2 = _interopRequireDefault(_has);

var _set = require('lodash/set');

var _set2 = _interopRequireDefault(_set);

var _json = require('json5');

var _json2 = _interopRequireDefault(_json);

var _writeFileAtomic = require('write-file-atomic');

var _writeFileAtomic2 = _interopRequireDefault(_writeFileAtomic);

var _util = require('util.promisify');

var _util2 = _interopRequireDefault(_util);

var _codeFrame = require('@babel/code-frame');

var _JsonFileError = require('./JsonFileError');

var _JsonFileError2 = _interopRequireDefault(_JsonFileError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * @flow
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            */

const readFileAsync = (0, _util2.default)(_fs2.default.readFile);
const writeFileAtomicAsync = (0, _util2.default)(_writeFileAtomic2.default);

/*:: type JSONT = Object;*/
/*:: type Options<JSONObject: JSONT> = {
  badJsonDefault?: JSONObject,
  jsonParseErrorDefault?: JSONObject,
  cantReadFileDefault?: JSONObject,
  default?: JSONObject,
  json5?: boolean,
  space?: number,
};*/


const DEFAULT_OPTIONS /*: Options<*>*/ = {
  badJsonDefault: undefined,
  jsonParseErrorDefault: undefined,
  cantReadFileDefault: undefined,
  default: undefined,
  json5: false,
  space: 2
};

/**
 * The JsonFile class represents the contents of json file.
 *
 * It's polymorphic on "JSONT", which is a simple type representing
 * and object with string keys and either objects or primitive types as values.
 * @type {[type]}
 */
class JsonFile /*:: <JSONObject: JSONT>*/ {

  constructor(file /*: string*/, options /*:: ?: Options<JSONObject>*/ = {}) {
    this.file = file;
    this.options = options;
  }

  readAsync(options /*:: ?: Options<JSONObject>*/) /*: Promise<JSONObject>*/ {
    var _this = this;

    return _asyncToGenerator(function* () {
      return readAsync(_this.file, _this._getOptions(options));
    })();
  }

  writeAsync(object /*: JSONObject*/, options /*:: ?: Options<JSONObject>*/) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      return writeAsync(_this2.file, object, _this2._getOptions(options));
    })();
  }

  getAsync /*:: <K: string, DefaultValue>*/(key /*: K*/, defaultValue /*: DefaultValue*/, options /*:: ?: Options<JSONObject>*/) /*: $ElementType<JSONObject, K> | DefaultValue*/ {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      return getAsync(_this3.file, key, defaultValue, _this3._getOptions(options));
    })();
  }

  setAsync(key /*: string*/, value /*: mixed*/, options /*:: ?: Options<JSONObject>*/) {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      return setAsync(_this4.file, key, value, _this4._getOptions(options));
    })();
  }

  mergeAsync(sources /*: JSONObject | Array<JSONObject>*/, options /*:: ?: Options<JSONObject>*/) {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      return mergeAsync(_this5.file, sources, _this5._getOptions(options));
    })();
  }

  deleteKeyAsync(key /*: string*/, options /*:: ?: Options<JSONObject>*/) {
    var _this6 = this;

    return _asyncToGenerator(function* () {
      return deleteKeyAsync(_this6.file, key, _this6._getOptions(options));
    })();
  }

  deleteKeysAsync(keys /*: Array<string>*/, options /*:: ?: Options<JSONObject>*/) {
    var _this7 = this;

    return _asyncToGenerator(function* () {
      return deleteKeysAsync(_this7.file, keys, _this7._getOptions(options));
    })();
  }

  rewriteAsync(options /*:: ?: Options<JSONObject>*/) {
    var _this8 = this;

    return _asyncToGenerator(function* () {
      return rewriteAsync(_this8.file, _this8._getOptions(options));
    })();
  }

  _getOptions(options /*:: ?: Options<JSONObject>*/) /*: Options<JSONObject>*/ {
    return _extends({}, this.options, options);
  }
}

exports.default = JsonFile;
JsonFile.readAsync = readAsync;
JsonFile.writeAsync = writeAsync;
JsonFile.getAsync = getAsync;
JsonFile.setAsync = setAsync;
JsonFile.mergeAsync = mergeAsync;
JsonFile.deleteKeyAsync = deleteKeyAsync;
JsonFile.deleteKeysAsync = deleteKeysAsync;
JsonFile.rewriteAsync = rewriteAsync;


function jsonParseErrorDefault /*:: <JSONObject: JSONT>*/(options /*:: ?: Options<JSONObject>*/ = {}) /*: JSONObject | void*/ {
  if (options.jsonParseErrorDefault === undefined) {
    return options.default;
  } else {
    return options.jsonParseErrorDefault;
  }
}

function cantReadFileDefault /*:: <JSONObject: JSONT>*/(options /*:: ?: Options<JSONObject>*/ = {}) /*: JSONObject | void*/ {
  if (options.cantReadFileDefault === undefined) {
    return options.default;
  } else {
    return options.cantReadFileDefault;
  }
}

function _getOption /*:: <JSONObject: JSONT, X: $Subtype<$Keys<Options<JSONObject>>>>*/(options /*:: ?: Options<JSONObject>*/, field /*: X*/) /*: $ElementType<Options<JSONObject>, X>*/ {
  if (options) {
    if (options[field] !== undefined) {
      return options[field];
    }
  }
  return DEFAULT_OPTIONS[field];
}

function locationFromSyntaxError(error, sourceString) {
  // JSON5 SyntaxError has lineNumber and columnNumber.
  if ('lineNumber' in error && 'columnNumber' in error) {
    return { line: error.lineNumber, column: error.columnNumber };
  }
  // JSON SyntaxError only includes the index in the message.
  let match = /at position (\d+)/.exec(error.message);
  if (match) {
    let index = parseInt(match[1], 10);
    let lines = sourceString.slice(0, index + 1).split('\n');
    return { line: lines.length, column: lines[lines.length - 1].length };
  }

  return null;
}