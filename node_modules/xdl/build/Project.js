'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stopAsync = exports.startAsync = exports.getUrlAsync = exports.setOptionsAsync = exports.stopTunnelsAsync = exports.startTunnelsAsync = exports.stopExpoServerAsync = exports.startExpoServerAsync = exports.stopReactNativeServerAsync = exports.startReactNativeServerAsync = exports.buildAsync = exports.publishAsync = exports.exportForAppHosting = exports.mergeAppDistributions = exports.getLatestReleaseAsync = exports.getSlugAsync = exports.getManifestUrlWithFallbackAsync = exports.currentStatus = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

let currentStatus = exports.currentStatus = (() => {
  var _ref = _asyncToGenerator(function* (projectDir) {
    const { packagerPort, expoServerPort } = yield (_ProjectSettings || _load_ProjectSettings()).readPackagerInfoAsync(projectDir);
    if (packagerPort && expoServerPort) {
      return 'running';
    } else if (packagerPort || expoServerPort) {
      return 'ill';
    } else {
      return 'exited';
    }
  });

  return function currentStatus(_x) {
    return _ref.apply(this, arguments);
  };
})();

// DECPRECATED: use UrlUtils.constructManifestUrlAsync


let getManifestUrlWithFallbackAsync = exports.getManifestUrlWithFallbackAsync = (() => {
  var _ref2 = _asyncToGenerator(function* (projectRoot) {
    return {
      url: yield (_UrlUtils || _load_UrlUtils()).constructManifestUrlAsync(projectRoot),
      isUrlFallback: false
    };
  });

  return function getManifestUrlWithFallbackAsync(_x2) {
    return _ref2.apply(this, arguments);
  };
})();

let _assertValidProjectRoot = (() => {
  var _ref3 = _asyncToGenerator(function* (projectRoot) {
    if (!projectRoot) {
      throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.NO_PROJECT_ROOT, 'No project root specified');
    }
  });

  return function _assertValidProjectRoot(_x3) {
    return _ref3.apply(this, arguments);
  };
})();

let _getFreePortAsync = (() => {
  var _ref4 = _asyncToGenerator(function* (rangeStart) {
    let port = yield (0, (_freeportAsync || _load_freeportAsync()).default)(rangeStart);
    if (!port) {
      throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.NO_PORT_FOUND, 'No available port found');
    }

    return port;
  });

  return function _getFreePortAsync(_x4) {
    return _ref4.apply(this, arguments);
  };
})();

let _getForPlatformAsync = (() => {
  var _ref5 = _asyncToGenerator(function* (projectRoot, url, platform, { errorCode, minLength }) {
    url = (_UrlUtils || _load_UrlUtils()).getPlatformSpecificBundleUrl(url, platform);

    let fullUrl = `${url}&platform=${platform}`;
    let response;

    try {
      response = yield (_axios || _load_axios()).default.get(fullUrl, {
        responseType: 'text',
        // Workaround for https://github.com/axios/axios/issues/907.
        // Without transformResponse, axios will parse the body as JSON regardless of the responseType/
        transformResponse: [function (data) {
          return data;
        }],
        proxy: false,
        validateStatus: function (status) {
          return status === 200;
        },
        headers: {
          'Exponent-Platform': platform
        }
      });
    } catch (error) {
      if (error.response) {
        if (error.response.data) {
          let body;
          try {
            body = JSON.parse(error.response.data);
          } catch (e) {
            (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, 'expo', response.data);
          }

          if (body) {
            if (body.message) {
              (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, 'expo', body.message);
            } else {
              (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, 'expo', response.data);
            }
          }
        }
        throw new (_XDLError || _load_XDLError()).default(errorCode, `Packager URL ${fullUrl} returned unexpected code ${response.status}. ` + 'Please open your project in the Expo app and see if there are any errors. ' + 'Also scroll up and make sure there were no errors or warnings when opening your project.');
      } else {
        throw error;
      }
    }

    if (!response.data || minLength && response.data.length < minLength) {
      throw new (_XDLError || _load_XDLError()).default(errorCode, `Body is: ${response.data}`);
    }

    return response.data;
  });

  return function _getForPlatformAsync(_x5, _x6, _x7, _x8) {
    return _ref5.apply(this, arguments);
  };
})();

let _resolveGoogleServicesFile = (() => {
  var _ref6 = _asyncToGenerator(function* (projectRoot, manifest) {
    if (manifest.android && manifest.android.googleServicesFile) {
      const contents = yield (_fsExtra || _load_fsExtra()).default.readFile(_path.default.resolve(projectRoot, manifest.android.googleServicesFile), 'utf8');
      manifest.android.googleServicesFile = contents;
    }
  });

  return function _resolveGoogleServicesFile(_x9, _x10) {
    return _ref6.apply(this, arguments);
  };
})();

let _resolveManifestAssets = (() => {
  var _ref7 = _asyncToGenerator(function* (projectRoot, manifest, resolver, strict = false) {
    try {
      // Asset fields that the user has set
      const assetSchemas = (yield (_ExpSchema || _load_ExpSchema()).getAssetSchemasAsync(manifest.sdkVersion)).filter(function ({ fieldPath }) {
        return (0, (_get || _load_get()).default)(manifest, fieldPath);
      });

      // Get the URLs
      const urls = yield Promise.all(assetSchemas.map((() => {
        var _ref8 = _asyncToGenerator(function* ({ fieldPath }) {
          const pathOrURL = (0, (_get || _load_get()).default)(manifest, fieldPath);
          if (pathOrURL.match(/^https?:\/\/(.*)$/)) {
            // It's a remote URL
            return pathOrURL;
          } else if ((_fsExtra || _load_fsExtra()).default.existsSync(_path.default.resolve(projectRoot, pathOrURL))) {
            return yield resolver(pathOrURL);
          } else {
            const err = new Error('Could not resolve local asset.');
            // $FlowFixMe
            err.localAssetPath = pathOrURL;
            // $FlowFixMe
            err.manifestField = fieldPath;
            throw err;
          }
        });

        return function (_x14) {
          return _ref8.apply(this, arguments);
        };
      })()));

      // Set the corresponding URL fields
      assetSchemas.forEach(function ({ fieldPath }, index) {
        return (0, (_set || _load_set()).default)(manifest, fieldPath + 'Url', urls[index]);
      });
    } catch (e) {
      let logMethod = (_ProjectUtils || _load_ProjectUtils()).logWarning;
      if (strict) {
        logMethod = (_ProjectUtils || _load_ProjectUtils()).logError;
      }
      if (e.localAssetPath) {
        logMethod(projectRoot, 'expo', `Unable to resolve asset "${e.localAssetPath}" from "${e.manifestField}" in your app/exp.json.`);
      } else {
        logMethod(projectRoot, 'expo', `Warning: Unable to resolve manifest assets. Icons might not work. ${e.message}.`);
      }

      if (strict) {
        throw new Error('Resolving assets failed.');
      }
    }
  });

  return function _resolveManifestAssets(_x11, _x12, _x13) {
    return _ref7.apply(this, arguments);
  };
})();

let getSlugAsync = exports.getSlugAsync = (() => {
  var _ref9 = _asyncToGenerator(function* (projectRoot, options = {}) {
    // Verify that exp/app.json exist
    let { exp, pkg } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectRoot);
    if (!exp || !pkg) {
      const configName = yield (_ProjectUtils || _load_ProjectUtils()).configFilenameAsync(projectRoot);
      throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.NO_PACKAGE_JSON, `Couldn't read ${configName} file in project at ${projectRoot}`);
    }

    if (!exp.slug && pkg.name) {
      exp.slug = pkg.name;
    } else if (!exp.slug) {
      const configName = yield (_ProjectUtils || _load_ProjectUtils()).configFilenameAsync(projectRoot);
      throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.INVALID_MANIFEST, `${configName} in ${projectRoot} must contain the slug field`);
    }
    return exp.slug;
  });

  return function getSlugAsync(_x15) {
    return _ref9.apply(this, arguments);
  };
})();

let getLatestReleaseAsync = exports.getLatestReleaseAsync = (() => {
  var _ref10 = _asyncToGenerator(function* (projectRoot, options) {
    // TODO(ville): move request from multipart/form-data to JSON once supported by the endpoint.
    let formData = new (_FormData || _load_FormData()).default();
    formData.append('queryType', 'history');
    formData.append('slug', (yield getSlugAsync(projectRoot)));
    formData.append('version', '2');
    formData.append('count', '1');
    formData.append('releaseChannel', options.releaseChannel);
    formData.append('platform', options.platform);
    const { queryResult } = yield (_Api || _load_Api()).default.callMethodAsync('publishInfo', [], 'post', null, {
      formData
    });
    if (queryResult && queryResult.length > 0) {
      return queryResult[0];
    } else {
      return null;
    }
  });

  return function getLatestReleaseAsync(_x16, _x17) {
    return _ref10.apply(this, arguments);
  };
})();

// Takes multiple exported apps in sourceDirs and coalesces them to one app in outputDir


let mergeAppDistributions = exports.mergeAppDistributions = (() => {
  var _ref11 = _asyncToGenerator(function* (projectRoot, sourceDirs, outputDir) {
    const assetPathToWrite = _path.default.resolve(projectRoot, outputDir, 'assets');
    yield (_fsExtra || _load_fsExtra()).default.ensureDir(assetPathToWrite);
    const bundlesPathToWrite = _path.default.resolve(projectRoot, outputDir, 'bundles');
    yield (_fsExtra || _load_fsExtra()).default.ensureDir(bundlesPathToWrite);

    // merge files from bundles and assets
    const androidIndexes = [];
    const iosIndexes = [];

    for (let sourceDir of sourceDirs) {
      const promises = [];

      // copy over assets/bundles from other src dirs to the output dir
      if (sourceDir !== outputDir) {
        // copy file over to assetPath
        const sourceAssetDir = _path.default.resolve(projectRoot, sourceDir, 'assets');
        const outputAssetDir = _path.default.resolve(projectRoot, outputDir, 'assets');
        const assetPromise = (_fsExtra || _load_fsExtra()).default.copy(sourceAssetDir, outputAssetDir);
        promises.push(assetPromise);

        // copy files over to bundlePath
        const sourceBundleDir = _path.default.resolve(projectRoot, sourceDir, 'bundles');
        const outputBundleDir = _path.default.resolve(projectRoot, outputDir, 'bundles');
        const bundlePromise = (_fsExtra || _load_fsExtra()).default.copy(sourceBundleDir, outputBundleDir);
        promises.push(bundlePromise);

        yield Promise.all(promises);
      }

      // put index.jsons into memory
      const putJsonInMemory = (() => {
        var _ref12 = _asyncToGenerator(function* (indexPath, accumulator) {
          const index = yield (_jsonFile || _load_jsonFile()).default.readAsync(indexPath);
          if (!index.sdkVersion) {
            throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.INVALID_MANIFEST, `Invalid index.json, must specify an sdkVersion at ${indexPath}`);
          }
          if (Array.isArray(index)) {
            // index.json could also be an array
            accumulator.push(...index);
          } else {
            accumulator.push(index);
          }
        });

        return function putJsonInMemory(_x21, _x22) {
          return _ref12.apply(this, arguments);
        };
      })();

      const androidIndexPath = _path.default.resolve(projectRoot, sourceDir, 'android-index.json');
      yield putJsonInMemory(androidIndexPath, androidIndexes);

      const iosIndexPath = _path.default.resolve(projectRoot, sourceDir, 'ios-index.json');
      yield putJsonInMemory(iosIndexPath, iosIndexes);
    }

    // sort indexes by descending sdk value
    const getSortedIndex = function (indexes) {
      return indexes.sort(function (index1, index2) {
        if ((_semver || _load_semver()).default.eq(index1.sdkVersion, index2.sdkVersion)) {
          (_Logger || _load_Logger()).default.global.error(`Encountered multiple index.json with the same SDK version ${index1.sdkVersion}. This could result in undefined behavior.`);
        }
        return (_semver || _load_semver()).default.gte(index1.sdkVersion, index2.sdkVersion) ? -1 : 1;
      });
    };

    const sortedAndroidIndexes = getSortedIndex(androidIndexes);
    const sortedIosIndexes = getSortedIndex(iosIndexes);

    // Save the json arrays to disk
    yield _writeArtifactSafelyAsync(projectRoot, null, _path.default.join(outputDir, 'android-index.json'), JSON.stringify(sortedAndroidIndexes));

    yield _writeArtifactSafelyAsync(projectRoot, null, _path.default.join(outputDir, 'ios-index.json'), JSON.stringify(sortedIosIndexes));
  });

  return function mergeAppDistributions(_x18, _x19, _x20) {
    return _ref11.apply(this, arguments);
  };
})();

/**
 * Apps exporting for self hosting will have the files created in the project directory the following way:
.
├── android-index.json
├── ios-index.json
├── assets
│   └── 1eccbc4c41d49fd81840aef3eaabe862
└── bundles
      ├── android-01ee6e3ab3e8c16a4d926c91808d5320.js
      └── ios-ee8206cc754d3f7aa9123b7f909d94ea.js
 */


let exportForAppHosting = exports.exportForAppHosting = (() => {
  var _ref13 = _asyncToGenerator(function* (projectRoot, publicUrl, assetUrl, outputDir, options = {}) {
    yield _validatePackagerReadyAsync(projectRoot);

    // make output dirs if not exists
    const assetPathToWrite = _path.default.resolve(projectRoot, _path.default.join(outputDir, 'assets'));
    yield (_fsExtra || _load_fsExtra()).default.ensureDir(assetPathToWrite);
    const bundlesPathToWrite = _path.default.resolve(projectRoot, _path.default.join(outputDir, 'bundles'));
    yield (_fsExtra || _load_fsExtra()).default.ensureDir(bundlesPathToWrite);

    // build the bundles
    let packagerOpts = {};
    if (options.isDev) {
      packagerOpts = { dev: true, minify: true };
    }
    const { iosBundle, androidBundle } = yield _buildPublishBundlesAsync(projectRoot, packagerOpts);
    const iosBundleHash = _crypto.default.createHash('md5').update(iosBundle).digest('hex');
    const iosBundleUrl = `ios-${iosBundleHash}.js`;
    const iosJsPath = _path.default.join(outputDir, 'bundles', iosBundleUrl);

    const androidBundleHash = _crypto.default.createHash('md5').update(androidBundle).digest('hex');
    const androidBundleUrl = `android-${androidBundleHash}.js`;
    const androidJsPath = _path.default.join(outputDir, 'bundles', androidBundleUrl);

    yield _writeArtifactSafelyAsync(projectRoot, null, iosJsPath, iosBundle);
    yield _writeArtifactSafelyAsync(projectRoot, null, androidJsPath, androidBundle);
    (_Logger || _load_Logger()).default.global.info('Finished saving JS Bundles.');

    // save the assets
    // Get project config
    const publishOptions = options.publishOptions || {};
    const exp = yield _getPublishExpConfigAsync(projectRoot, publishOptions);
    const { assets } = yield _fetchAndSaveAssetsAsync(projectRoot, exp, publicUrl, outputDir);

    if (options.dumpAssetmap) {
      (_Logger || _load_Logger()).default.global.info('Dumping asset map.');
      const assetmap = {};
      assets.forEach(function (asset) {
        assetmap[asset.hash] = asset;
      });
      yield _writeArtifactSafelyAsync(projectRoot, null, _path.default.join(outputDir, 'assetmap.json'), JSON.stringify(assetmap));
    }

    // Delete keys that are normally deleted in the publish process
    delete exp.hooks;

    // Add assetUrl to manifest
    exp.assetUrlOverride = assetUrl;

    exp.publishedTime = new Date().toISOString();
    exp.commitTime = new Date().toISOString();

    // generate revisionId and id the same way www does
    const hashIds = new (_hashids || _load_hashids()).default((_uuid || _load_uuid()).default.v1(), 10);
    exp.revisionId = hashIds.encode(Date.now());

    if (options.isDev) {
      exp.developer = {
        tool: 'exp'
      };
    }

    if (!exp.slug) {
      throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.INVALID_MANIFEST, 'Must provide a slug field in the app.json manifest.');
    }
    let username = yield (_User || _load_User()).default.getCurrentUsernameAsync();
    if (!username) {
      username = (_User2 || _load_User2()).ANONYMOUS_USERNAME;
    }
    exp.id = `@${username}/${exp.slug}`;

    // save the android manifest
    exp.bundleUrl = (0, (_urlJoin || _load_urlJoin()).default)(publicUrl, 'bundles', androidBundleUrl);
    exp.platform = 'android';
    yield _writeArtifactSafelyAsync(projectRoot, null, _path.default.join(outputDir, 'android-index.json'), JSON.stringify(exp));

    // save the ios manifest
    exp.bundleUrl = (0, (_urlJoin || _load_urlJoin()).default)(publicUrl, 'bundles', iosBundleUrl);
    exp.platform = 'ios';
    yield _writeArtifactSafelyAsync(projectRoot, null, _path.default.join(outputDir, 'ios-index.json'), JSON.stringify(exp));

    // build source maps
    if (options.dumpSourcemap) {
      const { iosSourceMap, androidSourceMap } = yield _maybeBuildSourceMapsAsync(projectRoot, exp, {
        force: true
      });
      // write the sourcemap files
      const iosMapName = `ios-${iosBundleHash}.map`;
      const iosMapPath = _path.default.join(outputDir, 'bundles', iosMapName);
      yield _writeArtifactSafelyAsync(projectRoot, null, iosMapPath, iosSourceMap);

      const androidMapName = `android-${androidBundleHash}.map`;
      const androidMapPath = _path.default.join(outputDir, 'bundles', androidMapName);
      yield _writeArtifactSafelyAsync(projectRoot, null, androidMapPath, androidSourceMap);

      // Remove original mapping to incorrect sourcemap paths
      (_Logger || _load_Logger()).default.global.info('Configuring sourcemaps');
      yield truncateLastNLines(iosJsPath, 1);
      yield truncateLastNLines(androidJsPath, 1);

      // Add correct mapping to sourcemap paths
      yield (_fsExtra || _load_fsExtra()).default.appendFile(iosJsPath, `\n//# sourceMappingURL=${iosMapName}`);
      yield (_fsExtra || _load_fsExtra()).default.appendFile(androidJsPath, `\n//# sourceMappingURL=${androidMapName}`);

      // Make a debug html so user can debug their bundles
      (_Logger || _load_Logger()).default.global.info('Preparing additional debugging files');
      const debugHtml = `
    <script src="${(0, (_urlJoin || _load_urlJoin()).default)('bundles', iosBundleUrl)}"></script>
    <script src="${(0, (_urlJoin || _load_urlJoin()).default)('bundles', androidBundleUrl)}"></script>
    Open up this file in Chrome. In the Javascript developer console, navigate to the Source tab.
    You can see a red coloured folder containing the original source code from your bundle.
    `;
      yield _writeArtifactSafelyAsync(projectRoot, null, _path.default.join(outputDir, 'debug.html'), debugHtml);
    }
  });

  return function exportForAppHosting(_x23, _x24, _x25, _x26) {
    return _ref13.apply(this, arguments);
  };
})();

// truncate the last n lines in a file


let truncateLastNLines = (() => {
  var _ref14 = _asyncToGenerator(function* (filePath, n) {
    const lines = yield (_readLastLines || _load_readLastLines()).default.read(filePath, n);
    const to_vanquish = lines.length;
    const { size } = yield (_fsExtra || _load_fsExtra()).default.stat(filePath);
    yield (_fsExtra || _load_fsExtra()).default.truncate(filePath, size - to_vanquish);
  });

  return function truncateLastNLines(_x27, _x28) {
    return _ref14.apply(this, arguments);
  };
})();

let _saveAssetAsync = (() => {
  var _ref15 = _asyncToGenerator(function* (projectRoot, assets, outputDir) {
    // Collect paths by key, also effectively handles duplicates in the array
    const paths = {};
    assets.forEach(function (asset) {
      asset.files.forEach(function (path, index) {
        paths[asset.fileHashes[index]] = path;
      });
    });

    // save files one chunk at a time
    const keyChunks = (0, (_chunk || _load_chunk()).default)(Object.keys(paths), 5);
    for (const keys of keyChunks) {
      const promises = [];
      for (const key of keys) {
        (_ProjectUtils || _load_ProjectUtils()).logDebug(projectRoot, 'expo', `uploading ${paths[key]}`);

        (_Logger || _load_Logger()).default.global.info({ quiet: true }, `Saving ${paths[key]}`);

        let assetPath = _path.default.resolve(outputDir, 'assets', key);

        // copy file over to assetPath
        const p = (_fsExtra || _load_fsExtra()).default.copy(paths[key], assetPath);
        promises.push(p);
      }
      yield Promise.all(promises);
    }
    (_Logger || _load_Logger()).default.global.info('Files successfully saved.');
  });

  return function _saveAssetAsync(_x29, _x30, _x31) {
    return _ref15.apply(this, arguments);
  };
})();

let publishAsync = exports.publishAsync = (() => {
  var _ref16 = _asyncToGenerator(function* (projectRoot, options = {}) {
    const user = yield (_User || _load_User()).default.ensureLoggedInAsync();
    yield _validatePackagerReadyAsync(projectRoot);
    (_Analytics || _load_Analytics()).logEvent('Publish', {
      projectRoot,
      developerTool: (_Config || _load_Config()).default.developerTool
    });

    const validationStatus = yield (_Doctor || _load_Doctor()).validateWithNetworkAsync(projectRoot);
    if (validationStatus == (_Doctor || _load_Doctor()).ERROR || validationStatus === (_Doctor || _load_Doctor()).FATAL) {
      throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.PUBLISH_VALIDATION_ERROR, "Couldn't publish because errors were found. (See logs above.) Please fix the errors and try again.");
    }

    // Get project config
    let exp = yield _getPublishExpConfigAsync(projectRoot, options);

    // TODO: refactor this out to a function, throw error if length doesn't match
    let { hooks } = exp;
    delete exp.hooks;
    let validPostPublishHooks = [];
    if (hooks && hooks.postPublish) {
      hooks.postPublish.forEach(function (hook) {
        let { file, config } = hook;
        let fn = _requireFromProject(file, projectRoot, exp);
        if (typeof fn !== 'function') {
          (_Logger || _load_Logger()).default.global.error(`Unable to load postPublishHook: '${file}'. The module does not export a function.`);
        } else {
          hook._fn = fn;
          validPostPublishHooks.push(hook);
        }
      });

      if (validPostPublishHooks.length !== hooks.postPublish.length) {
        (_Logger || _load_Logger()).default.global.error();

        throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.HOOK_INITIALIZATION_ERROR, 'Please fix your postPublish hook configuration.');
      }
    }

    let { iosBundle, androidBundle } = yield _buildPublishBundlesAsync(projectRoot);

    yield _fetchAndUploadAssetsAsync(projectRoot, exp);

    let { iosSourceMap, androidSourceMap } = yield _maybeBuildSourceMapsAsync(projectRoot, exp, {
      force: validPostPublishHooks.length
    });

    let response;
    try {
      response = yield _uploadArtifactsAsync({
        exp,
        iosBundle,
        androidBundle,
        options
      });
    } catch (e) {
      if (e.serverError === 'SCHEMA_VALIDATION_ERROR') {
        throw new Error(`There was an error validating your project schema. Check for any warnings about the contents of your app/exp.json.`);
      }
      (_Sentry || _load_Sentry()).captureException(e);
      throw e;
    }

    yield _maybeWriteArtifactsToDiskAsync({
      exp,
      projectRoot,
      iosBundle,
      androidBundle,
      iosSourceMap,
      androidSourceMap
    });

    if (validPostPublishHooks.length || exp.ios && exp.ios.publishManifestPath || exp.android && exp.android.publishManifestPath) {
      let [androidManifest, iosManifest] = yield Promise.all([(_ExponentTools || _load_ExponentTools()).getManifestAsync(response.url, {
        'Exponent-SDK-Version': exp.sdkVersion,
        'Exponent-Platform': 'android',
        'Expo-Release-Channel': options.releaseChannel,
        Accept: 'application/expo+json,application/json'
      }), (_ExponentTools || _load_ExponentTools()).getManifestAsync(response.url, {
        'Exponent-SDK-Version': exp.sdkVersion,
        'Exponent-Platform': 'ios',
        'Expo-Release-Channel': options.releaseChannel,
        Accept: 'application/expo+json,application/json'
      })]);

      const hookOptions = {
        url: response.url,
        exp,
        iosBundle,
        iosSourceMap,
        iosManifest,
        androidBundle,
        androidSourceMap,
        androidManifest,
        projectRoot,
        log: function (msg) {
          (_Logger || _load_Logger()).default.global.info({ quiet: true }, msg);
        }
      };

      for (let hook of validPostPublishHooks) {
        (_Logger || _load_Logger()).default.global.info(`Running postPublish hook: ${hook.file}`);
        try {
          let result = hook._fn(_extends({
            config: hook.config
          }, hookOptions));

          // If it's a promise, wait for it to resolve
          if (result && result.then) {
            result = yield result;
          }

          if (result) {
            (_Logger || _load_Logger()).default.global.info({ quiet: true }, result);
          }
        } catch (e) {
          (_Logger || _load_Logger()).default.global.warn(`Warning: postPublish hook '${hook.file}' failed: ${e.stack}`);
        }
      }

      if (exp.ios && exp.ios.publishManifestPath) {
        yield _writeArtifactSafelyAsync(projectRoot, 'ios.publishManifestPath', exp.ios.publishManifestPath, JSON.stringify(iosManifest));
        const context = (_StandaloneContext || _load_StandaloneContext()).default.createUserContext(projectRoot, exp);
        const { supportingDirectory } = (_IosWorkspace || _load_IosWorkspace()).getPaths(context);
        yield (_IosPlist || _load_IosPlist()).modifyAsync(supportingDirectory, 'EXShell', function (shellPlist) {
          shellPlist.releaseChannel = options.releaseChannel;
          return shellPlist;
        });
      }

      if (exp.android && exp.android.publishManifestPath) {
        yield _writeArtifactSafelyAsync(projectRoot, 'android.publishManifestPath', exp.android.publishManifestPath, JSON.stringify(androidManifest));
      }

      // We need to add EmbeddedResponse instances on Android to tell the runtime
      // that the shell app manifest and bundle is packaged.
      if (exp.android && exp.android.publishManifestPath && exp.android.publishBundlePath) {
        let fullManifestUrl = response.url.replace('exp://', 'https://');
        let constantsPath = _path.default.join(projectRoot, 'android', 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java');
        yield (_ExponentTools || _load_ExponentTools()).deleteLinesInFileAsync(`START EMBEDDED RESPONSES`, `END EMBEDDED RESPONSES`, constantsPath);
        yield (_ExponentTools || _load_ExponentTools()).regexFileAsync('// ADD EMBEDDED RESPONSES HERE', `
        // ADD EMBEDDED RESPONSES HERE
        // START EMBEDDED RESPONSES
        embeddedResponses.add(new Constants.EmbeddedResponse("${fullManifestUrl}", "assets://shell-app-manifest.json", "application/json"));
        embeddedResponses.add(new Constants.EmbeddedResponse("${androidManifest.bundleUrl}", "assets://shell-app.bundle", "application/javascript"));
        // END EMBEDDED RESPONSES`, constantsPath);
        yield (_ExponentTools || _load_ExponentTools()).regexFileAsync(/RELEASE_CHANNEL = "[^"]*"/, `RELEASE_CHANNEL = "${options.releaseChannel}"`, constantsPath);
      }
    }

    // TODO: move to postPublish hook
    if (exp.isKernel) {
      yield _handleKernelPublishedAsync({
        user,
        exp,
        projectRoot,
        url: response.url
      });
    }

    return _extends({}, response, {
      url: options.releaseChannel && options.releaseChannel !== 'default' ? `${response.url}?release-channel=${options.releaseChannel}` : response.url
    });
  });

  return function publishAsync(_x32) {
    return _ref16.apply(this, arguments);
  };
})();

let _uploadArtifactsAsync = (() => {
  var _ref17 = _asyncToGenerator(function* ({ exp, iosBundle, androidBundle, options }) {
    (_Logger || _load_Logger()).default.global.info('Uploading JavaScript bundles');
    let formData = new (_FormData || _load_FormData()).default();

    formData.append('expJson', JSON.stringify(exp));
    formData.append('iosBundle', _createBlob(iosBundle), 'iosBundle');
    formData.append('androidBundle', _createBlob(androidBundle), 'androidBundle');
    formData.append('options', JSON.stringify(options));
    let response = yield (_Api || _load_Api()).default.callMethodAsync('publish', null, 'put', null, {
      formData
    });
    return response;
  });

  return function _uploadArtifactsAsync(_x33) {
    return _ref17.apply(this, arguments);
  };
})();

let _validatePackagerReadyAsync = (() => {
  var _ref18 = _asyncToGenerator(function* (projectRoot) {
    _assertValidProjectRoot(projectRoot);

    // Ensure the packager is started
    let packagerInfo = yield (_ProjectSettings || _load_ProjectSettings()).readPackagerInfoAsync(projectRoot);
    if (!packagerInfo.packagerPort) {
      (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', 'Metro Bundler is not running. Trying to restart it...');
      yield startReactNativeServerAsync(projectRoot, { reset: true });
    }
  });

  return function _validatePackagerReadyAsync(_x34) {
    return _ref18.apply(this, arguments);
  };
})();

let _getPublishExpConfigAsync = (() => {
  var _ref19 = _asyncToGenerator(function* (projectRoot, options) {
    let schema = (_joi || _load_joi()).default.object().keys({
      releaseChannel: (_joi || _load_joi()).default.string()
    });

    // Validate schema
    const { error } = (_joi || _load_joi()).default.validate(options, schema);
    if (error) {
      throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.INVALID_OPTIONS, error.toString());
    }
    options.releaseChannel = options.releaseChannel || 'default'; // joi default not enforcing this :/

    // Verify that exp/app.json and package.json exist
    let { exp, pkg } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectRoot);
    if (!exp || !pkg) {
      const configName = yield (_ProjectUtils || _load_ProjectUtils()).configFilenameAsync(projectRoot);
      throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.NO_PACKAGE_JSON, `Couldn't read ${configName} file in project at ${projectRoot}`);
    }

    // Support version and name being specified in package.json for legacy
    // support pre: exp.json
    if (!exp.version && pkg.version) {
      exp.version = pkg.version;
    }

    if (!exp.slug && pkg.name) {
      exp.slug = pkg.name;
    }

    if (exp.android && exp.android.config) {
      delete exp.android.config;
    }

    if (exp.ios && exp.ios.config) {
      delete exp.ios.config;
    }

    // Only allow projects to be published with UNVERSIONED if a correct token is set in env
    if (exp.sdkVersion === 'UNVERSIONED' && !process.env['EXPO_SKIP_MANIFEST_VALIDATION_TOKEN']) {
      throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.INVALID_OPTIONS, 'Cannot publish with sdkVersion UNVERSIONED.');
    }
    exp.locales = yield (_ExponentTools || _load_ExponentTools()).getResolvedLocalesAsync(exp);
    return exp;
  });

  return function _getPublishExpConfigAsync(_x35, _x36) {
    return _ref19.apply(this, arguments);
  };
})();

// Fetch iOS and Android bundles for publishing


let _buildPublishBundlesAsync = (() => {
  var _ref20 = _asyncToGenerator(function* (projectRoot, opts) {
    let entryPoint = yield (_Exp || _load_Exp()).determineEntryPointAsync(projectRoot);
    let publishUrl = yield (_UrlUtils || _load_UrlUtils()).constructPublishUrlAsync(projectRoot, entryPoint, null, opts);

    (_Logger || _load_Logger()).default.global.info('Building iOS bundle');
    let iosBundle = yield _getForPlatformAsync(projectRoot, publishUrl, 'ios', {
      errorCode: (_ErrorCode || _load_ErrorCode()).default.INVALID_BUNDLE,
      minLength: MINIMUM_BUNDLE_SIZE
    });

    (_Logger || _load_Logger()).default.global.info('Building Android bundle');
    let androidBundle = yield _getForPlatformAsync(projectRoot, publishUrl, 'android', {
      errorCode: (_ErrorCode || _load_ErrorCode()).default.INVALID_BUNDLE,
      minLength: MINIMUM_BUNDLE_SIZE
    });

    return { iosBundle, androidBundle };
  });

  return function _buildPublishBundlesAsync(_x37, _x38) {
    return _ref20.apply(this, arguments);
  };
})();

// note(brentvatne): currently we build source map anytime there is a
// postPublish hook -- we may have an option in the future to manually
// enable sourcemap building, but for now it's very fast, most apps in
// production should use sourcemaps for error reporting, and in the worst
// case, adding a few seconds to a postPublish hook isn't too annoying


let _maybeBuildSourceMapsAsync = (() => {
  var _ref21 = _asyncToGenerator(function* (projectRoot, exp, options = {}) {
    if (!options.force) {
      return { iosSourceMap: null, androidSourceMap: null };
    }

    let entryPoint = yield (_Exp || _load_Exp()).determineEntryPointAsync(projectRoot);
    let sourceMapUrl = yield (_UrlUtils || _load_UrlUtils()).constructSourceMapUrlAsync(projectRoot, entryPoint);

    (_Logger || _load_Logger()).default.global.info('Building sourcemaps');
    let iosSourceMap = yield _getForPlatformAsync(projectRoot, sourceMapUrl, 'ios', {
      errorCode: (_ErrorCode || _load_ErrorCode()).default.INVALID_BUNDLE,
      minLength: MINIMUM_BUNDLE_SIZE
    });

    let androidSourceMap = yield _getForPlatformAsync(projectRoot, sourceMapUrl, 'android', {
      errorCode: (_ErrorCode || _load_ErrorCode()).default.INVALID_BUNDLE,
      minLength: MINIMUM_BUNDLE_SIZE
    });

    return { iosSourceMap, androidSourceMap };
  });

  return function _maybeBuildSourceMapsAsync(_x39, _x40) {
    return _ref21.apply(this, arguments);
  };
})();

/**
 * Collects all the assets declared in the android app, ios app and manifest
 *
 * @param {string} hostedAssetPrefix
 *    The path where assets are hosted (ie) http://xxx.cloudfront.com/assets/
 *
 * @modifies {exp} Replaces relative asset paths in the manifest with hosted URLS
 *
 */


let _collectAssets = (() => {
  var _ref22 = _asyncToGenerator(function* (projectRoot, exp, hostedAssetPrefix) {
    let entryPoint = yield (_Exp || _load_Exp()).determineEntryPointAsync(projectRoot);
    let assetsUrl = yield (_UrlUtils || _load_UrlUtils()).constructAssetsUrlAsync(projectRoot, entryPoint);

    let iosAssetsJson = yield _getForPlatformAsync(projectRoot, assetsUrl, 'ios', {
      errorCode: (_ErrorCode || _load_ErrorCode()).default.INVALID_ASSETS
    });

    let androidAssetsJson = yield _getForPlatformAsync(projectRoot, assetsUrl, 'android', {
      errorCode: (_ErrorCode || _load_ErrorCode()).default.INVALID_ASSETS
    });

    // Resolve manifest assets to their hosted URL and add them to the list of assets to
    // be uploaded. Modifies exp.
    const manifestAssets = [];
    yield _resolveManifestAssets(projectRoot, exp, (() => {
      var _ref23 = _asyncToGenerator(function* (assetPath) {
        const absolutePath = _path.default.resolve(projectRoot, assetPath);
        const contents = yield (_fsExtra || _load_fsExtra()).default.readFile(absolutePath);
        const hash = (0, (_md5hex || _load_md5hex()).default)(contents);
        manifestAssets.push({ files: [absolutePath], fileHashes: [hash], hash });
        return (0, (_urlJoin || _load_urlJoin()).default)(hostedAssetPrefix, hash);
      });

      return function (_x44) {
        return _ref23.apply(this, arguments);
      };
    })(), true);

    // Upload asset files
    const iosAssets = JSON.parse(iosAssetsJson);
    const androidAssets = JSON.parse(androidAssetsJson);
    return iosAssets.concat(androidAssets).concat(manifestAssets);
  });

  return function _collectAssets(_x41, _x42, _x43) {
    return _ref22.apply(this, arguments);
  };
})();

/**
 * Configures exp, preparing it for asset export
 *
 * @modifies {exp}
 *
 */


let _configureExpForAssets = (() => {
  var _ref24 = _asyncToGenerator(function* (projectRoot, exp, assets) {
    // Add google services file if it exists
    yield _resolveGoogleServicesFile(projectRoot, exp);

    // Convert asset patterns to a list of asset strings that match them.
    // Assets strings are formatted as `asset_<hash>.<type>` and represent
    // the name that the file will have in the app bundle. The `asset_` prefix is
    // needed because android doesn't support assets that start with numbers.
    if (exp.assetBundlePatterns) {
      const fullPatterns = exp.assetBundlePatterns.map(function (p) {
        return _path.default.join(projectRoot, p);
      });
      (_Logger || _load_Logger()).default.global.info('Processing asset bundle patterns:');
      fullPatterns.forEach(function (p) {
        return (_Logger || _load_Logger()).default.global.info('- ' + p);
      });
      // The assets returned by the RN packager has duplicates so make sure we
      // only bundle each once.
      const bundledAssets = new Set();
      for (const asset of assets) {
        const file = asset.files && asset.files[0];
        const shouldBundle = asset.__packager_asset && file && fullPatterns.some(function (p) {
          return (0, (_minimatch || _load_minimatch()).default)(file, p);
        });
        (_ProjectUtils || _load_ProjectUtils()).logDebug(projectRoot, 'expo', `${shouldBundle ? 'Include' : 'Exclude'} asset ${file}`);
        if (shouldBundle) {
          asset.fileHashes.forEach(function (hash) {
            return bundledAssets.add('asset_' + hash + (asset.type ? '.' + asset.type : ''));
          });
        }
      }
      exp.bundledAssets = [...bundledAssets];
      delete exp.assetBundlePatterns;
    }

    return exp;
  });

  return function _configureExpForAssets(_x45, _x46, _x47) {
    return _ref24.apply(this, arguments);
  };
})();

let _fetchAndUploadAssetsAsync = (() => {
  var _ref25 = _asyncToGenerator(function* (projectRoot, exp) {
    (_Logger || _load_Logger()).default.global.info('Analyzing assets');

    const assetCdnPath = (0, (_urlJoin || _load_urlJoin()).default)(EXPO_CDN, '~assets');
    const assets = yield _collectAssets(projectRoot, exp, assetCdnPath);

    (_Logger || _load_Logger()).default.global.info('Uploading assets');

    if (assets.length > 0 && assets[0].fileHashes) {
      yield uploadAssetsAsync(projectRoot, assets);
    } else {
      (_Logger || _load_Logger()).default.global.info({ quiet: true }, 'No assets to upload, skipped.');
    }

    // Updates the manifest to reflect additional asset bundling + configs
    yield _configureExpForAssets(projectRoot, exp, assets);

    return exp;
  });

  return function _fetchAndUploadAssetsAsync(_x48, _x49) {
    return _ref25.apply(this, arguments);
  };
})();

let _fetchAndSaveAssetsAsync = (() => {
  var _ref26 = _asyncToGenerator(function* (projectRoot, exp, hostedUrl, outputDir) {
    (_Logger || _load_Logger()).default.global.info('Analyzing assets');

    const assetCdnPath = (0, (_urlJoin || _load_urlJoin()).default)(hostedUrl, 'assets');
    const assets = yield _collectAssets(projectRoot, exp, assetCdnPath);

    (_Logger || _load_Logger()).default.global.info('Saving assets');

    if (assets.length > 0 && assets[0].fileHashes) {
      yield _saveAssetAsync(projectRoot, assets, outputDir);
    } else {
      (_Logger || _load_Logger()).default.global.info({ quiet: true }, 'No assets to upload, skipped.');
    }

    // Updates the manifest to reflect additional asset bundling + configs
    yield _configureExpForAssets(projectRoot, exp, assets);

    return { exp, assets };
  });

  return function _fetchAndSaveAssetsAsync(_x50, _x51, _x52, _x53) {
    return _ref26.apply(this, arguments);
  };
})();

let _writeArtifactSafelyAsync = (() => {
  var _ref27 = _asyncToGenerator(function* (projectRoot, keyName, artifactPath, artifact) {
    const pathToWrite = _path.default.resolve(projectRoot, artifactPath);
    if (!(_fsExtra || _load_fsExtra()).default.existsSync(_path.default.dirname(pathToWrite))) {
      const errorMsg = keyName ? `app.json specifies: ${pathToWrite}, but that directory does not exist.` : `app.json specifies ${keyName}: ${pathToWrite}, but that directory does not exist.`;
      (_Logger || _load_Logger()).default.global.warn(errorMsg);
    } else {
      yield (_fsExtra || _load_fsExtra()).default.writeFile(pathToWrite, artifact);
    }
  });

  return function _writeArtifactSafelyAsync(_x54, _x55, _x56, _x57) {
    return _ref27.apply(this, arguments);
  };
})();

let _maybeWriteArtifactsToDiskAsync = (() => {
  var _ref28 = _asyncToGenerator(function* ({
    exp,
    projectRoot,
    iosBundle,
    androidBundle,
    iosSourceMap,
    androidSourceMap
  }) {
    if (exp.android && exp.android.publishBundlePath) {
      yield _writeArtifactSafelyAsync(projectRoot, 'android.publishBundlePath', exp.android.publishBundlePath, androidBundle);
    }

    if (exp.ios && exp.ios.publishBundlePath) {
      yield _writeArtifactSafelyAsync(projectRoot, 'ios.publishBundlePath', exp.ios.publishBundlePath, iosBundle);
    }

    if (exp.android && exp.android.publishSourceMapPath) {
      yield _writeArtifactSafelyAsync(projectRoot, 'android.publishSourceMapPath', exp.android.publishSourceMapPath, androidSourceMap);
    }

    if (exp.ios && exp.ios.publishSourceMapPath) {
      yield _writeArtifactSafelyAsync(projectRoot, 'ios.publishSourceMapPath', exp.ios.publishSourceMapPath, iosSourceMap);
    }
  });

  return function _maybeWriteArtifactsToDiskAsync(_x58) {
    return _ref28.apply(this, arguments);
  };
})();

let _handleKernelPublishedAsync = (() => {
  var _ref29 = _asyncToGenerator(function* ({ projectRoot, user, exp, url }) {
    let kernelBundleUrl = `${(_Config || _load_Config()).default.api.scheme}://${(_Config || _load_Config()).default.api.host}`;
    if ((_Config || _load_Config()).default.api.port) {
      kernelBundleUrl = `${kernelBundleUrl}:${(_Config || _load_Config()).default.api.port}`;
    }
    kernelBundleUrl = `${kernelBundleUrl}/@${user.username}/${exp.slug}/bundle`;

    if (exp.kernel.androidManifestPath) {
      let manifest = yield (_ExponentTools || _load_ExponentTools()).getManifestAsync(url, {
        'Exponent-SDK-Version': exp.sdkVersion,
        'Exponent-Platform': 'android',
        Accept: 'application/expo+json,application/json'
      });
      manifest.bundleUrl = kernelBundleUrl;
      manifest.sdkVersion = 'UNVERSIONED';
      yield (_fsExtra || _load_fsExtra()).default.writeFile(_path.default.resolve(projectRoot, exp.kernel.androidManifestPath), JSON.stringify(manifest));
    }

    if (exp.kernel.iosManifestPath) {
      let manifest = yield (_ExponentTools || _load_ExponentTools()).getManifestAsync(url, {
        'Exponent-SDK-Version': exp.sdkVersion,
        'Exponent-Platform': 'ios',
        Accept: 'application/expo+json,application/json'
      });
      manifest.bundleUrl = kernelBundleUrl;
      manifest.sdkVersion = 'UNVERSIONED';
      yield (_fsExtra || _load_fsExtra()).default.writeFile(_path.default.resolve(projectRoot, exp.kernel.iosManifestPath), JSON.stringify(manifest));
    }
  });

  return function _handleKernelPublishedAsync(_x59) {
    return _ref29.apply(this, arguments);
  };
})();

// TODO(jesse): Add analytics for upload


let uploadAssetsAsync = (() => {
  var _ref30 = _asyncToGenerator(function* (projectRoot, assets) {
    // Collect paths by key, also effectively handles duplicates in the array
    const paths = {};
    assets.forEach(function (asset) {
      asset.files.forEach(function (path, index) {
        paths[asset.fileHashes[index]] = path;
      });
    });

    // Collect list of assets missing on host
    const metas = (yield (_Api || _load_Api()).default.callMethodAsync('assetsMetadata', [], 'post', {
      keys: Object.keys(paths)
    })).metadata;
    const missing = Object.keys(paths).filter(function (key) {
      return !metas[key].exists;
    });

    if (missing.length === 0) {
      (_Logger || _load_Logger()).default.global.info({ quiet: true }, `No assets changed, skipped.`);
    }

    // Upload them!
    yield Promise.all((0, (_chunk || _load_chunk()).default)(missing, 5).map((() => {
      var _ref31 = _asyncToGenerator(function* (keys) {
        let formData = new (_FormData || _load_FormData()).default();
        for (const key of keys) {
          (_ProjectUtils || _load_ProjectUtils()).logDebug(projectRoot, 'expo', `uploading ${paths[key]}`);

          let relativePath = paths[key].replace(projectRoot, '');
          (_Logger || _load_Logger()).default.global.info({ quiet: true }, `Uploading ${relativePath}`);

          formData.append(key, (yield _readFileForUpload(paths[key])), paths[key]);
        }
        yield (_Api || _load_Api()).default.callMethodAsync('uploadAssets', [], 'put', null, { formData });
      });

      return function (_x62) {
        return _ref31.apply(this, arguments);
      };
    })()));
  });

  return function uploadAssetsAsync(_x60, _x61) {
    return _ref30.apply(this, arguments);
  };
})();

let _readFileForUpload = (() => {
  var _ref32 = _asyncToGenerator(function* (path) {
    if ((0, (_EnvironmentHelper || _load_EnvironmentHelper()).isNode)()) {
      return (_fsExtra || _load_fsExtra()).default.createReadStream(path);
    } else {
      const data = yield (_fsExtra || _load_fsExtra()).default.readFile(path);
      return new Blob([data]);
    }
  });

  return function _readFileForUpload(_x63) {
    return _ref32.apply(this, arguments);
  };
})();

let getConfigAsync = (() => {
  var _ref33 = _asyncToGenerator(function* (projectRoot, options = {}) {
    if (!options.publicUrl) {
      // get the manifest from the project directory
      const { exp, pkg } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectRoot);
      const configName = yield (_ProjectUtils || _load_ProjectUtils()).configFilenameAsync(projectRoot);
      return {
        exp,
        pkg,
        configName: yield (_ProjectUtils || _load_ProjectUtils()).configFilenameAsync(projectRoot),
        configPrefix: configName === 'app.json' ? 'expo.' : ''
      };
    } else {
      // get the externally hosted manifest
      return {
        exp: yield (_ThirdParty || _load_ThirdParty()).getManifest(options.publicUrl, options),
        configName: options.publicUrl,
        configPrefix: '',
        pkg: {}
      };
    }
  });

  return function getConfigAsync(_x64) {
    return _ref33.apply(this, arguments);
  };
})();

let buildAsync = exports.buildAsync = (() => {
  var _ref34 = _asyncToGenerator(function* (projectRoot, options = {}) {
    yield (_User || _load_User()).default.ensureLoggedInAsync();
    _assertValidProjectRoot(projectRoot);

    (_Analytics || _load_Analytics()).logEvent('Build Shell App', {
      projectRoot,
      developerTool: (_Config || _load_Config()).default.developerTool,
      platform: options.platform
    });

    const schema = (_joi || _load_joi()).default.object().keys({
      current: (_joi || _load_joi()).default.boolean(),
      mode: (_joi || _load_joi()).default.string(),
      platform: (_joi || _load_joi()).default.any().valid('ios', 'android', 'all'),
      expIds: (_joi || _load_joi()).default.array(),
      type: (_joi || _load_joi()).default.any().valid('archive', 'simulator', 'client'),
      releaseChannel: (_joi || _load_joi()).default.string().regex(/[a-z\d][a-z\d._-]*/),
      bundleIdentifier: (_joi || _load_joi()).default.string().regex(/^[a-zA-Z][a-zA-Z0-9\-\.]+$/),
      publicUrl: (_joi || _load_joi()).default.string(),
      sdkVersion: (_joi || _load_joi()).default.strict()
    });

    const { error } = (_joi || _load_joi()).default.validate(options, schema);
    if (error) {
      throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.INVALID_OPTIONS, error.toString());
    }

    const { exp, pkg, configName, configPrefix } = yield getConfigAsync(projectRoot, options);

    if (!exp || !pkg) {
      throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.NO_PACKAGE_JSON, `Couldn't read ${configName} file in project at ${projectRoot}`);
    }

    // Support version and name being specified in package.json for legacy
    // support pre: exp.json
    if (!exp.version && pkg.version) {
      exp.version = pkg.version;
    }
    if (!exp.slug && pkg.name) {
      exp.slug = pkg.name;
    }

    if (options.mode !== 'status' && (options.platform === 'ios' || options.platform === 'all')) {
      if (!exp.ios || !exp.ios.bundleIdentifier) {
        throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.INVALID_MANIFEST, `Must specify a bundle identifier in order to build this experience for iOS. ` + `Please specify one in ${configName} at "${configPrefix}ios.bundleIdentifier"`);
      }
    }

    if (options.mode !== 'status' && (options.platform === 'android' || options.platform === 'all')) {
      if (!exp.android || !exp.android.package) {
        throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.INVALID_MANIFEST, `Must specify a java package in order to build this experience for Android. ` + `Please specify one in ${configName} at "${configPrefix}android.package"`);
      }
    }

    return yield (_Api || _load_Api()).default.callMethodAsync('build', [], 'put', {
      manifest: exp,
      options
    });
  });

  return function buildAsync(_x65) {
    return _ref34.apply(this, arguments);
  };
})();

let _waitForRunningAsync = (() => {
  var _ref35 = _asyncToGenerator(function* (projectRoot, url, retries = 300) {
    try {
      let response = yield (_axios || _load_axios()).default.get(url, {
        responseType: 'text',
        proxy: false
      });
      if (/packager-status:running/.test(response.data)) {
        return true;
      } else if (retries === 0) {
        (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, 'expo', `Could not get status from Metro bundler. Server response: ${response.data}`);
      }
    } catch (e) {
      if (retries === 0) {
        (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, 'expo', `Could not get status from Metro bundler. ${e.message}`);
      }
    }

    if (retries <= 0) {
      throw new Error('Connecting to Metro bundler failed.');
    } else {
      yield (0, (_delayAsync || _load_delayAsync()).default)(100);
      return _waitForRunningAsync(projectRoot, url, retries - 1);
    }
  });

  return function _waitForRunningAsync(_x66, _x67) {
    return _ref35.apply(this, arguments);
  };
})();

let startReactNativeServerAsync = exports.startReactNativeServerAsync = (() => {
  var _ref36 = _asyncToGenerator(function* (projectRoot, options = {}, verbose = true) {
    _assertValidProjectRoot(projectRoot);
    yield stopReactNativeServerAsync(projectRoot);
    yield (_Watchman || _load_Watchman()).addToPathAsync(); // Attempt to fix watchman if it's hanging
    yield (_Watchman || _load_Watchman()).unblockAndGetVersionAsync(projectRoot);

    let { exp } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectRoot);

    let packagerPort = yield _getFreePortAsync(19001); // Create packager options

    let packagerOpts = {
      port: packagerPort,
      customLogReporterPath: (_ProjectUtils || _load_ProjectUtils()).resolveModule('expo/tools/LogReporter', projectRoot, exp),
      assetExts: ['ttf'],
      nonPersistent: !!options.nonPersistent
    };

    if (options.maxWorkers) {
      packagerOpts['max-workers'] = options.maxWorkers;
    }

    if (!(_Versions || _load_Versions()).gteSdkVersion(exp, '16.0.0')) {
      delete packagerOpts.customLogReporterPath;
    }
    const userPackagerOpts = exp.packagerOpts;
    if (userPackagerOpts) {
      // The RN CLI expects rn-cli.config.js's path to be absolute. We use the
      // project root to resolve relative paths since that was the original
      // behavior of the RN CLI.
      if (userPackagerOpts.config) {
        userPackagerOpts.config = _path.default.resolve(projectRoot, userPackagerOpts.config);
      }

      packagerOpts = _extends({}, packagerOpts, userPackagerOpts, userPackagerOpts.assetExts ? {
        assetExts: (0, (_uniq || _load_uniq()).default)([...packagerOpts.assetExts, ...userPackagerOpts.assetExts])
      } : {});

      if (userPackagerOpts.port !== undefined && userPackagerOpts.port !== null) {
        packagerPort = userPackagerOpts.port;
      }
    }
    let cliOpts = (0, (_reduce || _load_reduce()).default)(packagerOpts, function (opts, val, key) {
      // If the packager opt value is boolean, don't set
      // --[opt] [value], just set '--opt'
      if (val && typeof val === 'boolean') {
        opts.push(`--${key}`);
      } else if (val) {
        opts.push(`--${key}`, val);
      }
      return opts;
    }, ['start']);
    if (options.reset) {
      cliOpts.push('--reset-cache');
    } // Get custom CLI path from project package.json, but fall back to node_module path
    let defaultCliPath = (_ProjectUtils || _load_ProjectUtils()).resolveModule('react-native/local-cli/cli.js', projectRoot, exp);
    const cliPath = exp.rnCliPath || defaultCliPath;
    let nodePath;
    // When using a custom path for the RN CLI, we want it to use the project
    // root to look up config files and Node modules
    if (exp.rnCliPath) {
      nodePath = _nodePathForProjectRoot(projectRoot);
    } else {
      nodePath = null;
    }
    // Run the copy of Node that's embedded in Electron by setting the
    // ELECTRON_RUN_AS_NODE environment variable
    // Note: the CLI script sets up graceful-fs and sets ulimit to 4096 in the
    // child process
    let packagerProcess = _child_process.default.fork(cliPath, cliOpts, {
      cwd: projectRoot,
      env: _extends({}, process.env, {
        REACT_NATIVE_APP_ROOT: projectRoot,
        NODE_PATH: nodePath,
        ELECTRON_RUN_AS_NODE: 1
      }),
      silent: true
    });
    yield (_ProjectSettings || _load_ProjectSettings()).setPackagerInfoAsync(projectRoot, {
      packagerPort,
      packagerPid: packagerProcess.pid
    }); // TODO: do we need this? don't know if it's ever called
    process.on('exit', function () {
      (0, (_treeKill || _load_treeKill()).default)(packagerProcess.pid);
    });
    packagerProcess.stdout.setEncoding('utf8');
    packagerProcess.stderr.setEncoding('utf8');
    packagerProcess.stdout.pipe((0, (_split || _load_split()).default)()).on('data', function (data) {
      if (verbose) {
        _logPackagerOutput(projectRoot, 'info', data);
      }
    });
    packagerProcess.stderr.on('data', function (data) {
      if (verbose) {
        _logPackagerOutput(projectRoot, 'error', data);
      }
    });
    let exitPromise = new Promise(function (resolve, reject) {
      packagerProcess.once('exit', (() => {
        var _ref37 = _asyncToGenerator(function* (code) {
          (_ProjectUtils || _load_ProjectUtils()).logDebug(projectRoot, 'expo', `Metro Bundler process exited with code ${code}`);
          if (code) {
            reject(new Error(`Metro Bundler process exited with code ${code}`));
          } else {
            resolve();
          }
          try {
            yield (_ProjectSettings || _load_ProjectSettings()).setPackagerInfoAsync(projectRoot, {
              packagerPort: null,
              packagerPid: null
            });
          } catch (e) {}
        });

        return function (_x69) {
          return _ref37.apply(this, arguments);
        };
      })());
    });
    let packagerUrl = yield (_UrlUtils || _load_UrlUtils()).constructBundleUrlAsync(projectRoot, {
      urlType: 'http',
      hostType: 'localhost'
    });
    yield Promise.race([_waitForRunningAsync(projectRoot, `${packagerUrl}/status`), exitPromise]);
  });

  return function startReactNativeServerAsync(_x68) {
    return _ref36.apply(this, arguments);
  };
})();

// Simulate the node_modules resolution
// If you project dir is /Jesse/Expo/Universe/BubbleBounce, returns
// "/Jesse/node_modules:/Jesse/Expo/node_modules:/Jesse/Expo/Universe/node_modules:/Jesse/Expo/Universe/BubbleBounce/node_modules"


let stopReactNativeServerAsync = exports.stopReactNativeServerAsync = (() => {
  var _ref38 = _asyncToGenerator(function* (projectRoot) {
    _assertValidProjectRoot(projectRoot);
    let packagerInfo = yield (_ProjectSettings || _load_ProjectSettings()).readPackagerInfoAsync(projectRoot);
    if (!packagerInfo.packagerPort || !packagerInfo.packagerPid) {
      (_ProjectUtils || _load_ProjectUtils()).logDebug(projectRoot, 'expo', `No packager found for project at ${projectRoot}.`);
      return;
    }
    (_ProjectUtils || _load_ProjectUtils()).logDebug(projectRoot, 'expo', `Killing packager process tree: ${packagerInfo.packagerPid}`);
    try {
      yield treekillAsync(packagerInfo.packagerPid, 'SIGKILL');
    } catch (e) {
      (_ProjectUtils || _load_ProjectUtils()).logDebug(projectRoot, 'expo', `Error stopping packager process: ${e.toString()}`);
    }
    yield (_ProjectSettings || _load_ProjectSettings()).setPackagerInfoAsync(projectRoot, {
      packagerPort: null,
      packagerPid: null
    });
  });

  return function stopReactNativeServerAsync(_x70) {
    return _ref38.apply(this, arguments);
  };
})();

let startExpoServerAsync = exports.startExpoServerAsync = (() => {
  var _ref39 = _asyncToGenerator(function* (projectRoot) {
    _assertValidProjectRoot(projectRoot);
    yield stopExpoServerAsync(projectRoot);
    let app = (0, (_express || _load_express()).default)();
    app.use((_express || _load_express()).default.json({
      limit: '10mb'
    }));
    app.use((_express || _load_express()).default.urlencoded({
      limit: '10mb',
      extended: true
    }));
    if ((yield (_Doctor || _load_Doctor()).validateWithNetworkAsync(projectRoot)) === (_Doctor || _load_Doctor()).FATAL) {
      throw new Error(`Couldn't start project. Please fix the errors and restart the project.`);
    } // Serve the manifest.
    let manifestHandler = (() => {
      var _ref40 = _asyncToGenerator(function* (req, res) {
        try {
          // We intentionally don't `await`. We want to continue trying even
          // if there is a potential error in the package.json and don't want to slow
          // down the request
          (_Doctor || _load_Doctor()).validateWithNetworkAsync(projectRoot);
          let { exp: manifest } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectRoot);
          if (!manifest) {
            const configName = yield (_ProjectUtils || _load_ProjectUtils()).configFilenameAsync(projectRoot);
            throw new Error(`No ${configName} file found`);
          } // Get packager opts and then copy into bundleUrlPackagerOpts
          let packagerOpts = yield (_ProjectSettings || _load_ProjectSettings()).getPackagerOptsAsync(projectRoot);
          let bundleUrlPackagerOpts = JSON.parse(JSON.stringify(packagerOpts));
          bundleUrlPackagerOpts.urlType = 'http';
          if (bundleUrlPackagerOpts.hostType === 'redirect') {
            bundleUrlPackagerOpts.hostType = 'tunnel';
          }
          manifest.xde = true; // deprecated
          manifest.developer = {
            tool: (_Config || _load_Config()).default.developerTool,
            projectRoot
          };
          manifest.packagerOpts = packagerOpts;
          manifest.env = {};
          for (let key of Object.keys(process.env)) {
            if (shouldExposeEnvironmentVariableInManifest(key)) {
              manifest.env[key] = process.env[key];
            }
          }
          let entryPoint = yield (_Exp || _load_Exp()).determineEntryPointAsync(projectRoot);
          let platform = req.headers['exponent-platform'] || 'ios';
          entryPoint = (_UrlUtils || _load_UrlUtils()).getPlatformSpecificBundleUrl(entryPoint, platform);
          let mainModuleName = (_UrlUtils || _load_UrlUtils()).guessMainModulePath(entryPoint);
          let queryParams = yield (_UrlUtils || _load_UrlUtils()).constructBundleQueryParamsAsync(projectRoot, packagerOpts, req.hostname);
          let path = `/${encodeURI(mainModuleName)}.bundle?platform=${encodeURIComponent(platform)}&${queryParams}`;
          manifest.bundleUrl = (yield (_UrlUtils || _load_UrlUtils()).constructBundleUrlAsync(projectRoot, bundleUrlPackagerOpts, req.hostname)) + path;
          manifest.debuggerHost = yield (_UrlUtils || _load_UrlUtils()).constructDebuggerHostAsync(projectRoot, req.hostname);
          manifest.mainModuleName = mainModuleName;
          manifest.logUrl = yield (_UrlUtils || _load_UrlUtils()).constructLogUrlAsync(projectRoot, req.hostname);
          manifest.hostUri = yield (_UrlUtils || _load_UrlUtils()).constructHostUriAsync(projectRoot, req.hostname);
          yield _resolveManifestAssets(projectRoot, manifest, (() => {
            var _ref41 = _asyncToGenerator(function* (path) {
              return manifest.bundleUrl.match(/^https?:\/\/.*?\//)[0] + 'assets/' + path;
            });

            return function (_x74) {
              return _ref41.apply(this, arguments);
            };
          })()); // the server normally inserts this but if we're offline we'll do it here
          yield _resolveGoogleServicesFile(projectRoot, manifest);
          const hostUUID = yield (_UserSettings || _load_UserSettings()).default.anonymousIdentifier();
          let currentSession = yield (_User || _load_User()).default.getSessionAsync();
          if (!currentSession || (_Config || _load_Config()).default.offline) {
            manifest.id = `@${(_User2 || _load_User2()).ANONYMOUS_USERNAME}/${manifest.slug}-${hostUUID}`;
          }
          let manifestString = JSON.stringify(manifest);
          if (req.headers['exponent-accept-signature']) {
            if (_cachedSignedManifest.manifestString === manifestString) {
              manifestString = _cachedSignedManifest.signedManifest;
            } else {
              if (!currentSession || (_Config || _load_Config()).default.offline) {
                const unsignedManifest = {
                  manifestString,
                  signature: 'UNSIGNED'
                };
                _cachedSignedManifest.manifestString = manifestString;
                manifestString = JSON.stringify(unsignedManifest);
                _cachedSignedManifest.signedManifest = manifestString;
              } else {
                let publishInfo = yield (_Exp || _load_Exp()).getPublishInfoAsync(projectRoot);
                let signedManifest = yield (_Api || _load_Api()).default.callMethodAsync('signManifest', [publishInfo.args], 'post', manifest);
                _cachedSignedManifest.manifestString = manifestString;
                _cachedSignedManifest.signedManifest = signedManifest.response;
                manifestString = signedManifest.response;
              }
            }
          }
          const hostInfo = {
            host: hostUUID,
            server: 'xdl',
            serverVersion: require('../package.json').version,
            serverDriver: (_Config || _load_Config()).default.developerTool,
            serverOS: _os.default.platform(),
            serverOSVersion: _os.default.release()
          };
          res.append('Exponent-Server', JSON.stringify(hostInfo));
          res.send(manifestString);
          (_Analytics || _load_Analytics()).logEvent('Serve Manifest', {
            projectRoot,
            developerTool: (_Config || _load_Config()).default.developerTool
          });
        } catch (e) {
          (_ProjectUtils || _load_ProjectUtils()).logDebug(projectRoot, 'expo', `Error in manifestHandler: ${e} ${e.stack}`);
          // 5xx = Server Error HTTP code
          res.status(520).send({
            error: e.toString()
          });
        }
      });

      return function manifestHandler(_x72, _x73) {
        return _ref40.apply(this, arguments);
      };
    })();
    app.get('/', manifestHandler);
    app.get('/manifest', manifestHandler);
    app.get('/index.exp', manifestHandler);
    app.post('/logs', (() => {
      var _ref42 = _asyncToGenerator(function* (req, res) {
        try {
          let deviceId = req.get('Device-Id');
          let deviceName = req.get('Device-Name');
          if (deviceId && deviceName && req.body) {
            _handleDeviceLogs(projectRoot, deviceId, deviceName, req.body);
          }
        } catch (e) {
          (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, 'expo', `Error getting device logs: ${e} ${e.stack}`);
        }
        res.send('Success');
      });

      return function (_x75, _x76) {
        return _ref42.apply(this, arguments);
      };
    })());
    app.post('/shutdown', (() => {
      var _ref43 = _asyncToGenerator(function* (req, res) {
        server.close();
        res.send('Success');
      });

      return function (_x77, _x78) {
        return _ref43.apply(this, arguments);
      };
    })());
    let expRc = yield (_ProjectUtils || _load_ProjectUtils()).readExpRcAsync(projectRoot);
    let expoServerPort = expRc.manifestPort ? expRc.manifestPort : yield _getFreePortAsync(19000);
    yield (_ProjectSettings || _load_ProjectSettings()).setPackagerInfoAsync(projectRoot, {
      expoServerPort
    });
    let server = app.listen(expoServerPort, function () {
      let host = server.address().address;
      let port = server.address().port;
      (_ProjectUtils || _load_ProjectUtils()).logDebug(projectRoot, 'expo', `Local server listening at http://${host}:${port}`);
    });
    yield (_Exp || _load_Exp()).saveRecentExpRootAsync(projectRoot);
  });

  return function startExpoServerAsync(_x71) {
    return _ref39.apply(this, arguments);
  };
})();

let stopExpoServerAsync = exports.stopExpoServerAsync = (() => {
  var _ref44 = _asyncToGenerator(function* (projectRoot) {
    _assertValidProjectRoot(projectRoot);
    let packagerInfo = yield (_ProjectSettings || _load_ProjectSettings()).readPackagerInfoAsync(projectRoot);
    if (packagerInfo && packagerInfo.expoServerPort) {
      try {
        yield (_axios || _load_axios()).default.post(`http://127.0.0.1:${packagerInfo.expoServerPort}/shutdown`);
      } catch (e) {}
    }
    yield (_ProjectSettings || _load_ProjectSettings()).setPackagerInfoAsync(projectRoot, {
      expoServerPort: null
    });
  });

  return function stopExpoServerAsync(_x79) {
    return _ref44.apply(this, arguments);
  };
})();

let _connectToNgrokAsync = (() => {
  var _ref45 = _asyncToGenerator(function* (projectRoot, args, hostnameAsync, ngrokPid, attempts = 0) {
    try {
      let configPath = _path.default.join((_UserSettings || _load_UserSettings()).default.dotExpoHomeDirectory(), 'ngrok.yml');
      let hostname = yield hostnameAsync();
      let url = yield ngrokConnectAsync(_extends({
        hostname,
        configPath
      }, args));
      return url;
    } catch (e) {
      // Attempt to connect 3 times
      if (attempts >= 2) {
        if (e.message) {
          throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.NGROK_ERROR, e.toString());
        } else {
          throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.NGROK_ERROR, JSON.stringify(e));
        }
      }
      if (!attempts) {
        attempts = 0;
      } // Attempt to fix the issue
      if (e.error_code && e.error_code === 103) {
        if (attempts === 0) {
          // Failed to start tunnel. Might be because url already bound to another session.
          if (ngrokPid) {
            try {
              process.kill(ngrokPid, 'SIGKILL');
            } catch (e) {
              (_ProjectUtils || _load_ProjectUtils()).logDebug(projectRoot, 'expo', `Couldn't kill ngrok with PID ${ngrokPid}`);
            }
          } else {
            yield ngrokKillAsync();
          }
        } else {
          // Change randomness to avoid conflict if killing ngrok didn't help
          yield (_Exp || _load_Exp()).resetProjectRandomnessAsync(projectRoot);
        }
      } // Wait 100ms and then try again
      yield (0, (_delayAsync || _load_delayAsync()).default)(100);
      return _connectToNgrokAsync(projectRoot, args, hostnameAsync, null, attempts + 1);
    }
  });

  return function _connectToNgrokAsync(_x80, _x81, _x82, _x83) {
    return _ref45.apply(this, arguments);
  };
})();

let startTunnelsAsync = exports.startTunnelsAsync = (() => {
  var _ref46 = _asyncToGenerator(function* (projectRoot) {
    let username = yield (_User || _load_User()).default.getCurrentUsernameAsync();
    if (!username) {
      username = (_User2 || _load_User2()).ANONYMOUS_USERNAME;
    }
    _assertValidProjectRoot(projectRoot);
    let packagerInfo = yield (_ProjectSettings || _load_ProjectSettings()).readPackagerInfoAsync(projectRoot);
    if (!packagerInfo.packagerPort) {
      throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.NO_PACKAGER_PORT, `No packager found for project at ${projectRoot}.`);
    }
    if (!packagerInfo.expoServerPort) {
      throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.NO_EXPO_SERVER_PORT, `No Expo server found for project at ${projectRoot}.`);
    }
    yield stopTunnelsAsync(projectRoot);
    if (yield (_Android || _load_Android()).startAdbReverseAsync(projectRoot)) {
      (_ProjectUtils || _load_ProjectUtils()).logInfo(projectRoot, 'expo', 'Successfully ran `adb reverse`. Localhost URLs should work on the connected Android device.');
    }
    let packageShortName = _path.default.parse(projectRoot).base;
    let expRc = yield (_ProjectUtils || _load_ProjectUtils()).readExpRcAsync(projectRoot);

    let startedTunnelsSuccessfully = false;

    // Some issues with ngrok cause it to hang indefinitely. After
    // TUNNEL_TIMEOUTms we just throw an error.
    yield Promise.race([_asyncToGenerator(function* () {
      yield (0, (_delayAsync || _load_delayAsync()).default)(TUNNEL_TIMEOUT);
      if (!startedTunnelsSuccessfully) {
        throw new Error('Starting tunnels timed out');
      }
    })(), _asyncToGenerator(function* () {
      let expoServerNgrokUrl = yield _connectToNgrokAsync(projectRoot, {
        authtoken: (_Config || _load_Config()).default.ngrok.authToken,
        port: packagerInfo.expoServerPort,
        proto: 'http'
      }, _asyncToGenerator(function* () {
        let randomness = expRc.manifestTunnelRandomness ? expRc.manifestTunnelRandomness : yield (_Exp || _load_Exp()).getProjectRandomnessAsync(projectRoot);
        return [randomness, (_UrlUtils || _load_UrlUtils()).domainify(username), (_UrlUtils || _load_UrlUtils()).domainify(packageShortName), (_Config || _load_Config()).default.ngrok.domain].join('.');
      }), packagerInfo.ngrokPid);
      let packagerNgrokUrl = yield _connectToNgrokAsync(projectRoot, {
        authtoken: (_Config || _load_Config()).default.ngrok.authToken,
        port: packagerInfo.packagerPort,
        proto: 'http'
      }, _asyncToGenerator(function* () {
        let randomness = expRc.manifestTunnelRandomness ? expRc.manifestTunnelRandomness : yield (_Exp || _load_Exp()).getProjectRandomnessAsync(projectRoot);
        return ['packager', randomness, (_UrlUtils || _load_UrlUtils()).domainify(username), (_UrlUtils || _load_UrlUtils()).domainify(packageShortName), (_Config || _load_Config()).default.ngrok.domain].join('.');
      }), packagerInfo.ngrokPid);
      yield (_ProjectSettings || _load_ProjectSettings()).setPackagerInfoAsync(projectRoot, {
        expoServerNgrokUrl,
        packagerNgrokUrl,
        ngrokPid: (_ngrok || _load_ngrok()).default.process().pid
      });

      startedTunnelsSuccessfully = true;

      (_ProjectUtils || _load_ProjectUtils()).logWithLevel(projectRoot, 'info', {
        tag: 'expo',
        _expoEventType: 'TUNNEL_READY'
      }, 'Tunnel ready.');

      (_ngrok || _load_ngrok()).default.addListener('statuschange', function (status) {
        if (status === 'reconnecting') {
          (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, 'expo', 'We noticed your tunnel is having issues. ' + 'This may be due to intermittent problems with our tunnel provider. ' + 'If you have trouble connecting to your app, try to Restart the project, ' + 'or switch Host to LAN.');
        } else if (status === 'online') {
          (_ProjectUtils || _load_ProjectUtils()).logInfo(projectRoot, 'expo', 'Tunnel connected.');
        }
      });
    })()]);
  });

  return function startTunnelsAsync(_x84) {
    return _ref46.apply(this, arguments);
  };
})();

let stopTunnelsAsync = exports.stopTunnelsAsync = (() => {
  var _ref51 = _asyncToGenerator(function* (projectRoot) {
    _assertValidProjectRoot(projectRoot);
    // This will kill all ngrok tunnels in the process.
    // We'll need to change this if we ever support more than one project
    // open at a time in XDE.
    let packagerInfo = yield (_ProjectSettings || _load_ProjectSettings()).readPackagerInfoAsync(projectRoot);
    let ngrokProcess = (_ngrok || _load_ngrok()).default.process();
    let ngrokProcessPid = ngrokProcess ? ngrokProcess.pid : null;
    (_ngrok || _load_ngrok()).default.removeAllListeners('statuschange');
    if (packagerInfo.ngrokPid && packagerInfo.ngrokPid !== ngrokProcessPid) {
      // Ngrok is running in some other process. Kill at the os level.
      try {
        process.kill(packagerInfo.ngrokPid);
      } catch (e) {
        (_ProjectUtils || _load_ProjectUtils()).logDebug(projectRoot, 'expo', `Couldn't kill ngrok with PID ${packagerInfo.ngrokPid}`);
      }
    } else {
      // Ngrok is running from the current process. Kill using ngrok api.
      yield ngrokKillAsync();
    }
    yield (_ProjectSettings || _load_ProjectSettings()).setPackagerInfoAsync(projectRoot, {
      expoServerNgrokUrl: null,
      packagerNgrokUrl: null,
      ngrokPid: null
    });
    yield (_Android || _load_Android()).stopAdbReverseAsync(projectRoot);
  });

  return function stopTunnelsAsync(_x85) {
    return _ref51.apply(this, arguments);
  };
})();

let setOptionsAsync = exports.setOptionsAsync = (() => {
  var _ref52 = _asyncToGenerator(function* (projectRoot, options) {
    _assertValidProjectRoot(projectRoot); // Check to make sure all options are valid
    let schema = (_joi || _load_joi()).default.object().keys({
      packagerPort: (_joi || _load_joi()).default.number().integer()
    });
    const { error } = (_joi || _load_joi()).default.validate(options, schema);
    if (error) {
      throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.INVALID_OPTIONS, error.toString());
    }
    yield (_ProjectSettings || _load_ProjectSettings()).setPackagerInfoAsync(projectRoot, options);
  });

  return function setOptionsAsync(_x86, _x87) {
    return _ref52.apply(this, arguments);
  };
})();

let getUrlAsync = exports.getUrlAsync = (() => {
  var _ref53 = _asyncToGenerator(function* (projectRoot, options = {}) {
    _assertValidProjectRoot(projectRoot);
    return yield (_UrlUtils || _load_UrlUtils()).constructManifestUrlAsync(projectRoot, options);
  });

  return function getUrlAsync(_x88) {
    return _ref53.apply(this, arguments);
  };
})();

let startAsync = exports.startAsync = (() => {
  var _ref54 = _asyncToGenerator(function* (projectRoot, options = {}, verbose = true) {
    _assertValidProjectRoot(projectRoot);
    (_Analytics || _load_Analytics()).logEvent('Start Project', {
      projectRoot,
      developerTool: (_Config || _load_Config()).default.developerTool
    });
    yield startExpoServerAsync(projectRoot);
    yield startReactNativeServerAsync(projectRoot, options, verbose);
    if (!(_Config || _load_Config()).default.offline) {
      try {
        yield startTunnelsAsync(projectRoot);
      } catch (e) {
        (_ProjectUtils || _load_ProjectUtils()).logDebug(projectRoot, 'expo', `Error starting tunnel ${e.message}`);
      }
    }
    let { exp } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectRoot);
    (_DevSession || _load_DevSession()).startSession(projectRoot, exp);
    return exp;
  });

  return function startAsync(_x89) {
    return _ref54.apply(this, arguments);
  };
})();

let _stopInternalAsync = (() => {
  var _ref55 = _asyncToGenerator(function* (projectRoot) {
    (_DevSession || _load_DevSession()).stopSession();
    yield stopExpoServerAsync(projectRoot);
    yield stopReactNativeServerAsync(projectRoot);
    if (!(_Config || _load_Config()).default.offline) {
      try {
        yield stopTunnelsAsync(projectRoot);
      } catch (e) {
        (_ProjectUtils || _load_ProjectUtils()).logDebug(projectRoot, 'expo', `Error stopping ngrok ${e.message}`);
      }
    }
  });

  return function _stopInternalAsync(_x90) {
    return _ref55.apply(this, arguments);
  };
})();

let stopAsync = exports.stopAsync = (() => {
  var _ref56 = _asyncToGenerator(function* (projectDir) {
    const result = yield Promise.race([_stopInternalAsync(projectDir), new Promise(function (resolve, reject) {
      return setTimeout(resolve, 2000, 'stopFailed');
    })]);
    if (result === 'stopFailed') {
      // find RN packager and ngrok pids, attempt to kill them manually
      const { packagerPid, ngrokPid } = yield (_ProjectSettings || _load_ProjectSettings()).readPackagerInfoAsync(projectDir);
      if (packagerPid) {
        try {
          process.kill(packagerPid);
        } catch (e) {}
      }
      if (ngrokPid) {
        try {
          process.kill(ngrokPid);
        } catch (e) {}
      }
      yield (_ProjectSettings || _load_ProjectSettings()).setPackagerInfoAsync(projectDir, {
        expoServerPort: null,
        packagerPort: null,
        packagerPid: null,
        expoServerNgrokUrl: null,
        packagerNgrokUrl: null,
        ngrokPid: null
      });
    }
  });

  return function stopAsync(_x91) {
    return _ref56.apply(this, arguments);
  };
})();

var _axios;

function _load_axios() {
  return _axios = _interopRequireDefault(require('axios'));
}

var _child_process = _interopRequireDefault(require('child_process'));

var _crypto = _interopRequireDefault(require('crypto'));

var _delayAsync;

function _load_delayAsync() {
  return _delayAsync = _interopRequireDefault(require('delay-async'));
}

var _decache;

function _load_decache() {
  return _decache = _interopRequireDefault(require('decache'));
}

var _express;

function _load_express() {
  return _express = _interopRequireDefault(require('express'));
}

var _freeportAsync;

function _load_freeportAsync() {
  return _freeportAsync = _interopRequireDefault(require('freeport-async'));
}

var _fsExtra;

function _load_fsExtra() {
  return _fsExtra = _interopRequireDefault(require('fs-extra'));
}

var _hashids;

function _load_hashids() {
  return _hashids = _interopRequireDefault(require('hashids'));
}

var _joi;

function _load_joi() {
  return _joi = _interopRequireDefault(require('joi'));
}

var _jsonFile;

function _load_jsonFile() {
  return _jsonFile = _interopRequireDefault(require('@expo/json-file'));
}

var _util;

function _load_util() {
  return _util = _interopRequireDefault(require('util.promisify'));
}

var _chunk;

function _load_chunk() {
  return _chunk = _interopRequireDefault(require('lodash/chunk'));
}

var _escapeRegExp;

function _load_escapeRegExp() {
  return _escapeRegExp = _interopRequireDefault(require('lodash/escapeRegExp'));
}

var _get;

function _load_get() {
  return _get = _interopRequireDefault(require('lodash/get'));
}

var _reduce;

function _load_reduce() {
  return _reduce = _interopRequireDefault(require('lodash/reduce'));
}

var _set;

function _load_set() {
  return _set = _interopRequireDefault(require('lodash/set'));
}

var _uniq;

function _load_uniq() {
  return _uniq = _interopRequireDefault(require('lodash/uniq'));
}

var _minimatch;

function _load_minimatch() {
  return _minimatch = _interopRequireDefault(require('minimatch'));
}

var _ngrok;

function _load_ngrok() {
  return _ngrok = _interopRequireDefault(require('@expo/ngrok'));
}

var _os = _interopRequireDefault(require('os'));

var _path = _interopRequireDefault(require('path'));

var _semver;

function _load_semver() {
  return _semver = _interopRequireDefault(require('semver'));
}

var _split;

function _load_split() {
  return _split = _interopRequireDefault(require('split'));
}

var _treeKill;

function _load_treeKill() {
  return _treeKill = _interopRequireDefault(require('tree-kill'));
}

var _md5hex;

function _load_md5hex() {
  return _md5hex = _interopRequireDefault(require('md5hex'));
}

var _url = _interopRequireDefault(require('url'));

var _urlJoin;

function _load_urlJoin() {
  return _urlJoin = _interopRequireDefault(require('url-join'));
}

var _uuid;

function _load_uuid() {
  return _uuid = _interopRequireDefault(require('uuid'));
}

var _readLastLines;

function _load_readLastLines() {
  return _readLastLines = _interopRequireDefault(require('read-last-lines'));
}

var _Analytics;

function _load_Analytics() {
  return _Analytics = _interopRequireWildcard(require('./Analytics'));
}

var _Android;

function _load_Android() {
  return _Android = _interopRequireWildcard(require('./Android'));
}

var _Api;

function _load_Api() {
  return _Api = _interopRequireDefault(require('./Api'));
}

var _Config;

function _load_Config() {
  return _Config = _interopRequireDefault(require('./Config'));
}

var _Doctor;

function _load_Doctor() {
  return _Doctor = _interopRequireWildcard(require('./project/Doctor'));
}

var _DevSession;

function _load_DevSession() {
  return _DevSession = _interopRequireWildcard(require('./DevSession'));
}

var _ErrorCode;

function _load_ErrorCode() {
  return _ErrorCode = _interopRequireDefault(require('./ErrorCode'));
}

var _Logger;

function _load_Logger() {
  return _Logger = _interopRequireDefault(require('./Logger'));
}

var _ExponentTools;

function _load_ExponentTools() {
  return _ExponentTools = _interopRequireWildcard(require('./detach/ExponentTools'));
}

var _Exp;

function _load_Exp() {
  return _Exp = _interopRequireWildcard(require('./Exp'));
}

var _ExpSchema;

function _load_ExpSchema() {
  return _ExpSchema = _interopRequireWildcard(require('./project/ExpSchema'));
}

var _FormData;

function _load_FormData() {
  return _FormData = _interopRequireDefault(require('./tools/FormData'));
}

var _IosPlist;

function _load_IosPlist() {
  return _IosPlist = _interopRequireWildcard(require('./detach/IosPlist'));
}

var _IosWorkspace;

function _load_IosWorkspace() {
  return _IosWorkspace = _interopRequireWildcard(require('./detach/IosWorkspace'));
}

var _EnvironmentHelper;

function _load_EnvironmentHelper() {
  return _EnvironmentHelper = require('./tools/EnvironmentHelper');
}

var _ProjectSettings;

function _load_ProjectSettings() {
  return _ProjectSettings = _interopRequireWildcard(require('./ProjectSettings'));
}

var _ProjectUtils;

function _load_ProjectUtils() {
  return _ProjectUtils = _interopRequireWildcard(require('./project/ProjectUtils'));
}

var _Sentry;

function _load_Sentry() {
  return _Sentry = _interopRequireWildcard(require('./Sentry'));
}

var _StandaloneContext;

function _load_StandaloneContext() {
  return _StandaloneContext = _interopRequireDefault(require('./detach/StandaloneContext'));
}

var _ThirdParty;

function _load_ThirdParty() {
  return _ThirdParty = _interopRequireWildcard(require('./ThirdParty'));
}

var _UrlUtils;

function _load_UrlUtils() {
  return _UrlUtils = _interopRequireWildcard(require('./UrlUtils'));
}

var _User;

function _load_User() {
  return _User = _interopRequireDefault(require('./User'));
}

var _User2;

function _load_User2() {
  return _User2 = require('./User');
}

var _UserSettings;

function _load_UserSettings() {
  return _UserSettings = _interopRequireDefault(require('./UserSettings'));
}

var _Versions;

function _load_Versions() {
  return _Versions = _interopRequireWildcard(require('./Versions'));
}

var _Watchman;

function _load_Watchman() {
  return _Watchman = _interopRequireWildcard(require('./Watchman'));
}

var _XDLError;

function _load_XDLError() {
  return _XDLError = _interopRequireDefault(require('./XDLError'));
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

//eslint-disable-line

const EXPO_CDN = 'https://d1wp6m56sqw74a.cloudfront.net';
const MINIMUM_BUNDLE_SIZE = 500;
const TUNNEL_TIMEOUT = 10 * 1000;

const treekillAsync = (0, (_util || _load_util()).default)((_treeKill || _load_treeKill()).default);
const ngrokConnectAsync = (0, (_util || _load_util()).default)((_ngrok || _load_ngrok()).default.connect);
const ngrokKillAsync = (0, (_util || _load_util()).default)((_ngrok || _load_ngrok()).default.kill);

let _cachedSignedManifest = {
  manifestString: null,
  signedManifest: null
};

function _requireFromProject(modulePath, projectRoot, exp) {
  try {
    let fullPath = (_ProjectUtils || _load_ProjectUtils()).resolveModule(modulePath, projectRoot, exp);
    // Clear the require cache for this module so get a fresh version of it
    // without requiring the user to restart Expo CLI
    (0, (_decache || _load_decache()).default)(fullPath);
    // $FlowIssue: doesn't work with dynamic requires
    return require(fullPath);
  } catch (e) {
    return null;
  }
}

function _createBlob(string) {
  if ((0, (_EnvironmentHelper || _load_EnvironmentHelper()).isNode)()) {
    return string;
  } else {
    return new Blob([string]);
  }
}

function _stripPackagerOutputBox(output) {
  let re = /Running packager on port (\d+)/;
  let found = output.match(re);
  if (found && found.length >= 2) {
    return `Running packager on port ${found[1]}\n`;
  } else {
    return null;
  }
}

function _logPackagerOutput(projectRoot, level, data) {
  let output = data.toString();
  if (!output) {
    return;
  }
  // Temporarily hide warnings about duplicate providesModule declarations
  // under react-native
  if (_isIgnorableDuplicateModuleWarning(projectRoot, level, output)) {
    (_ProjectUtils || _load_ProjectUtils()).logDebug(projectRoot, 'expo', `Suppressing @providesModule warning: ${output}`, 'project-suppress-providesmodule-warning');
    return;
  }
  if (/^Scanning folders for symlinks in /.test(output)) {
    (_ProjectUtils || _load_ProjectUtils()).logDebug(projectRoot, 'metro', output);
    return;
  }
  if (level === 'info') {
    (_ProjectUtils || _load_ProjectUtils()).logInfo(projectRoot, 'metro', output);
  } else {
    (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, 'metro', output);
  }
}

function _isIgnorableDuplicateModuleWarning(projectRoot, level, output) {
  if (level !== 'error' || !output.startsWith('jest-haste-map: @providesModule naming collision:')) {
    return false;
  }

  let reactNativeNodeModulesPath = _path.default.join(projectRoot, 'node_modules', 'react-native', 'node_modules');
  let reactNativeNodeModulesPattern = (0, (_escapeRegExp || _load_escapeRegExp()).default)(reactNativeNodeModulesPath);
  let reactNativeNodeModulesCollisionRegex = new RegExp(`Paths: ${reactNativeNodeModulesPattern}.+ collides with ${reactNativeNodeModulesPattern}.+`);
  return reactNativeNodeModulesCollisionRegex.test(output);
}

function _isIgnorableBugReportingExtraData(body) {
  return body.length === 2 && body[0] === 'BugReporting extraData:';
}

function _handleDeviceLogs(projectRoot, deviceId, deviceName, logs) {
  for (let i = 0; i < logs.length; i++) {
    let log = logs[i];
    let body = typeof log.body === 'string' ? [log.body] : log.body;
    let string = body.map(obj => {
      if (typeof obj === 'undefined') {
        return 'undefined';
      }
      if (obj === 'null') {
        return 'null';
      }
      if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean') {
        return obj;
      }
      try {
        return JSON.stringify(obj);
      } catch (e) {
        return obj.toString();
      }
    }).join(' ');
    let level = log.level;
    if (_isIgnorableBugReportingExtraData(body)) {
      level = (_Logger || _load_Logger()).default.DEBUG;
    }
    let groupDepth = log.groupDepth;
    let shouldHide = log.shouldHide;
    let includesStack = log.includesStack;
    (_ProjectUtils || _load_ProjectUtils()).logWithLevel(projectRoot, level, {
      tag: 'device',
      deviceId,
      deviceName,
      groupDepth,
      shouldHide,
      includesStack
    }, string);
  }
}
function _nodePathForProjectRoot(projectRoot) {
  let paths = [];
  let directory = _path.default.resolve(projectRoot);
  while (true) {
    paths.push(_path.default.join(directory, 'node_modules'));
    let parentDirectory = _path.default.dirname(directory);
    if (directory === parentDirectory) {
      break;
    }
    directory = parentDirectory;
  }
  return paths.join(_path.default.delimiter);
}


let blacklistedEnvironmentVariables = new Set(['EXPO_APPLE_PASSWORD', 'EXPO_ANDROID_KEY_PASSWORD', 'EXPO_ANDROID_KEYSTORE_PASSWORD', 'EXPO_IOS_DIST_P12_PASSWORD', 'EXPO_IOS_PUSH_P12_PASSWORD']);

function shouldExposeEnvironmentVariableInManifest(key) {
  if (blacklistedEnvironmentVariables.has(key.toUpperCase())) {
    return false;
  }
  return key.startsWith('REACT_NATIVE_') || key.startsWith('EXPO_');
}
//# sourceMappingURL=__sourcemaps__/Project.js.map
