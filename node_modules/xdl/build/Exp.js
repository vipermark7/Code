'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clearXDLCacheAsync = exports.resetProjectRandomnessAsync = exports.getProjectRandomnessAsync = exports.sendAsync = exports.recentValidExpsAsync = exports.getPublishInfoAsync = exports.getThirdPartyInfoAsync = exports.expInfoSafeAsync = exports.saveRecentExpRootAsync = exports.extractTemplateApp = exports.determineEntryPointAsync = exports.convertProjectAsync = exports.ENTRY_POINT_PLATFORM_TEMPLATE_STRING = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

let determineEntryPointAsync = exports.determineEntryPointAsync = (() => {
  var _ref = _asyncToGenerator(function* (root) {
    let { exp, pkg } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(root);

    // entryPoint is relative to the packager root and main is relative
    // to the project root. So if your rn-cli.config.js points to a different
    // root than the project root, these can be different. Most of the time
    // you should use main.
    let entryPoint = pkg.main || 'index.js';
    if (exp && exp.entryPoint) {
      entryPoint = exp.entryPoint;
    }

    return entryPoint;
  });

  return function determineEntryPointAsync(_x) {
    return _ref.apply(this, arguments);
  };
})();

let extractTemplateApp = exports.extractTemplateApp = (() => {
  var _ref2 = _asyncToGenerator(function* (templateSpec, name, projectRoot, packageManager = 'npm') {
    (_Logger || _load_Logger()).default.notifications.info({ code: (_NotificationCode || _load_NotificationCode()).default.PROGRESS }, (_MessageCode || _load_MessageCode()).default.EXTRACTING);
    yield (_pacote || _load_pacote()).default.extract(templateSpec, projectRoot, {
      cache: _path.default.join((_UserSettings || _load_UserSettings()).default.dotExpoHomeDirectory(), 'template-cache')
    });

    // Update files
    (_Logger || _load_Logger()).default.notifications.info({ code: (_NotificationCode || _load_NotificationCode()).default.PROGRESS }, (_MessageCode || _load_MessageCode()).default.CUSTOMIZING);

    let appFile = new (_jsonFile || _load_jsonFile()).default(_path.default.join(projectRoot, 'app.json'));
    let appJson = yield appFile.readAsync();
    appJson = _extends({}, appJson, {
      expo: _extends({}, appJson.expo, { name, slug: name })
    });
    yield appFile.writeAsync(appJson);

    let packageFile = new (_jsonFile || _load_jsonFile()).default(_path.default.join(projectRoot, 'package.json'));
    let packageJson = yield packageFile.readAsync();
    // Adding `private` stops npm from complaining about missing `name` and `version` fields.
    // We don't add a `name` field because it also exists in `app.json`.
    packageJson = _extends({}, packageJson, { private: true });
    // These are metadata fields related to the template package, let's remove them from the package.json.
    delete packageJson.name;
    delete packageJson.version;
    delete packageJson.description;
    delete packageJson.tags;
    delete packageJson.repository;
    // pacote adds these, but we don't want them in the package.json of the project.
    delete packageJson._resolved;
    delete packageJson._integrity;
    delete packageJson._from;
    yield packageFile.writeAsync(packageJson);

    // Rename `gitignore` because npm ignores files named `.gitignore` when publishing.
    // See: https://github.com/npm/npm/issues/1862
    try {
      yield (_fsExtra || _load_fsExtra()).default.move(_path.default.join(projectRoot, 'gitignore'), _path.default.join(projectRoot, '.gitignore'));
    } catch (error) {
      // Append, if there's already a `.gitignore` file there
      if (error.code === 'EEXIST') {
        let data = (_fsExtra || _load_fsExtra()).default.readFileSync(_path.default.join(projectRoot, 'gitignore'));
        (_fsExtra || _load_fsExtra()).default.appendFileSync(_path.default.join(projectRoot, '.gitignore'), data);
        (_fsExtra || _load_fsExtra()).default.unlinkSync(_path.default.join(projectRoot, 'gitignore'));
      } else if (error.code === 'ENOENT') {
        // `gitignore` doesn't exist, move on.
      } else {
        throw error;
      }
    }

    yield initGitRepo(projectRoot);

    yield installDependencies(projectRoot, packageManager);

    return projectRoot;
  });

  return function extractTemplateApp(_x2, _x3, _x4) {
    return _ref2.apply(this, arguments);
  };
})();

let initGitRepo = (() => {
  var _ref3 = _asyncToGenerator(function* (root) {
    if (process.platform === 'darwin' && !(_Binaries || _load_Binaries()).isXcodeInstalled()) {
      (_Logger || _load_Logger()).default.global.warn(`Unable to initialize git repo. \`git\` not installed.`);
      return;
    }

    // let's see if we're in a git tree
    let insideGit = true;
    try {
      yield (0, (_spawnAsync || _load_spawnAsync()).default)('git', ['rev-parse', '--is-inside-work-tree'], {
        cwd: root
      });
      (_Logger || _load_Logger()).default.global.debug('New project is already inside of a git repo, skipping git init.');
    } catch (e) {
      insideGit = false;
    }

    if (!insideGit) {
      try {
        yield (0, (_spawnAsync || _load_spawnAsync()).default)('git', ['init'], { cwd: root });
        (_Logger || _load_Logger()).default.global.info('Initialized a git repository.');
      } catch (e) {
        // no-op -- this is just a convenience and we don't care if it fails
      }
    }
  });

  return function initGitRepo(_x5) {
    return _ref3.apply(this, arguments);
  };
})();

let installDependencies = (() => {
  var _ref4 = _asyncToGenerator(function* (projectRoot, packageManager) {
    (_Logger || _load_Logger()).default.global.info('Installing dependencies...');

    if (packageManager === 'yarn') {
      yield (0, (_spawnAsync || _load_spawnAsync()).default)('yarnpkg', ['install'], {
        cwd: projectRoot,
        stdio: 'inherit'
      });
    } else {
      yield (0, (_spawnAsync || _load_spawnAsync()).default)('npm', ['install'], {
        cwd: projectRoot,
        stdio: 'inherit'
      });
    }
  });

  return function installDependencies(_x6, _x7) {
    return _ref4.apply(this, arguments);
  };
})();

let saveRecentExpRootAsync = exports.saveRecentExpRootAsync = (() => {
  var _ref5 = _asyncToGenerator(function* (root) {
    root = _path.default.resolve(root);

    // Write the recent Exps JSON file
    let recentExpsJsonFile = (_UserSettings || _load_UserSettings()).default.recentExpsJsonFile();
    let recentExps = yield recentExpsJsonFile.readAsync();
    // Filter out copies of this so we don't get dupes in this list
    recentExps = recentExps.filter(function (x) {
      return x !== root;
    });
    recentExps.unshift(root);
    return yield recentExpsJsonFile.writeAsync(recentExps.slice(0, 100));
  });

  return function saveRecentExpRootAsync(_x8) {
    return _ref5.apply(this, arguments);
  };
})();

let expInfoSafeAsync = exports.expInfoSafeAsync = (() => {
  var _ref6 = _asyncToGenerator(function* (root) {
    try {
      let {
        exp: { name, description, icon, iconUrl }
      } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(root);
      let pathOrUrl = icon || iconUrl || 'https://d3lwq5rlu14cro.cloudfront.net/ExponentEmptyManifest_192.png';
      let resolvedPath = _path.default.resolve(root, pathOrUrl);
      if ((_fsExtra || _load_fsExtra()).default.existsSync(resolvedPath)) {
        icon = `file://${resolvedPath}`;
      } else {
        icon = pathOrUrl; // Assume already a URL
      }

      return {
        readableRoot: makePathReadable(root),
        root,
        name,
        description,
        icon
      };
    } catch (e) {
      return null;
    }
  });

  return function expInfoSafeAsync(_x9) {
    return _ref6.apply(this, arguments);
  };
})();

let getThirdPartyInfoAsync = exports.getThirdPartyInfoAsync = (() => {
  var _ref7 = _asyncToGenerator(function* (publicUrl) {
    const user = yield (_User || _load_User()).default.ensureLoggedInAsync();

    if (!user) {
      throw new Error('Attempted to login in offline mode. This is a bug.');
    }

    const { username } = user;

    const exp = yield (_ThirdParty || _load_ThirdParty()).getManifest(publicUrl);
    const { slug, sdkVersion, version } = exp;
    if (!sdkVersion) {
      throw new Error(`sdkVersion is missing from ${publicUrl}`);
    }

    if (!slug) {
      // slug is made programmatically for app.json
      throw new Error(`slug field is missing from exp.json.`);
    }

    if (!version) {
      throw new Error(`Can't get version of package.`);
    }

    const bundleIdentifierIOS = exp.ios ? exp.ios.bundleIdentifier : null;
    return {
      args: {
        username,
        remoteUsername: username,
        remotePackageName: slug,
        remoteFullPackageName: `@${username}/${slug}`,
        bundleIdentifierIOS,
        sdkVersion
      }
    };
  });

  return function getThirdPartyInfoAsync(_x10) {
    return _ref7.apply(this, arguments);
  };
})();

// TODO: remove / change, no longer publishInfo, this is just used for signing


let getPublishInfoAsync = exports.getPublishInfoAsync = (() => {
  var _ref8 = _asyncToGenerator(function* (root) {
    const user = yield (_User || _load_User()).default.ensureLoggedInAsync();

    if (!user) {
      throw new Error('Attempted to login in offline mode. This is a bug.');
    }

    const { username } = user;

    const { exp } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(root);

    const name = exp.slug;
    const { version, sdkVersion } = exp;

    const configName = yield (_ProjectUtils || _load_ProjectUtils()).configFilenameAsync(root);

    if (!sdkVersion) {
      throw new Error(`sdkVersion is missing from ${configName}`);
    }

    if (!name) {
      // slug is made programmatically for app.json
      throw new Error(`slug field is missing from exp.json.`);
    }

    if (!version) {
      throw new Error(`Can't get version of package.`);
    }

    const remotePackageName = name;
    const remoteUsername = username;
    const remoteFullPackageName = `@${remoteUsername}/${remotePackageName}`;
    const bundleIdentifierIOS = exp.ios ? exp.ios.bundleIdentifier : null;

    return {
      args: {
        username,
        remoteUsername,
        remotePackageName,
        remoteFullPackageName,
        bundleIdentifierIOS,
        sdkVersion
      }
    };
  });

  return function getPublishInfoAsync(_x11) {
    return _ref8.apply(this, arguments);
  };
})();

let recentValidExpsAsync = exports.recentValidExpsAsync = (() => {
  var _ref9 = _asyncToGenerator(function* () {
    let recentExpsJsonFile = (_UserSettings || _load_UserSettings()).default.recentExpsJsonFile();
    let recentExps = yield recentExpsJsonFile.readAsync();

    let results = yield Promise.all(recentExps.map(expInfoSafeAsync));
    let filteredResults = results.filter(function (result) {
      return result;
    });
    return filteredResults;
  });

  return function recentValidExpsAsync() {
    return _ref9.apply(this, arguments);
  };
})();

let sendAsync = exports.sendAsync = (() => {
  var _ref10 = _asyncToGenerator(function* (recipient, url_, allowUnauthed = true) {
    let result = yield (_Api || _load_Api()).default.callMethodAsync('send', [recipient, url_, allowUnauthed]);
    return result;
  });

  return function sendAsync(_x12, _x13) {
    return _ref10.apply(this, arguments);
  };
})();

// TODO: figure out where these functions should live


let getProjectRandomnessAsync = exports.getProjectRandomnessAsync = (() => {
  var _ref11 = _asyncToGenerator(function* (projectRoot) {
    let ps = yield (_ProjectSettings || _load_ProjectSettings()).readAsync(projectRoot);
    let randomness = ps.urlRandomness;
    if (randomness) {
      return randomness;
    } else {
      return resetProjectRandomnessAsync(projectRoot);
    }
  });

  return function getProjectRandomnessAsync(_x14) {
    return _ref11.apply(this, arguments);
  };
})();

let resetProjectRandomnessAsync = exports.resetProjectRandomnessAsync = (() => {
  var _ref12 = _asyncToGenerator(function* (projectRoot) {
    let randomness = (_UrlUtils || _load_UrlUtils()).someRandomness();
    (_ProjectSettings || _load_ProjectSettings()).setAsync(projectRoot, { urlRandomness: randomness });
    return randomness;
  });

  return function resetProjectRandomnessAsync(_x15) {
    return _ref12.apply(this, arguments);
  };
})();

let clearXDLCacheAsync = exports.clearXDLCacheAsync = (() => {
  var _ref13 = _asyncToGenerator(function* () {
    let dotExpoHomeDirectory = (_UserSettings || _load_UserSettings()).default.dotExpoHomeDirectory();
    (_rimraf || _load_rimraf()).default.sync(_path.default.join(dotExpoHomeDirectory, 'ios-simulator-app-cache'));
    (_rimraf || _load_rimraf()).default.sync(_path.default.join(dotExpoHomeDirectory, 'android-apk-cache'));
    (_rimraf || _load_rimraf()).default.sync(_path.default.join(dotExpoHomeDirectory, 'starter-app-cache'));
    (_Logger || _load_Logger()).default.notifications.info(`Cleared cache`);
  });

  return function clearXDLCacheAsync() {
    return _ref13.apply(this, arguments);
  };
})();

var _Convert;

function _load_Convert() {
  return _Convert = require('./project/Convert');
}

Object.defineProperty(exports, 'convertProjectAsync', {
  enumerable: true,
  get: function () {
    return _interopRequireDefault(_Convert || _load_Convert()).default;
  }
});

var _fsExtra;

function _load_fsExtra() {
  return _fsExtra = _interopRequireDefault(require('fs-extra'));
}

var _path = _interopRequireDefault(require('path'));

var _spawnAsync;

function _load_spawnAsync() {
  return _spawnAsync = _interopRequireDefault(require('@expo/spawn-async'));
}

var _jsonFile;

function _load_jsonFile() {
  return _jsonFile = _interopRequireDefault(require('@expo/json-file'));
}

var _rimraf;

function _load_rimraf() {
  return _rimraf = _interopRequireDefault(require('rimraf'));
}

var _pacote;

function _load_pacote() {
  return _pacote = _interopRequireDefault(require('pacote'));
}

var _Analytics;

function _load_Analytics() {
  return _Analytics = _interopRequireWildcard(require('./Analytics'));
}

var _Api;

function _load_Api() {
  return _Api = _interopRequireDefault(require('./Api'));
}

var _Binaries;

function _load_Binaries() {
  return _Binaries = _interopRequireWildcard(require('./Binaries'));
}

var _ErrorCode;

function _load_ErrorCode() {
  return _ErrorCode = _interopRequireDefault(require('./ErrorCode'));
}

var _Extract;

function _load_Extract() {
  return _Extract = _interopRequireWildcard(require('./Extract'));
}

var _Logger;

function _load_Logger() {
  return _Logger = _interopRequireDefault(require('./Logger'));
}

var _NotificationCode;

function _load_NotificationCode() {
  return _NotificationCode = _interopRequireDefault(require('./NotificationCode'));
}

var _ProjectUtils;

function _load_ProjectUtils() {
  return _ProjectUtils = _interopRequireWildcard(require('./project/ProjectUtils'));
}

var _ThirdParty;

function _load_ThirdParty() {
  return _ThirdParty = _interopRequireWildcard(require('./ThirdParty'));
}

var _User;

function _load_User() {
  return _User = _interopRequireDefault(require('./User'));
}

var _UrlUtils;

function _load_UrlUtils() {
  return _UrlUtils = _interopRequireWildcard(require('./UrlUtils'));
}

var _UserSettings;

function _load_UserSettings() {
  return _UserSettings = _interopRequireDefault(require('./UserSettings'));
}

var _XDLError;

function _load_XDLError() {
  return _XDLError = _interopRequireDefault(require('./XDLError'));
}

var _ProjectSettings;

function _load_ProjectSettings() {
  return _ProjectSettings = _interopRequireWildcard(require('./ProjectSettings'));
}

var _MessageCode;

function _load_MessageCode() {
  return _MessageCode = _interopRequireDefault(require('./MessageCode'));
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// FIXME(perry) eliminate usage of this template
const ENTRY_POINT_PLATFORM_TEMPLATE_STRING = exports.ENTRY_POINT_PLATFORM_TEMPLATE_STRING = 'PLATFORM_GOES_HERE';

function getHomeDir() {
  return process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'] || '';
}

function makePathReadable(pth) {
  let homedir = getHomeDir();
  if (pth.substr(0, homedir.length) === homedir) {
    return `~${pth.substr(homedir.length)}`;
  } else {
    return pth;
  }
}
//# sourceMappingURL=__sourcemaps__/Exp.js.map
