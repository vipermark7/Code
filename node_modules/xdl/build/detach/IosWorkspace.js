'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNewestSdkVersionSupportedAsync = exports.getPaths = exports.createDetachedAsync = exports.addDetachedConfigToExp = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

let _getVersionedExpoKitConfigAsync = (() => {
  var _ref = _asyncToGenerator(function* (sdkVersion, skipServerValidation) {
    const versions = yield (_Versions || _load_Versions()).versionsAsync();
    let sdkVersionConfig = versions.sdkVersions[sdkVersion];
    if (!sdkVersionConfig) {
      if (skipServerValidation) {
        sdkVersionConfig = {};
      } else {
        throw new Error(`Unsupported SDK version: ${sdkVersion}`);
      }
    }
    const { iosVersion, iosExpoViewUrl } = sdkVersionConfig;
    const iosClientVersion = iosVersion ? iosVersion : versions.iosVersion;
    return {
      iosClientVersion,
      iosExpoViewUrl
    };
  });

  return function _getVersionedExpoKitConfigAsync(_x, _x2) {
    return _ref.apply(this, arguments);
  };
})();

let _getOrCreateTemplateDirectoryAsync = (() => {
  var _ref2 = _asyncToGenerator(function* (context, iosExpoViewUrl) {
    if (context.type === 'service') {
      return _path.default.join(context.data.expoSourcePath, '..');
    } else if (context.type === 'user') {
      let expoRootTemplateDirectory;
      if (process.env.EXPO_VIEW_DIR) {
        // Only for testing
        expoRootTemplateDirectory = process.env.EXPO_VIEW_DIR;
      } else {
        // HEY: if you need other paths into the extracted archive, be sure and include them
        // when the archive is generated in `ios/pipeline.js`
        expoRootTemplateDirectory = _path.default.join(context.data.projectPath, 'temp-ios-directory');
        if (!(0, (_ExponentTools || _load_ExponentTools()).isDirectory)(expoRootTemplateDirectory)) {
          (_fsExtra || _load_fsExtra()).default.mkdirpSync(expoRootTemplateDirectory);
          (_Logger || _load_Logger()).default.info('Downloading iOS code...');
          (0, (_invariant || _load_invariant()).default)(iosExpoViewUrl, `The URL for ExpoKit iOS must be set`);
          yield (_Api || _load_Api()).default.downloadAsync(iosExpoViewUrl, expoRootTemplateDirectory, {
            extract: true
          });
        }
      }
      return expoRootTemplateDirectory;
    }
  });

  return function _getOrCreateTemplateDirectoryAsync(_x3, _x4) {
    return _ref2.apply(this, arguments);
  };
})();

let _renameAndMoveProjectFilesAsync = (() => {
  var _ref3 = _asyncToGenerator(function* (context, projectDirectory, projectName) {
    // remove .gitignore, as this actually pertains to internal expo template management
    try {
      const gitIgnorePath = _path.default.join(projectDirectory, '.gitignore');
      if ((_fsExtra || _load_fsExtra()).default.existsSync(gitIgnorePath)) {
        (_rimraf || _load_rimraf()).default.sync(gitIgnorePath);
      }
    } catch (e) {}

    const filesToTransform = [_path.default.join('exponent-view-template.xcodeproj', 'project.pbxproj'), _path.default.join('exponent-view-template.xcworkspace', 'contents.xcworkspacedata'), _path.default.join('exponent-view-template.xcodeproj', 'xcshareddata', 'xcschemes', 'exponent-view-template.xcscheme')];

    let bundleIdentifier;
    if (context.type === 'user') {
      const exp = context.data.exp;
      bundleIdentifier = exp.ios && exp.ios.bundleIdentifier ? exp.ios.bundleIdentifier : null;
      if (!bundleIdentifier) {
        throw new Error(`Cannot configure an ExpoKit workspace with no iOS bundle identifier.`);
      }
    } else if (context.type === 'service') {
      bundleIdentifier = 'host.exp.Exponent';
    }

    yield Promise.all(filesToTransform.map(function (fileName) {
      return (0, (_ExponentTools || _load_ExponentTools()).transformFileContentsAsync)(_path.default.join(projectDirectory, fileName), function (fileString) {
        return fileString.replace(/com.getexponent.exponent-view-template/g, bundleIdentifier).replace(/exponent-view-template/g, projectName);
      });
    }));

    // order of this array matters
    const filesToMove = ['exponent-view-template', _path.default.join('exponent-view-template.xcodeproj', 'xcshareddata', 'xcschemes', 'exponent-view-template.xcscheme'), 'exponent-view-template.xcodeproj', 'exponent-view-template.xcworkspace'];

    filesToMove.forEach((() => {
      var _ref4 = _asyncToGenerator(function* (fileName) {
        let destFileName = _path.default.join(_path.default.dirname(fileName), `${projectName}${_path.default.extname(fileName)}`);
        yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('/bin/mv', [_path.default.join(projectDirectory, fileName), _path.default.join(projectDirectory, destFileName)]);
      });

      return function (_x8) {
        return _ref4.apply(this, arguments);
      };
    })());
  });

  return function _renameAndMoveProjectFilesAsync(_x5, _x6, _x7) {
    return _ref3.apply(this, arguments);
  };
})();

let _configureVersionsPlistAsync = (() => {
  var _ref5 = _asyncToGenerator(function* (configFilePath, standaloneSdkVersion, isServiceContext) {
    yield (_IosPlist || _load_IosPlist()).modifyAsync(configFilePath, 'EXSDKVersions', function (versionConfig) {
      versionConfig.sdkVersions = [standaloneSdkVersion];
      versionConfig.detachedNativeVersions = {
        shell: standaloneSdkVersion,
        kernel: standaloneSdkVersion
      };
      return versionConfig;
    });
  });

  return function _configureVersionsPlistAsync(_x9, _x10, _x11) {
    return _ref5.apply(this, arguments);
  };
})();

let _configureBuildConstantsPlistAsync = (() => {
  var _ref6 = _asyncToGenerator(function* (configFilePath, context) {
    yield (_IosPlist || _load_IosPlist()).modifyAsync(configFilePath, 'EXBuildConstants', function (constantsConfig) {
      constantsConfig.STANDALONE_CONTEXT_TYPE = context.type;
      return constantsConfig;
    });
  });

  return function _configureBuildConstantsPlistAsync(_x12, _x13) {
    return _ref6.apply(this, arguments);
  };
})();

let _renderPodfileFromTemplateAsync = (() => {
  var _ref7 = _asyncToGenerator(function* (context, expoRootTemplateDirectory, sdkVersion, iosClientVersion) {
    const { iosProjectDirectory, projectName } = getPaths(context);
    let podfileTemplateFilename;
    let podfileSubstitutions = {
      TARGET_NAME: projectName
    };
    let reactNativeDependencyPath;
    const detachableUniversalModules = (_Modules || _load_Modules()).getDetachableModulesForPlatformAndSdkVersion('ios', context.data.shellAppSdkVersion || sdkVersion);
    if (context.type === 'user') {
      (0, (_invariant || _load_invariant()).default)(iosClientVersion, `The iOS client version must be specified`);
      reactNativeDependencyPath = _path.default.dirname((_ProjectUtils || _load_ProjectUtils()).resolveModule('react-native/package.json', context.data.projectPath, context.data.exp));
      podfileSubstitutions.EXPOKIT_TAG = `ios/${iosClientVersion}`;
      podfileTemplateFilename = 'ExpoKit-Podfile';
      const expoDependenciesPath = _path.default.join(context.data.projectPath, 'node_modules');
      podfileSubstitutions.UNIVERSAL_MODULES = detachableUniversalModules.map(function (module) {
        return _extends({}, module, {
          path: _path.default.join(expoDependenciesPath, module.libName, module.subdirectory)
        });
      });
    } else if (context.type === 'service') {
      reactNativeDependencyPath = _path.default.join(expoRootTemplateDirectory, 'react-native-lab', 'react-native');
      podfileSubstitutions.EXPOKIT_PATH = _path.default.relative(iosProjectDirectory, expoRootTemplateDirectory);
      podfileSubstitutions.VERSIONED_REACT_NATIVE_PATH = _path.default.relative(iosProjectDirectory, _path.default.join(expoRootTemplateDirectory, 'ios', 'versioned-react-native'));
      const modulesPath = _path.default.join(expoRootTemplateDirectory, 'packages');
      podfileSubstitutions.UNIVERSAL_MODULES = detachableUniversalModules.map(function (module) {
        return _extends({}, module, {
          path: _path.default.join(modulesPath, module.libName, module.subdirectory)
        });
      });
      podfileTemplateFilename = 'ExpoKit-Podfile-versioned';
    } else {
      throw new Error(`Unsupported context type: ${context.type}`);
    }
    podfileSubstitutions.REACT_NATIVE_PATH = _path.default.relative(iosProjectDirectory, reactNativeDependencyPath);
    podfileSubstitutions.UNIVERSAL_MODULES = podfileSubstitutions.UNIVERSAL_MODULES.map(function (module) {
      return _extends({}, module, {
        path: _path.default.relative(iosProjectDirectory, module.path)
      });
    });

    // env flags for testing
    if (process.env.EXPOKIT_TAG_IOS) {
      (_Logger || _load_Logger()).default.info(`EXPOKIT_TAG_IOS: Using custom ExpoKit iOS tag...`);
      podfileSubstitutions.EXPOKIT_TAG = process.env.EXPOKIT_TAG_IOS;
    } else if (process.env.EXPO_VIEW_DIR) {
      (_Logger || _load_Logger()).default.info('EXPO_VIEW_DIR: Using local ExpoKit source for iOS...');
      podfileSubstitutions.EXPOKIT_PATH = _path.default.relative(iosProjectDirectory, process.env.EXPO_VIEW_DIR);
      // If EXPO_VIEW_DIR is defined overwrite UNIVERSAL_MODULES with paths pointing to EXPO_VIEW_DIR
      podfileSubstitutions.UNIVERSAL_MODULES = podfileSubstitutions.UNIVERSAL_MODULES.map(function (module) {
        return _extends({}, module, {
          path: _path.default.relative(iosProjectDirectory, _path.default.join(process.env.EXPO_VIEW_DIR, 'packages', module.libName, module.subdirectory))
        });
      });
    }
    const templatePodfilePath = _path.default.join(expoRootTemplateDirectory, 'template-files', 'ios', podfileTemplateFilename);
    yield (0, (_IosPodsTools || _load_IosPodsTools()).renderPodfileAsync)(templatePodfilePath, _path.default.join(iosProjectDirectory, 'Podfile'), podfileSubstitutions, context.data.shellAppSdkVersion, sdkVersion);
  });

  return function _renderPodfileFromTemplateAsync(_x14, _x15, _x16, _x17) {
    return _ref7.apply(this, arguments);
  };
})();

let createDetachedAsync = (() => {
  var _ref8 = _asyncToGenerator(function* (context) {
    const { iosProjectDirectory, projectName, supportingDirectory } = getPaths(context);
    (_Logger || _load_Logger()).default.info(`Creating ExpoKit workspace at ${iosProjectDirectory}...`);

    const isServiceContext = context.type === 'service';
    const standaloneSdkVersion = yield getNewestSdkVersionSupportedAsync(context);

    let iosClientVersion;
    let iosExpoViewUrl;
    if (context.type === 'user') {
      ({ iosClientVersion, iosExpoViewUrl } = yield _getVersionedExpoKitConfigAsync(standaloneSdkVersion, process.env.EXPO_VIEW_DIR));
    }

    const expoRootTemplateDirectory = yield _getOrCreateTemplateDirectoryAsync(context, iosExpoViewUrl);

    // copy template workspace
    (_Logger || _load_Logger()).default.info('Moving iOS project files...');
    (_Logger || _load_Logger()).default.info('Attempting to create project directory...');
    (_fsExtra || _load_fsExtra()).default.mkdirpSync(iosProjectDirectory);
    (_Logger || _load_Logger()).default.info('Created project directory! Copying files:');
    yield (_Utils || _load_Utils()).ncpAsync(_path.default.join(expoRootTemplateDirectory, 'exponent-view-template', 'ios'), iosProjectDirectory);

    (_Logger || _load_Logger()).default.info('Naming iOS project...');
    yield _renameAndMoveProjectFilesAsync(context, iosProjectDirectory, projectName);

    (_Logger || _load_Logger()).default.info('Configuring iOS dependencies...');
    // this configuration must happen prior to build time because it affects which
    // native versions of RN we depend on.
    yield _configureVersionsPlistAsync(supportingDirectory, standaloneSdkVersion, isServiceContext);
    yield _configureBuildConstantsPlistAsync(supportingDirectory, context);
    yield _renderPodfileFromTemplateAsync(context, expoRootTemplateDirectory, standaloneSdkVersion, iosClientVersion);

    if (!process.env.EXPO_VIEW_DIR) {
      if (context.type === 'user') {
        (0, (_ExponentTools || _load_ExponentTools()).rimrafDontThrow)(expoRootTemplateDirectory);
      }
      yield (_IosPlist || _load_IosPlist()).cleanBackupAsync(supportingDirectory, 'EXSDKVersions', false);
    }
  });

  return function createDetachedAsync(_x18) {
    return _ref8.apply(this, arguments);
  };
})();

/**
 *  Get the newest sdk version supported given the standalone context.
 *  Not all contexts support the newest sdk version.
 */
let getNewestSdkVersionSupportedAsync = (() => {
  var _ref9 = _asyncToGenerator(function* (context) {
    if (context.type === 'user') {
      return context.data.exp.sdkVersion;
    } else if (context.type === 'service') {
      // when running in universe or on a turtle machine,
      // we care about what sdk version is actually present in this working copy.
      // this might not be the same thing deployed to our www Versions endpoint.
      let { supportingDirectory } = getPaths(context);
      if (!(_fsExtra || _load_fsExtra()).default.existsSync(supportingDirectory)) {
        // if we run this method before creating the workspace, we may need to look at the template.
        supportingDirectory = _path.default.join(context.data.expoSourcePath, '..', 'exponent-view-template', 'ios', 'exponent-view-template', 'Supporting');
      }
      let allVersions, newestVersion;
      yield (_IosPlist || _load_IosPlist()).modifyAsync(supportingDirectory, 'EXSDKVersions', function (versionConfig) {
        allVersions = versionConfig.sdkVersions;
        return versionConfig;
      });
      let highestMajorComponent = 0;
      allVersions.forEach(function (version) {
        let majorComponent = (0, (_ExponentTools || _load_ExponentTools()).parseSdkMajorVersion)(version);
        if (majorComponent > highestMajorComponent) {
          highestMajorComponent = majorComponent;
          newestVersion = version;
        }
      });
      return newestVersion;
    }
  });

  return function getNewestSdkVersionSupportedAsync(_x19) {
    return _ref9.apply(this, arguments);
  };
})();

var _fsExtra;

function _load_fsExtra() {
  return _fsExtra = _interopRequireDefault(require('fs-extra'));
}

var _invariant;

function _load_invariant() {
  return _invariant = _interopRequireDefault(require('invariant'));
}

var _path = _interopRequireDefault(require('path'));

var _rimraf;

function _load_rimraf() {
  return _rimraf = _interopRequireDefault(require('rimraf'));
}

var _Api;

function _load_Api() {
  return _Api = _interopRequireDefault(require('../Api'));
}

var _ExponentTools;

function _load_ExponentTools() {
  return _ExponentTools = require('./ExponentTools');
}

var _IosPodsTools;

function _load_IosPodsTools() {
  return _IosPodsTools = require('./IosPodsTools.js');
}

var _IosPlist;

function _load_IosPlist() {
  return _IosPlist = _interopRequireWildcard(require('./IosPlist'));
}

var _Logger;

function _load_Logger() {
  return _Logger = _interopRequireDefault(require('./Logger'));
}

var _ProjectUtils;

function _load_ProjectUtils() {
  return _ProjectUtils = _interopRequireWildcard(require('../project/ProjectUtils'));
}

var _Utils;

function _load_Utils() {
  return _Utils = _interopRequireWildcard(require('../Utils'));
}

var _StandaloneContext;

function _load_StandaloneContext() {
  return _StandaloneContext = _interopRequireDefault(require('./StandaloneContext'));
}

var _Versions;

function _load_Versions() {
  return _Versions = _interopRequireWildcard(require('../Versions'));
}

var _Modules;

function _load_Modules() {
  return _Modules = _interopRequireWildcard(require('../modules/Modules'));
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function addDetachedConfigToExp(exp, context) {
  if (context.type !== 'user') {
    (_Logger || _load_Logger()).default.warn(`Tried to modify exp for a non-user StandaloneContext, ignoring`);
    return exp;
  }
  const { supportingDirectory } = getPaths(context);
  exp.ios.publishBundlePath = _path.default.relative(context.data.projectPath, _path.default.join(supportingDirectory, 'shell-app.bundle'));
  exp.ios.publishManifestPath = _path.default.relative(context.data.projectPath, _path.default.join(supportingDirectory, 'shell-app-manifest.json'));
  return exp;
}

/**
 *  paths returned:
 *    iosProjectDirectory - root directory of an (uncompiled) xcworkspace and obj-c source tree
 *    projectName - xcworkspace project name normalized from context.config
 *    supportingDirectory - location of Info.plist, xib files, etc. during configuration.
 *      for an unbuilt app this is underneath iosProjectDirectory. for a compiled app it's just
 *      a path to the flat xcarchive.
 *    intermediatesDirectory - temporary spot to write whatever files are needed during the
 *      detach/build process but can be discarded afterward.
 */
function getPaths(context) {
  let iosProjectDirectory;
  let projectName;
  let supportingDirectory;
  let intermediatesDirectory;
  if (context.isAnonymous()) {
    projectName = 'ExpoKitApp';
  } else if (context.config && context.config.name) {
    let projectNameLabel = context.config.name;
    projectName = projectNameLabel.replace(/[^a-z0-9_\-]/gi, '-').toLowerCase();
  } else {
    throw new Error('Cannot configure an Expo project with no name.');
  }
  if (context.type === 'user') {
    iosProjectDirectory = _path.default.join(context.data.projectPath, 'ios');
    supportingDirectory = _path.default.join(iosProjectDirectory, projectName, 'Supporting');
  } else if (context.type === 'service') {
    iosProjectDirectory = context.build.ios.workspaceSourcePath;
    if (context.data.archivePath) {
      // compiled archive has a flat NSBundle
      supportingDirectory = context.data.archivePath;
    } else {
      supportingDirectory = _path.default.join(iosProjectDirectory, projectName, 'Supporting');
    }
  } else {
    throw new Error(`Unsupported StandaloneContext type: ${context.type}`);
  }
  // sandbox intermediates directory by workspace so that concurrently operating
  // contexts do not interfere with one another.
  intermediatesDirectory = _path.default.join(iosProjectDirectory, 'ExpoKitIntermediates');
  return {
    intermediatesDirectory,
    iosProjectDirectory,
    projectName,
    supportingDirectory
  };
}exports.addDetachedConfigToExp = addDetachedConfigToExp;
exports.createDetachedAsync = createDetachedAsync;
exports.getPaths = getPaths;
exports.getNewestSdkVersionSupportedAsync = getNewestSdkVersionSupportedAsync;
//# sourceMappingURL=../__sourcemaps__/detach/IosWorkspace.js.map
