// Copyright 2015-present 650 Industries. All rights reserved.
'use strict';

// Set EXPO_VIEW_DIR to universe/exponent to test locally

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bundleAssetsAsync = exports.prepareDetachedBuildAsync = exports.detachAsync = undefined;

let yesnoAsync = (() => {
  var _ref = _asyncToGenerator(function* (message) {
    const { ok } = yield (_inquirer || _load_inquirer()).default.prompt([{
      type: 'confirm',
      name: 'ok',
      message
    }]);
    return ok;
  });

  return function yesnoAsync(_x) {
    return _ref.apply(this, arguments);
  };
})();

let detachAsync = exports.detachAsync = (() => {
  var _ref2 = _asyncToGenerator(function* (projectRoot, options = {}) {
    let user = yield (_User || _load_User()).default.ensureLoggedInAsync();

    if (!user) {
      throw new Error('Internal error -- somehow detach is being run in offline mode.');
    }

    let username = user.username;
    const { configName, configPath, configNamespace } = yield (_ProjectUtils || _load_ProjectUtils()).findConfigFileAsync(projectRoot);
    let { exp, pkg } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectRoot);
    if (!exp) throw new Error(`Couldn't read ${configName}`);
    if (!pkg) throw new Error(`Couldn't read package.json`);
    let experienceName = `@${username}/${exp.slug}`;
    let experienceUrl = `exp://exp.host/${experienceName}`;

    // Check to make sure project isn't fully detached already
    let hasIosDirectory = (0, (_ExponentTools || _load_ExponentTools()).isDirectory)(_path.default.join(projectRoot, 'ios'));
    let hasAndroidDirectory = (0, (_ExponentTools || _load_ExponentTools()).isDirectory)(_path.default.join(projectRoot, 'android'));

    if (hasIosDirectory && hasAndroidDirectory) {
      throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.DIRECTORY_ALREADY_EXISTS, 'Error detaching. `ios` and `android` directories already exist.');
    }

    // Project was already detached on Windows or Linux
    if (!hasIosDirectory && hasAndroidDirectory && _process.default.platform === 'darwin') {
      let response = yield yesnoAsync(`This will add an Xcode project and leave your existing Android project alone. Enter 'yes' to continue:`);
      if (!response) {
        (_Logger || _load_Logger()).default.info('Exiting...');
        return false;
      }
    }

    if (hasIosDirectory && !hasAndroidDirectory) {
      throw new Error('`ios` directory already exists. Please remove it and try again.');
    }

    (_Logger || _load_Logger()).default.info('Validating project manifest...');
    if (!exp.name) {
      throw new Error(`${configName} is missing \`name\``);
    }

    if (!exp.sdkVersion) {
      throw new Error(`${configName} is missing \`sdkVersion\``);
    }

    let majorSdkVersion = (0, (_ExponentTools || _load_ExponentTools()).parseSdkMajorVersion)(exp.sdkVersion);
    if (majorSdkVersion < 16) {
      throw new Error(`${configName} must be updated to SDK 16.0.0 or newer to be detached.`);
    }

    const versions = yield (_Versions || _load_Versions()).versionsAsync();
    let sdkVersionConfig = versions.sdkVersions[exp.sdkVersion];
    if (!sdkVersionConfig || !sdkVersionConfig.androidExpoViewUrl || !sdkVersionConfig.iosExpoViewUrl) {
      if (_process.default.env.EXPO_VIEW_DIR) {
        (_Logger || _load_Logger()).default.warn(`Detaching is not supported for SDK ${exp.sdkVersion}; ignoring this because you provided EXPO_VIEW_DIR`);
        sdkVersionConfig = {};
      } else {
        throw new Error(`Detaching is not supported for SDK version ${exp.sdkVersion}`);
      }
    }

    // Modify exp.json
    exp.isDetached = true;

    if (!exp.detach) {
      exp.detach = {};
    }

    let detachedUUID = (_uuid || _load_uuid()).default.v4().replace(/-/g, '');
    let generatedScheme = `exp${detachedUUID}`;

    if (!exp.detach.scheme && !(_Versions || _load_Versions()).gteSdkVersion(exp, '27.0.0')) {
      // set this for legacy purposes
      exp.detach.scheme = generatedScheme;
    }

    if (!exp.scheme) {
      (_Logger || _load_Logger()).default.info(`You have not specified a custom scheme for deep linking. A default value of ${generatedScheme} will be used. You can change this later by following the instructions in this guide: https://docs.expo.io/versions/latest/workflow/linking`);
      exp.scheme = generatedScheme;
    }

    let expoDirectory = _path.default.join(projectRoot, '.expo-source');
    (_fsExtra || _load_fsExtra()).default.mkdirpSync(expoDirectory);
    const context = (_StandaloneContext || _load_StandaloneContext()).default.createUserContext(projectRoot, exp, experienceUrl);

    // iOS
    let isIosSupported = true;
    if (_process.default.platform !== 'darwin') {
      if (options && options.force) {
        (_Logger || _load_Logger()).default.warn(`You are not running macOS, but have provided the --force option, so we will attempt to generate an iOS project anyway. This might fail.`);
      } else {
        (_Logger || _load_Logger()).default.warn(`Skipping iOS because you are not running macOS.`);
        isIosSupported = false;
      }
    }

    if (!hasIosDirectory && isIosSupported) {
      if (!exp.ios) {
        exp.ios = {};
      }
      if (!exp.ios.bundleIdentifier) {
        (_Logger || _load_Logger()).default.info(`You'll need to specify an iOS bundle identifier. See: https://docs.expo.io/versions/latest/guides/configuration.html#bundleidentifier`);
        const { iosBundleIdentifier } = yield (_inquirer || _load_inquirer()).default.prompt([{
          name: 'iosBundleIdentifier',
          message: 'What would you like your iOS bundle identifier to be?',
          validate: function (value) {
            return (/^[a-zA-Z][a-zA-Z0-9\-\.]+$/.test(value)
            );
          }
        }]);
        exp.ios.bundleIdentifier = iosBundleIdentifier;
      }

      yield detachIOSAsync(context);
      exp = (_IosWorkspace || _load_IosWorkspace()).addDetachedConfigToExp(exp, context);
      exp.detach.iosExpoViewUrl = sdkVersionConfig.iosExpoViewUrl;
    }

    // Android
    if (!hasAndroidDirectory) {
      if (!exp.android) {
        exp.android = {};
      }
      if (!exp.android.package) {
        (_Logger || _load_Logger()).default.info(`You'll need to specify an Android package name. See: https://docs.expo.io/versions/latest/guides/configuration.html#package`);
        const { androidPackage } = yield (_inquirer || _load_inquirer()).default.prompt([{
          name: 'androidPackage',
          message: 'What would you like your Android package name to be?',
          validate: function (value) {
            return (/^[a-zA-Z][a-zA-Z0-9\_]*(\.[a-zA-Z][a-zA-Z0-9\_]*)+$/.test(value) ? true : "Invalid format of Android package name (only alphanumeric characters, '.' and '_' are allowed, and each '.' must be followed by a letter)"
            );
          }
        }]);
        exp.android.package = androidPackage;
      }

      let androidDirectory = _path.default.join(expoDirectory, 'android');
      (_rimraf || _load_rimraf()).default.sync(androidDirectory);
      (_fsExtra || _load_fsExtra()).default.mkdirpSync(androidDirectory);
      if ((_Versions || _load_Versions()).gteSdkVersion(exp, '24.0.0')) {
        yield detachAndroidAsync(context, sdkVersionConfig.androidExpoViewUrl);
      } else {
        yield (_OldAndroidDetach || _load_OldAndroidDetach()).detachAndroidAsync(projectRoot, androidDirectory, exp.sdkVersion, experienceUrl, exp, sdkVersionConfig.androidExpoViewUrl);
      }
      exp = (_AndroidShellApp || _load_AndroidShellApp()).addDetachedConfigToExp(exp, context);
      exp.detach.androidExpoViewUrl = sdkVersionConfig.androidExpoViewUrl;
    }

    (_Logger || _load_Logger()).default.info('Writing ExpoKit configuration...');
    // Update exp.json/app.json
    // if we're writing to app.json, we need to place the configuration under the expo key
    const config = configNamespace ? { [configNamespace]: exp } : exp;
    yield (_fsExtra || _load_fsExtra()).default.writeFile(configPath, JSON.stringify(config, null, 2));

    let reactNativeVersion, expoReactNativeTag;
    if (sdkVersionConfig && sdkVersionConfig.expoReactNativeTag) {
      expoReactNativeTag = sdkVersionConfig.expoReactNativeTag;
      reactNativeVersion = `https://github.com/expo/react-native/archive/${expoReactNativeTag}.tar.gz`;
    } else {
      if (_process.default.env.EXPO_VIEW_DIR) {
        // ignore, using test directory
      } else {
        throw new Error(`Expo's React Native fork does not support this SDK version.`);
      }
    }

    const nodeModulesPath = exp.nodeModulesPath ? _path.default.resolve(projectRoot, exp.nodeModulesPath) : projectRoot;
    if (reactNativeVersion && pkg.dependencies['react-native'] !== reactNativeVersion) {
      (_Logger || _load_Logger()).default.info('Installing the Expo fork of react-native...');
      try {
        yield (0, (_installPackageAsync || _load_installPackageAsync()).default)(nodeModulesPath, 'react-native', reactNativeVersion, {
          silent: true
        });
      } catch (e) {
        (_Logger || _load_Logger()).default.warn('Unable to install the Expo fork of react-native.');
        (_Logger || _load_Logger()).default.warn(`Please install react-native@${reactNativeVersion} to complete detaching.`);
      }
    }

    // Add expokitNpmPackage if it is supported. Was added before SDK 29.
    if (_process.default.env.EXPO_VIEW_DIR) {
      (_Logger || _load_Logger()).default.info(`Installing 'expokit' package...`);
      yield (0, (_spawnAsync || _load_spawnAsync()).default)('yarn', ['link'], {
        cwd: _path.default.join(_process.default.env.EXPO_VIEW_DIR, 'expokit-npm-package')
      });
      yield (0, (_spawnAsync || _load_spawnAsync()).default)('yarn', ['link', 'expokit'], {
        cwd: nodeModulesPath
      });
    } else if (sdkVersionConfig.expokitNpmPackage) {
      (_Logger || _load_Logger()).default.info(`Installing 'expokit' package...`);
      try {
        let packageName = sdkVersionConfig.expokitNpmPackage.split('@')[0];
        let packageVersion = sdkVersionConfig.expokitNpmPackage.split('@')[1];
        yield (0, (_installPackageAsync || _load_installPackageAsync()).default)(nodeModulesPath, packageName, packageVersion, {
          silent: true
        });
      } catch (e) {
        (_Logger || _load_Logger()).default.warn(`Unable to install ${sdkVersionConfig.expokitNpmPackage}.`);
        (_Logger || _load_Logger()).default.warn('Please install manually to complete detaching.');
      }
    }

    (_Logger || _load_Logger()).default.info('Finished detaching your project! Look in the `android` and `ios` directories for the respective native projects. Follow the ExpoKit guide at https://docs.expo.io/versions/latest/guides/expokit.html to get your project running.');
    return true;
  });

  return function detachAsync(_x2) {
    return _ref2.apply(this, arguments);
  };
})();

/**
 *  Create a detached Expo iOS app pointing at the given project.
 */


let detachIOSAsync = (() => {
  var _ref3 = _asyncToGenerator(function* (context) {
    yield (_IosWorkspace || _load_IosWorkspace()).createDetachedAsync(context);

    (_Logger || _load_Logger()).default.info('Configuring iOS project...');
    yield (_IosNSBundle || _load_IosNSBundle()).configureAsync(context);

    (_Logger || _load_Logger()).default.info(`iOS detach is complete!`);
  });

  return function detachIOSAsync(_x3) {
    return _ref3.apply(this, arguments);
  };
})();

let detachAndroidAsync = (() => {
  var _ref4 = _asyncToGenerator(function* (context, expoViewUrl) {
    if (context.type !== 'user') {
      throw new Error(`detachAndroidAsync only supports user standalone contexts`);
    }

    (_Logger || _load_Logger()).default.info('Moving Android project files...');
    let androidProjectDirectory = _path.default.join(context.data.projectPath, 'android');
    let tmpExpoDirectory;
    if (_process.default.env.EXPO_VIEW_DIR) {
      // Only for testing
      yield (_AndroidShellApp || _load_AndroidShellApp()).copyInitialShellAppFilesAsync(_path.default.join(_process.default.env.EXPO_VIEW_DIR, 'android'), androidProjectDirectory, true, context.data.exp.sdkVersion);
    } else {
      tmpExpoDirectory = _path.default.join(context.data.projectPath, 'temp-android-directory');
      (_fsExtra || _load_fsExtra()).default.mkdirpSync(tmpExpoDirectory);
      (_Logger || _load_Logger()).default.info('Downloading Android code...');
      yield (_Api || _load_Api()).default.downloadAsync(expoViewUrl, tmpExpoDirectory, { extract: true });
      yield (_AndroidShellApp || _load_AndroidShellApp()).copyInitialShellAppFilesAsync(tmpExpoDirectory, androidProjectDirectory, true, context.data.exp.sdkVersion);
    }

    (_Logger || _load_Logger()).default.info('Updating Android app...');
    yield (_AndroidShellApp || _load_AndroidShellApp()).runShellAppModificationsAsync(context, context.data.exp.sdkVersion);

    // Clean up
    (_Logger || _load_Logger()).default.info('Cleaning up Android...');
    if (!_process.default.env.EXPO_VIEW_DIR) {
      (0, (_ExponentTools || _load_ExponentTools()).rimrafDontThrow)(tmpExpoDirectory);
    }
    (_Logger || _load_Logger()).default.info('Android detach is complete!\n');
  });

  return function detachAndroidAsync(_x4, _x5) {
    return _ref4.apply(this, arguments);
  };
})();

let ensureBuildConstantsExistsIOSAsync = (() => {
  var _ref5 = _asyncToGenerator(function* (configFilePath) {
    // EXBuildConstants is included in newer ExpoKit projects.
    // create it if it doesn't exist.
    const doesBuildConstantsExist = (_fsExtra || _load_fsExtra()).default.existsSync(_path.default.join(configFilePath, 'EXBuildConstants.plist'));
    if (!doesBuildConstantsExist) {
      yield (_IosPlist || _load_IosPlist()).createBlankAsync(configFilePath, 'EXBuildConstants');
      (_Logger || _load_Logger()).default.info('Created `EXBuildConstants.plist` because it did not exist yet');
    }
  });

  return function ensureBuildConstantsExistsIOSAsync(_x6) {
    return _ref5.apply(this, arguments);
  };
})();

let _getIosExpoKitVersionThrowErrorAsync = (() => {
  var _ref6 = _asyncToGenerator(function* (iosProjectDirectory) {
    let expoKitVersion = '';
    const podfileLockPath = _path.default.join(iosProjectDirectory, 'Podfile.lock');
    try {
      const podfileLock = yield (_fsExtra || _load_fsExtra()).default.readFile(podfileLockPath, 'utf8');
      const expoKitVersionRegex = /ExpoKit\/Core\W?\(([0-9\.]+)\)/gi;
      let match = expoKitVersionRegex.exec(podfileLock);
      expoKitVersion = match[1];
    } catch (e) {
      throw new Error(`Unable to read ExpoKit version from Podfile.lock. Make sure your project depends on ExpoKit. (${e})`);
    }
    return expoKitVersion;
  });

  return function _getIosExpoKitVersionThrowErrorAsync(_x7) {
    return _ref6.apply(this, arguments);
  };
})();

let prepareDetachedBuildIosAsync = (() => {
  var _ref7 = _asyncToGenerator(function* (projectDir, args) {
    const { exp } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectDir);
    if (exp) {
      return prepareDetachedUserContextIosAsync(projectDir, exp, args);
    } else {
      return prepareDetachedServiceContextIosAsync(projectDir, args);
    }
  });

  return function prepareDetachedBuildIosAsync(_x8, _x9) {
    return _ref7.apply(this, arguments);
  };
})();

let prepareDetachedServiceContextIosAsync = (() => {
  var _ref8 = _asyncToGenerator(function* (projectDir, args) {
    // service context
    // TODO: very brittle hack: the paths here are hard coded to match the single workspace
    // path generated inside IosShellApp. When we support more than one path, this needs to
    // be smarter.
    const expoRootDir = _path.default.join(projectDir, '..', '..');
    const workspaceSourcePath = _path.default.join(projectDir, 'default');
    const buildFlags = (_StandaloneBuildFlags || _load_StandaloneBuildFlags()).default.createIos('Release', { workspaceSourcePath });
    const context = (_StandaloneContext || _load_StandaloneContext()).default.createServiceContext(expoRootDir, null, null, null,
    /* testEnvironment */'none', buildFlags, null, null);
    const { iosProjectDirectory, supportingDirectory } = (_IosWorkspace || _load_IosWorkspace()).getPaths(context);
    const expoKitVersion = yield _getIosExpoKitVersionThrowErrorAsync(iosProjectDirectory);

    // use prod api keys if available
    const prodApiKeys = yield _readDefaultApiKeysAsync(_path.default.join(context.data.expoSourcePath, '__internal__', 'keys.json'));

    const { exp } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(expoRootDir);

    yield (_IosPlist || _load_IosPlist()).modifyAsync(supportingDirectory, 'EXBuildConstants', function (constantsConfig) {
      // verify that we are actually in a service context and not a misconfigured project
      const contextType = constantsConfig.STANDALONE_CONTEXT_TYPE;
      if (contextType !== 'service') {
        throw new Error('Unable to configure a project which has no app.json and also no STANDALONE_CONTEXT_TYPE.');
      }
      constantsConfig.EXPO_RUNTIME_VERSION = expoKitVersion;
      constantsConfig.API_SERVER_ENDPOINT = _process.default.env.ENVIRONMENT === 'staging' ? 'https://staging.exp.host/--/api/v2/' : 'https://exp.host/--/api/v2/';
      if (prodApiKeys) {
        constantsConfig.DEFAULT_API_KEYS = prodApiKeys;
      }
      if (exp && exp.sdkVersion) {
        constantsConfig.TEMPORARY_SDK_VERSION = exp.sdkVersion;
      }
      return constantsConfig;
    });
  });

  return function prepareDetachedServiceContextIosAsync(_x10, _x11) {
    return _ref8.apply(this, arguments);
  };
})();

let _readDefaultApiKeysAsync = (() => {
  var _ref9 = _asyncToGenerator(function* (jsonFilePath) {
    if ((_fsExtra || _load_fsExtra()).default.existsSync(jsonFilePath)) {
      let keys = {};
      const allKeys = yield new (_jsonFile || _load_jsonFile()).default(jsonFilePath).readAsync();
      const validKeys = ['AMPLITUDE_KEY', 'GOOGLE_MAPS_IOS_API_KEY'];
      for (const key in allKeys) {
        if (allKeys.hasOwnProperty(key) && validKeys.includes(key)) {
          keys[key] = allKeys[key];
        }
      }
      return keys;
    }
    return null;
  });

  return function _readDefaultApiKeysAsync(_x12) {
    return _ref9.apply(this, arguments);
  };
})();

let prepareDetachedUserContextIosAsync = (() => {
  var _ref10 = _asyncToGenerator(function* (projectDir, exp, args) {
    const context = (_StandaloneContext || _load_StandaloneContext()).default.createUserContext(projectDir, exp);
    let { iosProjectDirectory, supportingDirectory } = (_IosWorkspace || _load_IosWorkspace()).getPaths(context);

    (_Logger || _load_Logger()).default.info(`Preparing iOS build at ${iosProjectDirectory}...`);
    // These files cause @providesModule naming collisions
    // but are not available until after `pod install` has run.
    let podsDirectory = _path.default.join(iosProjectDirectory, 'Pods');
    if (!(0, (_ExponentTools || _load_ExponentTools()).isDirectory)(podsDirectory)) {
      throw new Error(`Can't find directory ${podsDirectory}, make sure you've run pod install.`);
    }
    let rnPodDirectory = _path.default.join(podsDirectory, 'React');
    if ((0, (_ExponentTools || _load_ExponentTools()).isDirectory)(rnPodDirectory)) {
      let rnFilesToDelete = yield (0, (_globPromise || _load_globPromise()).default)(rnPodDirectory + '/**/*.@(js|json)');
      if (rnFilesToDelete) {
        for (let i = 0; i < rnFilesToDelete.length; i++) {
          yield (_fsExtra || _load_fsExtra()).default.unlink(rnFilesToDelete[i]);
        }
      }
    }

    // insert expo development url into iOS config
    if (!args.skipXcodeConfig) {
      // populate EXPO_RUNTIME_VERSION from ExpoKit pod version
      const expoKitVersion = yield _getIosExpoKitVersionThrowErrorAsync(iosProjectDirectory);

      // populate development url
      let devUrl = yield (_UrlUtils || _load_UrlUtils()).constructManifestUrlAsync(projectDir);

      // populate default api keys
      const defaultApiKeys = yield _readDefaultApiKeysAsync(_path.default.join(podsDirectory, 'ExpoKit', 'template-files', 'keys.json'));

      yield ensureBuildConstantsExistsIOSAsync(supportingDirectory);
      yield (_IosPlist || _load_IosPlist()).modifyAsync(supportingDirectory, 'EXBuildConstants', function (constantsConfig) {
        constantsConfig.developmentUrl = devUrl;
        constantsConfig.EXPO_RUNTIME_VERSION = expoKitVersion;
        if (defaultApiKeys) {
          constantsConfig.DEFAULT_API_KEYS = defaultApiKeys;
        }
        if (exp.sdkVersion) {
          constantsConfig.TEMPORARY_SDK_VERSION = exp.sdkVersion;
        }
        return constantsConfig;
      });
    }
  });

  return function prepareDetachedUserContextIosAsync(_x13, _x14, _x15) {
    return _ref10.apply(this, arguments);
  };
})();

let prepareDetachedBuildAsync = exports.prepareDetachedBuildAsync = (() => {
  var _ref11 = _asyncToGenerator(function* (projectDir, args) {
    if (args.platform === 'ios') {
      yield prepareDetachedBuildIosAsync(projectDir, args);
    } else {
      let { exp } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectDir);
      let buildConstantsFileName = (_Versions || _load_Versions()).gteSdkVersion(exp, '24.0.0') ? 'DetachBuildConstants.java' : 'ExponentBuildConstants.java';

      let androidProjectDirectory = _path.default.join(projectDir, 'android');
      let expoBuildConstantsMatches = yield (0, (_globPromise || _load_globPromise()).default)(androidProjectDirectory + '/**/' + buildConstantsFileName);
      if (expoBuildConstantsMatches && expoBuildConstantsMatches.length) {
        let expoBuildConstants = expoBuildConstantsMatches[0];
        let devUrl = yield (_UrlUtils || _load_UrlUtils()).constructManifestUrlAsync(projectDir);
        yield (0, (_ExponentTools || _load_ExponentTools()).regexFileAsync)(/DEVELOPMENT_URL \= \"[^\"]*\"\;/, `DEVELOPMENT_URL = "${devUrl}";`, expoBuildConstants);
      }
    }
  });

  return function prepareDetachedBuildAsync(_x16, _x17) {
    return _ref11.apply(this, arguments);
  };
})();

let bundleAssetsAsync = exports.bundleAssetsAsync = (() => {
  var _ref12 = _asyncToGenerator(function* (projectDir, args) {
    let { exp } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectDir);
    if (!exp) {
      // Don't run assets bundling for the service context.
      return;
    }
    let publishManifestPath = args.platform === 'ios' ? exp.ios.publishManifestPath : exp.android.publishManifestPath;
    if (!publishManifestPath) {
      (_Logger || _load_Logger()).default.warn(`Skipped assets bundling because the '${args.platform}.publishManifestPath' key is not specified in the app manifest.`);
      return;
    }
    let bundledManifestPath = _path.default.join(projectDir, publishManifestPath);
    let manifest;
    try {
      manifest = JSON.parse((yield (_fsExtra || _load_fsExtra()).default.readFile(bundledManifestPath, 'utf8')));
    } catch (ex) {
      throw new Error(`Error reading the manifest file. Make sure the path '${bundledManifestPath}' is correct.\n\nError: ${ex.message}`);
    }
    yield (_AssetBundle || _load_AssetBundle()).bundleAsync(null, manifest.bundledAssets, args.dest);
  });

  return function bundleAssetsAsync(_x18, _x19) {
    return _ref12.apply(this, arguments);
  };
})();

var _fsExtra;

function _load_fsExtra() {
  return _fsExtra = _interopRequireDefault(require('fs-extra'));
}

var _jsonFile;

function _load_jsonFile() {
  return _jsonFile = _interopRequireDefault(require('@expo/json-file'));
}

var _path = _interopRequireDefault(require('path'));

var _process = _interopRequireDefault(require('process'));

var _rimraf;

function _load_rimraf() {
  return _rimraf = _interopRequireDefault(require('rimraf'));
}

var _globPromise;

function _load_globPromise() {
  return _globPromise = _interopRequireDefault(require('glob-promise'));
}

var _uuid;

function _load_uuid() {
  return _uuid = _interopRequireDefault(require('uuid'));
}

var _inquirer;

function _load_inquirer() {
  return _inquirer = _interopRequireDefault(require('inquirer'));
}

var _spawnAsync;

function _load_spawnAsync() {
  return _spawnAsync = _interopRequireDefault(require('@expo/spawn-async'));
}

var _ExponentTools;

function _load_ExponentTools() {
  return _ExponentTools = require('./ExponentTools');
}

var _AssetBundle;

function _load_AssetBundle() {
  return _AssetBundle = _interopRequireWildcard(require('./AssetBundle'));
}

var _IosPlist;

function _load_IosPlist() {
  return _IosPlist = _interopRequireWildcard(require('./IosPlist'));
}

var _IosNSBundle;

function _load_IosNSBundle() {
  return _IosNSBundle = _interopRequireWildcard(require('./IosNSBundle'));
}

var _IosWorkspace;

function _load_IosWorkspace() {
  return _IosWorkspace = _interopRequireWildcard(require('./IosWorkspace'));
}

var _AndroidShellApp;

function _load_AndroidShellApp() {
  return _AndroidShellApp = _interopRequireWildcard(require('./AndroidShellApp'));
}

var _OldAndroidDetach;

function _load_OldAndroidDetach() {
  return _OldAndroidDetach = _interopRequireWildcard(require('./OldAndroidDetach'));
}

var _Api;

function _load_Api() {
  return _Api = _interopRequireDefault(require('../Api'));
}

var _ErrorCode;

function _load_ErrorCode() {
  return _ErrorCode = _interopRequireDefault(require('../ErrorCode'));
}

var _ProjectUtils;

function _load_ProjectUtils() {
  return _ProjectUtils = _interopRequireWildcard(require('../project/ProjectUtils'));
}

var _User;

function _load_User() {
  return _User = _interopRequireDefault(require('../User'));
}

var _XDLError;

function _load_XDLError() {
  return _XDLError = _interopRequireDefault(require('../XDLError'));
}

var _StandaloneBuildFlags;

function _load_StandaloneBuildFlags() {
  return _StandaloneBuildFlags = _interopRequireDefault(require('./StandaloneBuildFlags'));
}

var _StandaloneContext;

function _load_StandaloneContext() {
  return _StandaloneContext = _interopRequireDefault(require('./StandaloneContext'));
}

var _UrlUtils;

function _load_UrlUtils() {
  return _UrlUtils = _interopRequireWildcard(require('../UrlUtils'));
}

var _Versions;

function _load_Versions() {
  return _Versions = _interopRequireWildcard(require('../Versions'));
}

var _installPackageAsync;

function _load_installPackageAsync() {
  return _installPackageAsync = _interopRequireDefault(require('./installPackageAsync'));
}

var _Logger;

function _load_Logger() {
  return _Logger = _interopRequireDefault(require('./Logger'));
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
//# sourceMappingURL=../__sourcemaps__/detach/Detach.js.map
