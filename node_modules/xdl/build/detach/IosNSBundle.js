'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.configureAsync = undefined;

let _cleanPropertyListBackupsAsync = (() => {
  var _ref = _asyncToGenerator(function* (context, backupPath) {
    yield (_IosPlist || _load_IosPlist()).cleanBackupAsync(backupPath, 'EXShell', false);
    yield (_IosPlist || _load_IosPlist()).cleanBackupAsync(backupPath, 'Info', false);
    // TODO: support this in user contexts as well
    if (context.type === 'service') {
      const { projectName } = (_IosWorkspace || _load_IosWorkspace()).getPaths(context);
      yield (_IosPlist || _load_IosPlist()).cleanBackupAsync(backupPath, `${projectName}.entitlements`, false);
    }
  });

  return function _cleanPropertyListBackupsAsync(_x, _x2) {
    return _ref.apply(this, arguments);
  };
})();

/**
 * Write the manifest and JS bundle to the NSBundle.
 */


let _preloadManifestAndBundleAsync = (() => {
  var _ref2 = _asyncToGenerator(function* (manifest, supportingDirectory, manifestFilename, bundleFilename) {
    const bundleUrl = manifest.bundleUrl;
    yield (_fsExtra || _load_fsExtra()).default.writeFile(_path.default.join(supportingDirectory, manifestFilename), JSON.stringify(manifest));
    yield (0, (_ExponentTools || _load_ExponentTools()).saveUrlToPathAsync)(bundleUrl, _path.default.join(supportingDirectory, bundleFilename));
  });

  return function _preloadManifestAndBundleAsync(_x3, _x4, _x5, _x6) {
    return _ref2.apply(this, arguments);
  };
})();

/**
 *  This method only makes sense when operating on a context with sdk version < 26.
 */


let _maybeLegacyPreloadKernelManifestAndBundleAsync = (() => {
  var _ref3 = _asyncToGenerator(function* (context, manifestFilename, bundleFilename) {
    const { supportingDirectory } = (_IosWorkspace || _load_IosWorkspace()).getPaths(context);
    let sdkVersionSupported = yield (_IosWorkspace || _load_IosWorkspace()).getNewestSdkVersionSupportedAsync(context);

    if ((0, (_ExponentTools || _load_ExponentTools()).parseSdkMajorVersion)(sdkVersionSupported) < 26) {
      (_Logger || _load_Logger()).default.info('Preloading Expo kernel JS...');
      const kernelManifest = yield (0, (_ExponentTools || _load_ExponentTools()).getManifestAsync)(KERNEL_URL, {
        'Exponent-SDK-Version': sdkVersionSupported,
        'Exponent-Platform': 'ios',
        Accept: 'application/expo+json,application/json'
      });
      return _preloadManifestAndBundleAsync(kernelManifest, supportingDirectory, manifestFilename, bundleFilename);
    }
  });

  return function _maybeLegacyPreloadKernelManifestAndBundleAsync(_x7, _x8, _x9) {
    return _ref3.apply(this, arguments);
  };
})();

/**
 * Configure a standalone entitlements file.
 */


let _configureEntitlementsAsync = (() => {
  var _ref4 = _asyncToGenerator(function* (context) {
    if (context.type === 'user') {
      // don't modify .entitlements, print info/instructions
      const exp = context.data.exp;
      (_Logger || _load_Logger()).default.info('Your iOS ExpoKit project will not contain an .entitlements file by default. If you need specific Apple entitlements, enable them manually via Xcode or the Apple Developer website.');
      let keysToFlag = [];
      if (exp.ios && exp.ios.usesIcloudStorage) {
        keysToFlag.push('ios.usesIcloudStorage');
      }
      if (exp.ios && exp.ios.associatedDomains) {
        keysToFlag.push('ios.associatedDomains');
      }
      if (keysToFlag.length) {
        (_Logger || _load_Logger()).default.info('We noticed the following keys in your project which may require entitlements:');
        keysToFlag.forEach(function (key) {
          (_Logger || _load_Logger()).default.info(`  ${key}`);
        });
      }
      return {};
    } else {
      // modify the .entitlements file
      const { projectName, supportingDirectory } = (_IosWorkspace || _load_IosWorkspace()).getPaths(context);
      const manifest = context.data.manifest;
      const entitlementsFilename = `${projectName}.entitlements`;
      const appleTeamId = context.build.ios.appleTeamId;
      if (!(_fsExtra || _load_fsExtra()).default.existsSync(_path.default.join(supportingDirectory, entitlementsFilename))) {
        yield (_IosPlist || _load_IosPlist()).createBlankAsync(supportingDirectory, entitlementsFilename);
      }
      const result = (_IosPlist || _load_IosPlist()).modifyAsync(supportingDirectory, entitlementsFilename, function (entitlements) {
        // push notif entitlement changes based on build configuration
        entitlements['aps-environment'] = context.build.configuration === 'Release' ? 'production' : 'development';

        // remove iCloud-specific entitlements if the developer isn't using iCloud Storage with DocumentPicker
        if (manifest.ios && manifest.ios.usesIcloudStorage && appleTeamId) {
          entitlements['com.apple.developer.icloud-container-identifiers'] = ['iCloud.' + manifest.ios.bundleIdentifier];
          entitlements['com.apple.developer.ubiquity-container-identifiers'] = ['iCloud.' + manifest.ios.bundleIdentifier];
          entitlements['com.apple.developer.ubiquity-kvstore-identifier'] = appleTeamId + '.' + manifest.ios.bundleIdentifier;
          entitlements['com.apple.developer.icloud-services'] = ['CloudDocuments'];
        } else {
          ['com.apple.developer.icloud-container-identifiers', 'com.apple.developer.icloud-services', 'com.apple.developer.ubiquity-container-identifiers', 'com.apple.developer.ubiquity-kvstore-identifier'].forEach(function (key) {
            if (entitlements.hasOwnProperty(key)) {
              delete entitlements[key];
            }
          });
        }

        // Add app associated domains remove exp-specific ones.
        if (manifest.ios && manifest.ios.associatedDomains) {
          entitlements['com.apple.developer.associated-domains'] = manifest.ios.associatedDomains;
        } else if (entitlements.hasOwnProperty('com.apple.developer.associated-domains')) {
          delete entitlements['com.apple.developer.associated-domains'];
        }

        // for now, remove any merchant ID in shell apps
        // (TODO: better plan for payments)
        delete entitlements['com.apple.developer.in-app-payments'];

        return entitlements;
      });
      return result;
    }
  });

  return function _configureEntitlementsAsync(_x10) {
    return _ref4.apply(this, arguments);
  };
})();

/**
 *  Resolve the private config for a project.
 *  For standalone apps, this is copied into a separate context field context.data.privateConfig
 *  by the turtle builder. For a local project, this is available in app.json under ios.config.
 */


/**
 * Configure an iOS Info.plist for a standalone app.
 */
let _configureInfoPlistAsync = (() => {
  var _ref5 = _asyncToGenerator(function* (context) {
    const { supportingDirectory } = (_IosWorkspace || _load_IosWorkspace()).getPaths(context);
    const config = context.config;
    const privateConfig = _getPrivateConfig(context);

    let result = yield (_IosPlist || _load_IosPlist()).modifyAsync(supportingDirectory, 'Info', function (infoPlist) {
      // make sure this happens first:
      // apply any custom information from ios.infoPlist prior to all other exponent config
      let usageDescriptionKeysConfigured = {};
      if (config.ios && config.ios.infoPlist) {
        let extraConfig = config.ios.infoPlist;
        for (let key in extraConfig) {
          if (extraConfig.hasOwnProperty(key)) {
            infoPlist[key] = extraConfig[key];

            // if the user provides *UsageDescription keys, don't override them later.
            if (_isAppleUsageDescriptionKey(key)) {
              usageDescriptionKeysConfigured[key] = true;
            }
          }
        }
      }

      // bundle id
      infoPlist.CFBundleIdentifier = config.ios && config.ios.bundleIdentifier ? config.ios.bundleIdentifier : null;
      if (!infoPlist.CFBundleIdentifier) {
        throw new Error(`Cannot configure an iOS app with no bundle identifier.`);
      }

      // app name
      infoPlist.CFBundleName = config.name;
      infoPlist.CFBundleDisplayName = config.name;

      // determine app linking schemes
      let linkingSchemes = config.scheme ? [config.scheme] : [];
      if (config.facebookScheme && config.facebookScheme.startsWith('fb')) {
        linkingSchemes.push(config.facebookScheme);
      }

      if (privateConfig && privateConfig.googleSignIn && privateConfig.googleSignIn.reservedClientId) {
        linkingSchemes.push(privateConfig.googleSignIn.reservedClientId);
      }

      // remove exp scheme, add app scheme(s)
      infoPlist.CFBundleURLTypes = [{
        CFBundleURLSchemes: linkingSchemes
      }, {
        // Add the generic oauth redirect, it's important that it has the name
        // 'OAuthRedirect' so we can find it in app code.
        CFBundleURLName: 'OAuthRedirect',
        CFBundleURLSchemes: [infoPlist.CFBundleIdentifier]
      }];

      // add or remove other facebook config
      if (config.facebookAppId) {
        infoPlist.FacebookAppID = config.facebookAppId;
        let queriesSchemes = infoPlist.LSApplicationQueriesSchemes || [];
        queriesSchemes = queriesSchemes.concat(['fbapi', 'fb-messenger-api', 'fbauth2', 'fbshareextension']);
        infoPlist.LSApplicationQueriesSchemes = queriesSchemes;
      } else {
        delete infoPlist['FacebookAppID'];
      }
      if (config.facebookDisplayName) {
        infoPlist.FacebookDisplayName = config.facebookDisplayName;
      } else {
        delete infoPlist['FacebookDisplayName'];
      }

      // set ITSAppUsesNonExemptEncryption to let people skip manually
      // entering it in iTunes Connect
      if (privateConfig && privateConfig.hasOwnProperty('usesNonExemptEncryption') && privateConfig.usesNonExemptEncryption === false) {
        infoPlist.ITSAppUsesNonExemptEncryption = false;
      }

      // google maps api key
      if (privateConfig && privateConfig.googleMapsApiKey) {
        infoPlist.GMSApiKey = privateConfig.googleMapsApiKey;
      }

      // use version from manifest
      let version = config.version ? config.version : '0.0.0';
      let buildNumber = config.ios && config.ios.buildNumber ? config.ios.buildNumber : '1';
      infoPlist.CFBundleShortVersionString = version;
      infoPlist.CFBundleVersion = buildNumber;

      infoPlist.Fabric = {
        APIKey: privateConfig && privateConfig.fabric && privateConfig.fabric.apiKey || DEFAULT_FABRIC_KEY,
        Kits: [{
          KitInfo: {},
          KitName: 'Crashlytics'
        }]
      };

      if (privateConfig && privateConfig.branch) {
        infoPlist.branch_key = {
          live: privateConfig.branch.apiKey
        };
      }

      let permissionsAppName = config.name ? config.name : 'this app';
      for (let key in infoPlist) {
        if (infoPlist.hasOwnProperty(key) && _isAppleUsageDescriptionKey(key) && !usageDescriptionKeysConfigured.hasOwnProperty(key)) {
          infoPlist[key] = infoPlist[key].replace('Expo experiences', permissionsAppName);
        }
      }

      // 1 is iPhone, 2 is iPad
      infoPlist.UIDeviceFamily = config.ios && config.ios.supportsTablet ? [1, 2] : [1];

      // allow iPad-only
      if (config.ios && config.ios.isTabletOnly) {
        infoPlist.UIDeviceFamily = [2];
      }

      // context-specific plist changes
      if (context.type === 'user') {
        infoPlist = _configureInfoPlistForLocalDevelopment(infoPlist, context.data.exp);
        _logDeveloperInfoForLocalDevelopment(infoPlist);
      }

      return infoPlist;
    });
    return result;
  });

  return function _configureInfoPlistAsync(_x11) {
    return _ref5.apply(this, arguments);
  };
})();

/**
 *  Configure EXShell.plist for a standalone app.
 */


let _configureShellPlistAsync = (() => {
  var _ref6 = _asyncToGenerator(function* (context) {
    const { supportingDirectory } = (_IosWorkspace || _load_IosWorkspace()).getPaths(context);
    const config = context.config;
    const buildPhaseLogger = (_Logger || _load_Logger()).default.withFields({ buildPhase: 'configuring NSBundle' });

    yield (_IosPlist || _load_IosPlist()).modifyAsync(supportingDirectory, 'EXShell', function (shellPlist) {
      // older SDK versions rely on `isShell` flag in xdl
      if ((0, (_ExponentTools || _load_ExponentTools()).parseSdkMajorVersion)(config.sdkVersion) < 28) {
        shellPlist.isShell = true;
      }
      shellPlist.manifestUrl = context.published.url;
      shellPlist.releaseChannel = context.published.releaseChannel;
      if (context.data.testEnvironment) {
        shellPlist.testEnvironment = context.data.testEnvironment;
      }
      if (config.ios && config.ios.permissions) {
        shellPlist.permissions = config.ios.permissions;
      }
      if (context.type == 'user') {
        // disable manifest verification on detached apps until
        // the developer adds the correct entitlements to their bundle id.
        shellPlist.isManifestVerificationBypassed = true;
      }
      if (config.ios && config.ios.hasOwnProperty('isRemoteJSEnabled')) {
        // deprecated, overridden by updates.enabled if that exists
        shellPlist.areRemoteUpdatesEnabled = config.ios.isRemoteJSEnabled;
      }
      if (config.updates && config.updates.hasOwnProperty('enabled')) {
        // enable/disable code push if the developer provided specific behavior
        shellPlist.areRemoteUpdatesEnabled = config.updates.enabled;
      }
      if (!(0, (_ExponentTools || _load_ExponentTools()).manifestUsesSplashApi)(config, 'ios') && (0, (_ExponentTools || _load_ExponentTools()).parseSdkMajorVersion)(config.sdkVersion) < 28) {
        // for people still using the old loading api, hide the native splash screen.
        // we can remove this code eventually.
        shellPlist.isSplashScreenDisabled = true;
      }

      buildPhaseLogger.info('Using standalone config:', shellPlist);
      return shellPlist;
    });
  });

  return function _configureShellPlistAsync(_x12) {
    return _ref6.apply(this, arguments);
  };
})();

let _configureConstantsPlistAsync = (() => {
  var _ref7 = _asyncToGenerator(function* (context) {
    if (context.type === 'user') {
      return;
    }

    const { supportingDirectory } = (_IosWorkspace || _load_IosWorkspace()).getPaths(context);
    yield (_IosPlist || _load_IosPlist()).modifyAsync(supportingDirectory, 'EXBuildConstants', function (constantsConfig) {
      constantsConfig.API_SERVER_ENDPOINT = process.env.ENVIRONMENT === 'staging' ? 'https://staging.exp.host/--/api/v2/' : 'https://exp.host/--/api/v2/';
      return constantsConfig;
    });
  });

  return function _configureConstantsPlistAsync(_x13) {
    return _ref7.apply(this, arguments);
  };
})();

let configureAsync = (() => {
  var _ref8 = _asyncToGenerator(function* (context) {
    const buildPhaseLogger = (_Logger || _load_Logger()).default.withFields({ buildPhase: 'configuring NSBundle' });

    let {
      intermediatesDirectory,
      iosProjectDirectory,
      projectName,
      supportingDirectory
    } = (_IosWorkspace || _load_IosWorkspace()).getPaths(context);
    if (!context.published.url) {
      throw new Error(`Can't configure a NSBundle without a published url.`);
    }

    // ensure the intermediates directory is clean of any prior build's artifacts, in the event we
    // share directories across builds
    yield (_fsExtra || _load_fsExtra()).default.remove(intermediatesDirectory);

    try {
      // common configuration for all contexts
      buildPhaseLogger.info(`Modifying NSBundle configuration at ${supportingDirectory}...`);
      yield _configureInfoPlistAsync(context);
      yield _configureShellPlistAsync(context);
      yield _configureEntitlementsAsync(context);
      yield _configureConstantsPlistAsync(context);
      yield (_IosLaunchScreen || _load_IosLaunchScreen()).configureLaunchAssetsAsync(context, intermediatesDirectory);
      yield (_IosLocalization || _load_IosLocalization()).writeLocalizationResourcesAsync({
        supportingDirectory,
        context
      });

      if (context.type === 'user') {
        const iconPath = _path.default.join(iosProjectDirectory, projectName, 'Assets.xcassets', 'AppIcon.appiconset');
        yield (_IosIcons || _load_IosIcons()).createAndWriteIconsToPathAsync(context, iconPath);
      } else if (context.type === 'service') {
        buildPhaseLogger.info('Bundling assets...');
        try {
          yield (_AssetBundle || _load_AssetBundle()).bundleAsync(context, context.data.manifest.bundledAssets, supportingDirectory, context.data.manifest.sdkVersion === '24.0.0');
        } catch (e) {
          throw new Error(`Asset bundling failed: ${e}`);
        }
        buildPhaseLogger.info('Compiling resources...');
        yield (_IosAssetArchive || _load_IosAssetArchive()).buildAssetArchiveAsync(context, supportingDirectory, intermediatesDirectory);
        yield _preloadManifestAndBundleAsync(context.data.manifest, supportingDirectory, 'shell-app-manifest.json', 'shell-app.bundle');
      }

      yield _maybeLegacyPreloadKernelManifestAndBundleAsync(context, 'kernel-manifest.json', 'kernel.ios.bundle');
    } finally {
      buildPhaseLogger.info('Cleaning up iOS...');
      yield Promise.all([_cleanPropertyListBackupsAsync(context, supportingDirectory), (_fsExtra || _load_fsExtra()).default.remove(intermediatesDirectory)]);
    }
  });

  return function configureAsync(_x14) {
    return _ref8.apply(this, arguments);
  };
})();

var _fsExtra;

function _load_fsExtra() {
  return _fsExtra = _interopRequireDefault(require('fs-extra'));
}

var _path = _interopRequireDefault(require('path'));

var _ExponentTools;

function _load_ExponentTools() {
  return _ExponentTools = require('./ExponentTools');
}

var _IosAssetArchive;

function _load_IosAssetArchive() {
  return _IosAssetArchive = _interopRequireWildcard(require('./IosAssetArchive'));
}

var _AssetBundle;

function _load_AssetBundle() {
  return _AssetBundle = _interopRequireWildcard(require('./AssetBundle'));
}

var _IosIcons;

function _load_IosIcons() {
  return _IosIcons = _interopRequireWildcard(require('./IosIcons'));
}

var _IosPlist;

function _load_IosPlist() {
  return _IosPlist = _interopRequireWildcard(require('./IosPlist'));
}

var _IosLaunchScreen;

function _load_IosLaunchScreen() {
  return _IosLaunchScreen = _interopRequireWildcard(require('./IosLaunchScreen'));
}

var _IosWorkspace;

function _load_IosWorkspace() {
  return _IosWorkspace = _interopRequireWildcard(require('./IosWorkspace'));
}

var _StandaloneContext;

function _load_StandaloneContext() {
  return _StandaloneContext = _interopRequireDefault(require('./StandaloneContext'));
}

var _IosLocalization;

function _load_IosLocalization() {
  return _IosLocalization = _interopRequireWildcard(require('./IosLocalization'));
}

var _Logger;

function _load_Logger() {
  return _Logger = _interopRequireDefault(require('./Logger'));
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// TODO: move this somewhere else. this is duplicated in universe/exponent/template-files/keys,
// but xdl doesn't have access to that.
const DEFAULT_FABRIC_KEY = '81130e95ea13cd7ed9a4f455e96214902c721c99';
const KERNEL_URL = 'https://expo.io/@exponent/home';

function _configureInfoPlistForLocalDevelopment(config, exp) {
  // add detached scheme
  if (exp.isDetached && exp.detach.scheme) {
    if (!config.CFBundleURLTypes) {
      config.CFBundleURLTypes = [{
        CFBundleURLSchemes: []
      }];
    }
    config.CFBundleURLTypes[0].CFBundleURLSchemes.push(exp.detach.scheme);
  }
  // for local dev, don't specify device family here
  if (config.UIDeviceFamily) {
    delete config.UIDeviceFamily;
  }
  return config;
}

/**
 *  Prints warnings or info about the configured environment for local development.
 */
function _logDeveloperInfoForLocalDevelopment(infoPlist) {
  // warn about *UsageDescription changes
  let usageKeysConfigured = [];
  for (let key in infoPlist) {
    if (infoPlist.hasOwnProperty(key) && key.indexOf('UsageDescription') !== -1) {
      usageKeysConfigured.push(key);
    }
  }
  if (usageKeysConfigured.length) {
    (_Logger || _load_Logger()).default.info('We added some permissions keys to `Info.plist` in your detached iOS project:');
    usageKeysConfigured.forEach(key => {
      (_Logger || _load_Logger()).default.info(`  ${key}`);
    });
    (_Logger || _load_Logger()).default.info('You may want to revise them to include language appropriate to your project. You can also remove them if your app will never use the corresponding API. See the Apple docs for these keys.');
  }
}

function _getPrivateConfig(context) {
  let privateConfig;
  if (context.type === 'service') {
    privateConfig = context.data.privateConfig;
  } else if (context.type === 'user') {
    const exp = context.data.exp;
    if (exp && exp.ios) {
      privateConfig = exp.ios.config;
    }
  }
  return privateConfig;
}

function _isAppleUsageDescriptionKey(key) {
  return key.indexOf('UsageDescription') !== -1;
}exports.configureAsync = configureAsync;
//# sourceMappingURL=../__sourcemaps__/detach/IosNSBundle.js.map
