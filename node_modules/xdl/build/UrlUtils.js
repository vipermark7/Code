'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isHttps = exports.constructUrlAsync = exports.constructBundleQueryParamsAsync = exports.constructDebuggerHostAsync = exports.constructAssetsUrlAsync = exports.constructSourceMapUrlAsync = exports.constructPublishUrlAsync = exports.constructUrlWithExtensionAsync = exports.constructLogUrlAsync = exports.constructHostUriAsync = exports.constructManifestUrlAsync = exports.constructBundleUrlAsync = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

let constructBundleUrlAsync = exports.constructBundleUrlAsync = (() => {
  var _ref = _asyncToGenerator(function* (projectRoot, opts, requestHostname) {
    return constructUrlAsync(projectRoot, opts, true, requestHostname);
  });

  return function constructBundleUrlAsync(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
})();

let constructManifestUrlAsync = exports.constructManifestUrlAsync = (() => {
  var _ref2 = _asyncToGenerator(function* (projectRoot, opts, requestHostname) {
    return constructUrlAsync(projectRoot, opts, false, requestHostname);
  });

  return function constructManifestUrlAsync(_x4, _x5, _x6) {
    return _ref2.apply(this, arguments);
  };
})();

// gets the base manifest URL and removes the scheme


let constructHostUriAsync = exports.constructHostUriAsync = (() => {
  var _ref3 = _asyncToGenerator(function* (projectRoot, requestHostname) {
    let urlString = yield constructUrlAsync(projectRoot, null, false, requestHostname);
    // we need to use node's legacy urlObject api since the newer one doesn't like empty protocols
    let urlObj = _url.default.parse(urlString);
    urlObj.protocol = '';
    urlObj.slashes = false;
    return _url.default.format(urlObj);
  });

  return function constructHostUriAsync(_x7, _x8) {
    return _ref3.apply(this, arguments);
  };
})();

let constructLogUrlAsync = exports.constructLogUrlAsync = (() => {
  var _ref4 = _asyncToGenerator(function* (projectRoot, requestHostname) {
    let baseUrl = yield constructUrlAsync(projectRoot, { urlType: 'http' }, false, requestHostname);
    return `${baseUrl}/logs`;
  });

  return function constructLogUrlAsync(_x9, _x10) {
    return _ref4.apply(this, arguments);
  };
})();

let constructUrlWithExtensionAsync = exports.constructUrlWithExtensionAsync = (() => {
  var _ref5 = _asyncToGenerator(function* (projectRoot, entryPoint, ext, requestHostname, opts) {
    const defaultOpts = {
      dev: false,
      minify: true
    };
    opts = opts || defaultOpts;
    let bundleUrl = yield constructBundleUrlAsync(projectRoot, {
      hostType: 'localhost',
      urlType: 'http'
    }, requestHostname);

    let mainModulePath = guessMainModulePath(entryPoint);
    bundleUrl += `/${mainModulePath}.${ext}`;

    let queryParams = yield constructBundleQueryParamsAsync(projectRoot, opts, requestHostname);
    return `${bundleUrl}?${queryParams}`;
  });

  return function constructUrlWithExtensionAsync(_x11, _x12, _x13, _x14, _x15) {
    return _ref5.apply(this, arguments);
  };
})();

let constructPublishUrlAsync = exports.constructPublishUrlAsync = (() => {
  var _ref6 = _asyncToGenerator(function* (projectRoot, entryPoint, requestHostname, opts) {
    return yield constructUrlWithExtensionAsync(projectRoot, entryPoint, 'bundle', requestHostname, opts);
  });

  return function constructPublishUrlAsync(_x16, _x17, _x18, _x19) {
    return _ref6.apply(this, arguments);
  };
})();

let constructSourceMapUrlAsync = exports.constructSourceMapUrlAsync = (() => {
  var _ref7 = _asyncToGenerator(function* (projectRoot, entryPoint, requestHostname) {
    return yield constructUrlWithExtensionAsync(projectRoot, entryPoint, 'map', requestHostname);
  });

  return function constructSourceMapUrlAsync(_x20, _x21, _x22) {
    return _ref7.apply(this, arguments);
  };
})();

let constructAssetsUrlAsync = exports.constructAssetsUrlAsync = (() => {
  var _ref8 = _asyncToGenerator(function* (projectRoot, entryPoint, requestHostname) {
    return yield constructUrlWithExtensionAsync(projectRoot, entryPoint, 'assets', requestHostname);
  });

  return function constructAssetsUrlAsync(_x23, _x24, _x25) {
    return _ref8.apply(this, arguments);
  };
})();

let constructDebuggerHostAsync = exports.constructDebuggerHostAsync = (() => {
  var _ref9 = _asyncToGenerator(function* (projectRoot, requestHostname) {
    return constructUrlAsync(projectRoot, {
      urlType: 'no-protocol'
    }, true, requestHostname);
  });

  return function constructDebuggerHostAsync(_x26, _x27) {
    return _ref9.apply(this, arguments);
  };
})();

let constructBundleQueryParamsAsync = exports.constructBundleQueryParamsAsync = (() => {
  var _ref10 = _asyncToGenerator(function* (projectRoot, opts) {
    let queryParams = `dev=${encodeURIComponent(!!opts.dev)}`;

    if (opts.hasOwnProperty('strict')) {
      queryParams += `&strict=${encodeURIComponent(!!opts.strict)}`;
    }

    if (opts.hasOwnProperty('minify')) {
      queryParams += `&minify=${encodeURIComponent(!!opts.minify)}`;
    }

    queryParams += '&hot=false';

    let { exp, pkg } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectRoot);

    // Use an absolute path here so that we can not worry about symlinks/relative requires
    let pluginModule = (_ProjectUtils || _load_ProjectUtils()).resolveModule('expo/tools/hashAssetFiles', projectRoot, exp);
    queryParams += `&assetPlugin=${encodeURIComponent(pluginModule)}`;

    // Only sdk-10.1.0+ supports the assetPlugin parameter. We use only the
    // major version in the sdkVersion field, so check for 11.0.0 to be sure.
    let supportsAssetPlugins = (_Versions || _load_Versions()).gteSdkVersion(exp, '11.0.0');
    if (!supportsAssetPlugins) {
      queryParams += '&includeAssetFileHashes=true';
    }

    return queryParams;
  });

  return function constructBundleQueryParamsAsync(_x28, _x29) {
    return _ref10.apply(this, arguments);
  };
})();

let constructUrlAsync = exports.constructUrlAsync = (() => {
  var _ref11 = _asyncToGenerator(function* (projectRoot, opts, isPackager, requestHostname) {
    if (opts) {
      let schema = (_joi || _load_joi()).default.object().keys({
        urlType: (_joi || _load_joi()).default.any().valid('exp', 'http', 'redirect', 'no-protocol'),
        lanType: (_joi || _load_joi()).default.any().valid('ip', 'hostname'),
        hostType: (_joi || _load_joi()).default.any().valid('localhost', 'lan', 'tunnel'),
        dev: (_joi || _load_joi()).default.boolean(),
        strict: (_joi || _load_joi()).default.boolean(),
        minify: (_joi || _load_joi()).default.boolean(),
        urlRandomness: (_joi || _load_joi()).default.string().optional().allow(null)
      });

      const { error } = (_joi || _load_joi()).default.validate(opts, schema);
      if (error) {
        throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.INVALID_OPTIONS, error.toString());
      }
    }

    let defaultOpts = yield (_ProjectSettings || _load_ProjectSettings()).getPackagerOptsAsync(projectRoot);
    if (!opts) {
      opts = defaultOpts;
    } else {
      opts = Object.assign({}, defaultOpts, opts);
    }

    let packagerInfo = yield (_ProjectSettings || _load_ProjectSettings()).readPackagerInfoAsync(projectRoot);

    let protocol;
    if (opts.urlType === 'http') {
      protocol = 'http';
    } else if (opts.urlType === 'no-protocol') {
      protocol = null;
    } else {
      protocol = 'exp';

      let { exp } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectRoot);
      if (exp.detach) {
        if (exp.scheme && (_Versions || _load_Versions()).gteSdkVersion(exp, '27.0.0')) {
          protocol = exp.scheme;
        } else if (exp.detach.scheme) {
          // must keep this fallback in place for older projects
          // and those detached with an older version of xdl
          protocol = exp.detach.scheme;
        }
      }
    }

    let hostname;
    let port;

    const proxyURL = isPackager ? process.env.EXPO_PACKAGER_PROXY_URL : process.env.EXPO_MANIFEST_PROXY_URL;
    if (proxyURL) {
      const parsedProxyURL = _url.default.parse(proxyURL);
      hostname = parsedProxyURL.hostname;
      port = parsedProxyURL.port;
      if (parsedProxyURL.protocol === 'https:') {
        if (protocol === 'http') {
          protocol = 'https';
        }
        if (!port) {
          port = '443';
        }
      }
    } else if (opts.hostType === 'localhost' || requestHostname === 'localhost') {
      hostname = '127.0.0.1';
      port = isPackager ? packagerInfo.packagerPort : packagerInfo.expoServerPort;
    } else if (opts.hostType === 'lan' || (_Config || _load_Config()).default.offline) {
      if (process.env.EXPO_PACKAGER_HOSTNAME) {
        hostname = process.env.EXPO_PACKAGER_HOSTNAME.trim();
      } else if (process.env.REACT_NATIVE_PACKAGER_HOSTNAME) {
        hostname = process.env.REACT_NATIVE_PACKAGER_HOSTNAME.trim();
      } else if (opts.lanType === 'ip') {
        if (requestHostname) {
          hostname = requestHostname;
        } else {
          hostname = (_ip || _load_ip()).default.address();
        }
      } else {
        // Some old versions of OSX work with hostname but not local ip address.
        hostname = _os.default.hostname();
      }
      port = isPackager ? packagerInfo.packagerPort : packagerInfo.expoServerPort;
    } else {
      let ngrokUrl = isPackager ? packagerInfo.packagerNgrokUrl : packagerInfo.expoServerNgrokUrl;
      if (!ngrokUrl) {
        (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', 'Tunnel URL not found, falled back to LAN URL.', 'tunnel-url-not-found');
        return constructUrlAsync(projectRoot, _extends({}, opts, { hostType: 'lan' }), isPackager, requestHostname);
      } else {
        (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'tunnel-url-not-found');
        let pnu = _url.default.parse(ngrokUrl);
        hostname = pnu.hostname;
        port = pnu.port;
      }
    }

    let url_ = '';
    if (protocol) {
      url_ += `${protocol}://`;
    }

    if (!hostname) {
      throw new Error('Hostname cannot be inferred.');
    }

    url_ += hostname;

    if (port) {
      url_ += `:${port}`;
    } else {
      // Android HMR breaks without this :|
      url_ += ':80';
    }

    if (opts.urlType === 'redirect') {
      return `https://exp.host/--/to-exp/${encodeURIComponent(url_)}`;
    }

    return url_;
  });

  return function constructUrlAsync(_x30, _x31, _x32, _x33) {
    return _ref11.apply(this, arguments);
  };
})();

let isHttps = exports.isHttps = (() => {
  var _ref12 = _asyncToGenerator(function* (url) {
    return (_validator || _load_validator()).default.isURL(url, { protocols: ['https'] });
  });

  return function isHttps(_x34) {
    return _ref12.apply(this, arguments);
  };
})();

exports.guessMainModulePath = guessMainModulePath;
exports.randomIdentifier = randomIdentifier;
exports.sevenDigitIdentifier = sevenDigitIdentifier;
exports.randomIdentifierForUser = randomIdentifierForUser;
exports.someRandomness = someRandomness;
exports.domainify = domainify;
exports.getPlatformSpecificBundleUrl = getPlatformSpecificBundleUrl;

var _joi;

function _load_joi() {
  return _joi = _interopRequireDefault(require('joi'));
}

var _os = _interopRequireDefault(require('os'));

var _path = _interopRequireDefault(require('path'));

var _url = _interopRequireDefault(require('url'));

var _validator;

function _load_validator() {
  return _validator = _interopRequireDefault(require('validator'));
}

var _ip;

function _load_ip() {
  return _ip = _interopRequireDefault(require('./ip'));
}

var _Config;

function _load_Config() {
  return _Config = _interopRequireDefault(require('./Config'));
}

var _ErrorCode;

function _load_ErrorCode() {
  return _ErrorCode = _interopRequireDefault(require('./ErrorCode'));
}

var _Exp;

function _load_Exp() {
  return _Exp = _interopRequireWildcard(require('./Exp'));
}

var _ProjectSettings;

function _load_ProjectSettings() {
  return _ProjectSettings = _interopRequireWildcard(require('./ProjectSettings'));
}

var _ProjectUtils;

function _load_ProjectUtils() {
  return _ProjectUtils = _interopRequireWildcard(require('./project/ProjectUtils'));
}

var _Versions;

function _load_Versions() {
  return _Versions = _interopRequireWildcard(require('./Versions'));
}

var _XDLError;

function _load_XDLError() {
  return _XDLError = _interopRequireDefault(require('./XDLError'));
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function guessMainModulePath(entryPoint) {
  return entryPoint.replace(/\.js$/, '');
}

function randomIdentifier(length = 6) {
  let alphabet = '23456789qwertyuipasdfghjkzxcvbnm';
  let result = '';
  for (let i = 0; i < length; i++) {
    let j = Math.floor(Math.random() * alphabet.length);
    let c = alphabet.substr(j, 1);
    result += c;
  }
  return result;
}

function sevenDigitIdentifier() {
  return `${randomIdentifier(3)}-${randomIdentifier(4)}`;
}

function randomIdentifierForUser(username) {
  return `${username}-${randomIdentifier(3)}-${randomIdentifier(2)}`;
}

function someRandomness() {
  return [randomIdentifier(2), randomIdentifier(3)].join('-');
}

function domainify(s) {
  return s.toLowerCase().replace(/[^a-z0-9-]/g, '-').replace(/^-+/, '').replace(/-+$/, '');
}

function getPlatformSpecificBundleUrl(url, platform) {
  if (url.includes((_Exp || _load_Exp()).ENTRY_POINT_PLATFORM_TEMPLATE_STRING)) {
    return url.replace((_Exp || _load_Exp()).ENTRY_POINT_PLATFORM_TEMPLATE_STRING, platform);
  } else {
    return url;
  }
}
//# sourceMappingURL=__sourcemaps__/UrlUtils.js.map
