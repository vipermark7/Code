Object.defineProperty(exports, "__esModule", { value: true });
var SQLite = require('nativescript-sqlite');
var MASTER_TABLE_NAME = 'sqlite_master';
function execute(dbName, tableName, sqlQueries, write) {
    if (write === void 0) { write = false; }
    var escapedTableName = "\"" + tableName + "\"";
    var isMaster = tableName === MASTER_TABLE_NAME;
    return new SQLite(dbName)
        .then(function (db) {
        // This will set the database to return the results as an array of objects
        db.resultType(SQLite.RESULTSASOBJECT);
        if (!isMaster) {
            db
                .execSQL("CREATE TABLE IF NOT EXISTS " + escapedTableName + " (key BLOB PRIMARY KEY NOT NULL, value BLOB NOT NULL)")
                .then(function () { return db; });
        }
        return db;
    })
        .then(function (db) {
        var promises = sqlQueries.map(function (_a) {
            var sqlQuery = _a[0], _b = _a[1], parameters = _b === void 0 ? [] : _b;
            var promise;
            if (write) {
                promise = db.execSQL(sqlQuery.replace('#{table}', escapedTableName), parameters);
            }
            else {
                promise = db.all(sqlQuery.replace('#{table}', escapedTableName), parameters);
            }
            return promise
                .then(function (resultSet) {
                if (resultSet === void 0) { resultSet = []; }
                if (!write && Array.isArray(resultSet) && resultSet.length > 0) {
                    return resultSet.map(function (row) {
                        try {
                            return isMaster ? row.value : JSON.parse(row.value);
                        }
                        catch (error) {
                            // Catch the error
                            return row.value;
                        }
                    });
                }
                return resultSet;
            });
        });
        return Promise.all(promises)
            .then(function (results) {
            return results.reduce(function ($result, result) {
                return $result.concat(result);
            }, []);
        })
            .then(function (result) {
            return db
                .close()
                .then(function () { return result; });
        })
            .catch(function (error) {
            return db
                .close()
                .then(function () {
                throw error;
            });
        });
    });
}
function find(dbName, tableName) {
    return __awaiter(this, void 0, void 0, function () {
        var docs;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, execute(dbName, tableName, [['SELECT value FROM #{table}']])];
                case 1:
                    docs = _a.sent();
                    return [2 /*return*/, docs];
            }
        });
    });
}
exports.find = find;
function count(dbName, tableName) {
    return __awaiter(this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, execute(dbName, tableName, [['SELECT COUNT(DISTINCT key) AS value FROM #{table}']])];
                case 1:
                    result = _a.sent();
                    return [2 /*return*/, result.shift() || 0];
            }
        });
    });
}
exports.count = count;
function findById(dbName, tableName, id) {
    return __awaiter(this, void 0, void 0, function () {
        var docs;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, execute(dbName, tableName, [['SELECT value FROM #{table} WHERE key = ?', [id]]])];
                case 1:
                    docs = _a.sent();
                    return [2 /*return*/, docs.shift()];
            }
        });
    });
}
exports.findById = findById;
function save(dbName, tableName, docs) {
    if (docs === void 0) { docs = []; }
    return __awaiter(this, void 0, void 0, function () {
        var sqlQueries;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    sqlQueries = docs.map(function (doc) { return ['REPLACE INTO #{table} (key, value) VALUES (?, ?)', [doc._id, JSON.stringify(doc)]]; });
                    return [4 /*yield*/, execute(dbName, tableName, sqlQueries, true)];
                case 1:
                    _a.sent();
                    return [2 /*return*/, docs];
            }
        });
    });
}
exports.save = save;
function removeById(dbName, tableName, id) {
    return __awaiter(this, void 0, void 0, function () {
        var responses;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, execute(dbName, tableName, [['DELETE FROM #{table} WHERE key = ?', [id]]], true)];
                case 1:
                    responses = _a.sent();
                    return [2 /*return*/, responses.shift()];
            }
        });
    });
}
exports.removeById = removeById;
function clear(dbName, tableName) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, execute(dbName, tableName, [['DROP TABLE IF EXISTS #{table}']], true)];
                case 1:
                    _a.sent();
                    return [2 /*return*/, true];
            }
        });
    });
}
exports.clear = clear;
function clearDatabase(dbName, exclude) {
    if (exclude === void 0) { exclude = []; }
    return __awaiter(this, void 0, void 0, function () {
        var tables;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, execute(dbName, MASTER_TABLE_NAME, [['SELECT name AS value FROM #{table} WHERE type = ?', ['table']]])];
                case 1:
                    tables = _a.sent();
                    if (!(tables.length > 0)) return [3 /*break*/, 3];
                    return [4 /*yield*/, Promise.all(tables.map(function (tableName) {
                            if (exclude.indexOf(tableName) === -1) {
                                return execute(dbName, tableName, [['DROP TABLE IF EXISTS #{table}']], true);
                            }
                            return null;
                        }))];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3: return [2 /*return*/, true];
            }
        });
    });
}
exports.clearDatabase = clearDatabase;
//# sourceMappingURL=sqlite.js.map