Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var kinvey_1 = require("../errors/kinvey");
var http_1 = require("../http");
var MAX_BACKOFF = 32 * 1000;
function transformMetadata(file, metadata) {
    if (file === void 0) { file = {}; }
    if (metadata === void 0) { metadata = {}; }
    var fileMetadata = Object.assign({}, {
        filename: file._filename || file.name,
        public: false,
        size: file.size || file.length,
        mimeType: file.mimeType || file.type || 'application/octet-stream'
    }, metadata);
    fileMetadata._filename = fileMetadata.filename;
    delete fileMetadata.filename;
    fileMetadata._public = fileMetadata.public;
    delete fileMetadata.public;
    return fileMetadata;
}
exports.transformMetadata = transformMetadata;
function saveFileMetadata(metadata, options) {
    if (options === void 0) { options = {}; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var request, response;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (metadata.size <= 0) {
                        throw new kinvey_1.KinveyError('Unable to create a file with a size of 0.');
                    }
                    request = new http_1.KinveyHttpRequest({
                        method: metadata._id ? http_1.HttpRequestMethod.PUT : http_1.HttpRequestMethod.POST,
                        headers: new http_1.KinveyHttpHeaders({
                            'X-Kinvey-Content-Type': metadata.mimeType
                        }),
                        auth: http_1.KinveyHttpAuth.SessionOrMaster,
                        url: metadata._id ? http_1.formatKinveyBaasUrl(http_1.KinveyBaasNamespace.Blob, "/" + metadata._id) : http_1.formatKinveyBaasUrl(http_1.KinveyBaasNamespace.Blob),
                        body: metadata,
                        timeout: options.timeout
                    });
                    return [4 /*yield*/, request.execute()];
                case 1:
                    response = _a.sent();
                    return [2 /*return*/, response.data];
            }
        });
    });
}
exports.saveFileMetadata = saveFileMetadata;
function checkUploadStatus(url, headers, metadata, timeout) {
    var requestHeaders = new http_1.HttpHeaders(headers);
    requestHeaders.set('Content-Type', metadata.mimeType);
    requestHeaders.set('Content-Range', "bytes */" + metadata.size);
    var request = new http_1.HttpRequest({
        method: http_1.HttpRequestMethod.PUT,
        headers: requestHeaders,
        url: url,
        timeout: timeout
    });
    return request.execute();
}
exports.checkUploadStatus = checkUploadStatus;
function getStartIndex(rangeHeader, max) {
    var start = rangeHeader ? parseInt(rangeHeader.split('-')[1], 10) + 1 : 0;
    return start >= max ? max - 1 : start;
}
exports.getStartIndex = getStartIndex;
function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
}
exports.randomInt = randomInt;
function uploadFile(url, file, metadata, options) {
    if (options === void 0) { options = {}; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var _a, count, _b, maxBackoff, _c, start, requestHeaders, request, response, backoff_1;
        return tslib_1.__generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _a = options.count, count = _a === void 0 ? 0 : _a, _b = options.maxBackoff, maxBackoff = _b === void 0 ? MAX_BACKOFF : _b;
                    _c = options.start, start = _c === void 0 ? 0 : _c;
                    requestHeaders = new http_1.HttpHeaders(options.headers);
                    requestHeaders.set('Content-Type', metadata.mimeType);
                    requestHeaders.set('Content-Range', "bytes " + options.start + "-" + (metadata.size - 1) + "/" + metadata.size);
                    request = new http_1.HttpRequest({
                        method: http_1.HttpRequestMethod.PUT,
                        headers: requestHeaders,
                        url: url,
                        body: file.slice(options.start, metadata.size),
                        timeout: options.timeout
                    });
                    return [4 /*yield*/, request.execute()];
                case 1:
                    response = _d.sent();
                    if (!!response.isSuccess()) return [3 /*break*/, 4];
                    if (!(response.statusCode >= 500 && response.statusCode < 600)) return [3 /*break*/, 3];
                    backoff_1 = (Math.pow(2, options.count)) + randomInt(1, 1001);
                    if (!(backoff_1 < options.maxBackoff)) return [3 /*break*/, 3];
                    return [4 /*yield*/, new Promise(function (resolve) {
                            setTimeout(resolve, backoff_1);
                        })];
                case 2:
                    _d.sent();
                    return [2 /*return*/, uploadFile(url, file, metadata, { count: count + 1, start: start, maxBackoff: maxBackoff })];
                case 3: throw response.error;
                case 4:
                    // The upload isn't complete and we must upload the rest of the file
                    if (response.statusCode === 308) {
                        start = getStartIndex(response.headers.get('Range'), metadata.size);
                        return [2 /*return*/, uploadFile(url, file, metadata, { count: 0, start: start, maxBackoff: maxBackoff })];
                    }
                    return [2 /*return*/, response.data];
            }
        });
    });
}
exports.uploadFile = uploadFile;
function upload(file, metadata, options) {
    if (file === void 0) { file = {}; }
    if (metadata === void 0) { metadata = {}; }
    if (options === void 0) { options = {}; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var fileMetadata, kinveyFile, uploadStatusResponse, uploadOptions;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    fileMetadata = transformMetadata(file, metadata);
                    return [4 /*yield*/, saveFileMetadata(fileMetadata, options)];
                case 1:
                    kinveyFile = _a.sent();
                    return [4 /*yield*/, checkUploadStatus(kinveyFile._uploadURL, kinveyFile._requiredHeaders, fileMetadata, options.timeout)];
                case 2:
                    uploadStatusResponse = _a.sent();
                    if (!uploadStatusResponse.isSuccess()) {
                        throw uploadStatusResponse.error;
                    }
                    if (!(uploadStatusResponse.statusCode !== 200 && uploadStatusResponse.statusCode !== 201)) return [3 /*break*/, 4];
                    if (uploadStatusResponse.statusCode !== 308) {
                        // TODO: Here we should handle redirects according to location header, but this generally shouldn't happen
                        throw new kinvey_1.KinveyError('Unexpected response for upload file status check request.');
                    }
                    uploadOptions = {
                        start: getStartIndex(uploadStatusResponse.headers.get('Range'), metadata.size),
                        timeout: options.timeout,
                        maxBackoff: options.maxBackoff,
                        headers: kinveyFile._requiredHeaders
                    };
                    return [4 /*yield*/, uploadFile(kinveyFile._uploadURL, file, fileMetadata, uploadOptions)];
                case 3:
                    _a.sent();
                    _a.label = 4;
                case 4:
                    delete kinveyFile._expiresAt;
                    delete kinveyFile._requiredHeaders;
                    delete kinveyFile._uploadURL;
                    kinveyFile._data = file;
                    return [2 /*return*/, kinveyFile];
            }
        });
    });
}
exports.upload = upload;
//# sourceMappingURL=upload.js.map