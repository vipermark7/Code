Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var url_1 = require("url");
var http_1 = require("../../http");
var kinvey_1 = require("../../errors/kinvey");
var utils_1 = require("./utils");
var popup_1 = require("./popup");
function loginWithPopup(clientId, redirectUri, version) {
    var _this = this;
    return new Promise(function (resolve, reject) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var url, popup, redirected;
        var _this = this;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    url = http_1.formatKinveyAuthUrl("/" + utils_1.getVersion(version) + "/oauth/auth", {
                        client_id: clientId,
                        redirect_uri: redirectUri,
                        response_type: 'code',
                        scope: 'openid'
                    });
                    return [4 /*yield*/, popup_1.open(url)];
                case 1:
                    popup = _a.sent();
                    redirected = false;
                    popup.onLoaded(function (event) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                        var parsedUrl, _a, code, error, error_description, error_1;
                        return tslib_1.__generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    _b.trys.push([0, 3, , 4]);
                                    if (!(event.url && event.url.indexOf(redirectUri) === 0 && redirected === false)) return [3 /*break*/, 2];
                                    parsedUrl = url_1.parse(event.url, true);
                                    _a = parsedUrl.query, code = _a.code, error = _a.error, error_description = _a.error_description;
                                    redirected = true;
                                    popup.removeAllListeners();
                                    return [4 /*yield*/, popup.close()];
                                case 1:
                                    _b.sent();
                                    if (code) {
                                        resolve(code);
                                    }
                                    else if (error) {
                                        reject(new kinvey_1.KinveyError(error));
                                    }
                                    else {
                                        reject(new kinvey_1.KinveyError('No code or error was provided.'));
                                    }
                                    _b.label = 2;
                                case 2: return [3 /*break*/, 4];
                                case 3:
                                    error_1 = _b.sent();
                                    return [3 /*break*/, 4];
                                case 4: return [2 /*return*/];
                            }
                        });
                    }); });
                    popup.onClosed(function () {
                        if (!redirected) {
                            popup.removeAllListeners();
                            reject(new kinvey_1.KinveyError('Login has been cancelled.'));
                        }
                    });
                    return [2 /*return*/];
            }
        });
    }); });
}
exports.loginWithPopup = loginWithPopup;
//# sourceMappingURL=loginWithPopup.js.map